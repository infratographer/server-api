// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package testclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"go.infratographer.com/server-api/internal/ent/generated"
	"go.infratographer.com/x/gidx"
)

type IPAddressable interface {
	IsIPAddressable()
	GetID() gidx.PrefixedID
}

// An object with an ID.
// Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
type Node interface {
	IsNode()
	// The id of the object.
	GetID() gidx.PrefixedID
}

type Entity interface {
	IsEntity()
}

// Input information to create a server cpu type.
type CreateServerCPUTypeInput struct {
	// The name of the vendor for the server cpu type.
	Vendor string `json:"vendor"`
	// The mode of the server cpu type.
	Model string `json:"model"`
	// The clock speed of the server cpu type.
	ClockSpeed string `json:"clockSpeed"`
	// The number of cores for the server cpu type.
	CoreCount int64 `json:"coreCount"`
}

// Input information to create a server chassis.
type CreateServerChassisInput struct {
	// The ID for the parent of this chassis.
	ParentChassisID gidx.PrefixedID `json:"parentChassisID"`
	// The serial number of the server chassis.
	Serial              string          `json:"serial"`
	ServerID            gidx.PrefixedID `json:"serverID"`
	ServerChassisTypeID gidx.PrefixedID `json:"serverChassisTypeID"`
}

// Input information to create a server chassis type.
type CreateServerChassisTypeInput struct {
	// The name of the vendor for the server chassis type.
	Vendor string `json:"vendor"`
	// The mode of the server chassis type.
	Model string `json:"model"`
	// The height of the server chassis type.
	Height string `json:"height"`
	// Whether the server chassis type is full depth.
	IsFullDepth bool `json:"isFullDepth"`
	// The ID for the parent of this chassis type.
	ParentChassisTypeID gidx.PrefixedID `json:"parentChassisTypeID"`
}

// Input information to create a server component.
type CreateServerComponentInput struct {
	// The name of the server component.
	Name string `json:"name"`
	// The name of the vendor of the server component.
	Vendor string `json:"vendor"`
	// The model of the server component.
	Model string `json:"model"`
	// The serial number of the server component.
	Serial          string          `json:"serial"`
	ComponentTypeID gidx.PrefixedID `json:"componentTypeID"`
	ServerID        gidx.PrefixedID `json:"serverID"`
}

// Input information to create a server component type.
type CreateServerComponentTypeInput struct {
	// The name of the server component type.
	Name string `json:"name"`
}

// Create a new server.
type CreateServerInput struct {
	// The name of the server.
	Name string `json:"name"`
	// The description of the server.
	Description *string `json:"description,omitempty"`
	// The ID for the owner of this server.
	OwnerID gidx.PrefixedID `json:"ownerID"`
	// The ID for the location of this server.
	LocationID   gidx.PrefixedID   `json:"locationID"`
	ProviderID   gidx.PrefixedID   `json:"providerID"`
	ServerTypeID gidx.PrefixedID   `json:"serverTypeID"`
	ComponentIDs []gidx.PrefixedID `json:"componentIDs,omitempty"`
}

// Input information to create a server provider.
type CreateServerProviderInput struct {
	// The name of the server provider.
	Name string `json:"name"`
	// The ID for the resource provider of this server.
	ResourceProviderID gidx.PrefixedID `json:"resourceProviderID"`
}

// Input information to create a server type.
type CreateServerTypeInput struct {
	// The name of the server type.
	Name string `json:"name"`
	// The ID for the owner of this server type.
	OwnerID gidx.PrefixedID `json:"ownerID"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Server struct {
	// The ID of the server.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server.
	Name string `json:"name"`
	// The description of the server.
	Description *string `json:"description,omitempty"`
	// The server provider for the server.
	Provider   generated.Provider        `json:"serverProvider"`
	ServerType ServerType                `json:"serverType"`
	Components ServerComponentConnection `json:"components"`
}

func (Server) IsIPAddressable()            {}
func (this Server) GetID() gidx.PrefixedID { return this.ID }

func (Server) IsNode() {}

// The id of the object.

func (Server) IsEntity() {}

type ServerCPUType struct {
	// The ID of the server cpu type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the vendor for the server cpu type.
	Vendor string `json:"vendor"`
	// The mode of the server cpu type.
	Model string `json:"model"`
	// The clock speed of the server cpu type.
	ClockSpeed string `json:"clockSpeed"`
	// The number of cores for the server cpu type.
	CoreCount int64 `json:"coreCount"`
}

func (ServerCPUType) IsNode() {}

// The id of the object.
func (this ServerCPUType) GetID() gidx.PrefixedID { return this.ID }

func (ServerCPUType) IsEntity() {}

// A connection to a list of items.
type ServerCPUTypeConnection struct {
	// A list of edges.
	Edges []*ServerCPUTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverCPUTypeCreate
type ServerCPUTypeCreatePayload struct {
	// The created server cpu type.
	ServerCPUType ServerCPUType `json:"serverCPUType"`
}

// Return response from serverCPUTypeDelete
type ServerCPUTypeDeletePayload struct {
	// The ID of the deleted server cpu type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerCPUTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerCPUType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerCPUType connections
type ServerCPUTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerCPUTypes.
	Field ServerCPUTypeOrderField `json:"field"`
}

// Return response from serverCPUTypeUpdate
type ServerCPUTypeUpdatePayload struct {
	// The updated server cpu type.
	ServerCPUType ServerCPUType `json:"serverCPUType"`
}

// ServerCPUTypeWhereInput is used for filtering ServerCPUType objects.
// Input was generated by ent.
type ServerCPUTypeWhereInput struct {
	Not *ServerCPUTypeWhereInput   `json:"not,omitempty"`
	And []*ServerCPUTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerCPUTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// vendor field predicates
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNeq          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGt           *string  `json:"vendorGT,omitempty"`
	VendorGte          *string  `json:"vendorGTE,omitempty"`
	VendorLt           *string  `json:"vendorLT,omitempty"`
	VendorLte          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`
	// model field predicates
	Model             *string  `json:"model,omitempty"`
	ModelNeq          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGt           *string  `json:"modelGT,omitempty"`
	ModelGte          *string  `json:"modelGTE,omitempty"`
	ModelLt           *string  `json:"modelLT,omitempty"`
	ModelLte          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`
	// clock_speed field predicates
	ClockSpeed             *string  `json:"clockSpeed,omitempty"`
	ClockSpeedNeq          *string  `json:"clockSpeedNEQ,omitempty"`
	ClockSpeedIn           []string `json:"clockSpeedIn,omitempty"`
	ClockSpeedNotIn        []string `json:"clockSpeedNotIn,omitempty"`
	ClockSpeedGt           *string  `json:"clockSpeedGT,omitempty"`
	ClockSpeedGte          *string  `json:"clockSpeedGTE,omitempty"`
	ClockSpeedLt           *string  `json:"clockSpeedLT,omitempty"`
	ClockSpeedLte          *string  `json:"clockSpeedLTE,omitempty"`
	ClockSpeedContains     *string  `json:"clockSpeedContains,omitempty"`
	ClockSpeedHasPrefix    *string  `json:"clockSpeedHasPrefix,omitempty"`
	ClockSpeedHasSuffix    *string  `json:"clockSpeedHasSuffix,omitempty"`
	ClockSpeedEqualFold    *string  `json:"clockSpeedEqualFold,omitempty"`
	ClockSpeedContainsFold *string  `json:"clockSpeedContainsFold,omitempty"`
	// core_count field predicates
	CoreCount      *int64  `json:"coreCount,omitempty"`
	CoreCountNeq   *int64  `json:"coreCountNEQ,omitempty"`
	CoreCountIn    []int64 `json:"coreCountIn,omitempty"`
	CoreCountNotIn []int64 `json:"coreCountNotIn,omitempty"`
	CoreCountGt    *int64  `json:"coreCountGT,omitempty"`
	CoreCountGte   *int64  `json:"coreCountGTE,omitempty"`
	CoreCountLt    *int64  `json:"coreCountLT,omitempty"`
	CoreCountLte   *int64  `json:"coreCountLTE,omitempty"`
}

type ServerChassis struct {
	// The ID of the server chassis.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The serial number of the server chassis.
	Serial            string            `json:"serial"`
	Server            Server            `json:"server"`
	ServerChassisType ServerChassisType `json:"serverChassisType"`
}

func (ServerChassis) IsNode() {}

// The id of the object.
func (this ServerChassis) GetID() gidx.PrefixedID { return this.ID }

func (ServerChassis) IsEntity() {}

// A connection to a list of items.
type ServerChassisConnection struct {
	// A list of edges.
	Edges []*ServerChassisEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverChassisCreate
type ServerChassisCreatePayload struct {
	// The created server chassis.
	ServerChassis ServerChassis `json:"serverChassis"`
}

// Return response from serverChassisDelete
type ServerChassisDeletePayload struct {
	// The ID of the deleted server chassis.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerChassisEdge struct {
	// The item at the end of the edge.
	Node *ServerChassis `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerChassis connections
type ServerChassisOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerChasses.
	Field ServerChassisOrderField `json:"field"`
}

type ServerChassisType struct {
	// The ID of the server chassis type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the vendor for the server chassis type.
	Vendor string `json:"vendor"`
	// The mode of the server chassis type.
	Model string `json:"model"`
	// The height of the server chassis type.
	Height string `json:"height"`
	// Whether the server chassis type is full depth.
	IsFullDepth bool `json:"isFullDepth"`
}

func (ServerChassisType) IsNode() {}

// The id of the object.
func (this ServerChassisType) GetID() gidx.PrefixedID { return this.ID }

func (ServerChassisType) IsEntity() {}

// A connection to a list of items.
type ServerChassisTypeConnection struct {
	// A list of edges.
	Edges []*ServerChassisTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverChassisTypeCreate
type ServerChassisTypeCreatePayload struct {
	// The created server chassis type.
	ServerChassisType ServerChassisType `json:"serverChassisType"`
}

// Return response from serverChassisTypeDelete
type ServerChassisTypeDeletePayload struct {
	// The ID of the deleted server chassis type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerChassisTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerChassisType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerChassisType connections
type ServerChassisTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerChassisTypes.
	Field ServerChassisTypeOrderField `json:"field"`
}

// Return response from serverChassisTypeUpdate
type ServerChassisTypeUpdatePayload struct {
	// The updated server chassis type.
	ServerChassisType ServerChassisType `json:"serverChassisType"`
}

// ServerChassisTypeWhereInput is used for filtering ServerChassisType objects.
// Input was generated by ent.
type ServerChassisTypeWhereInput struct {
	Not *ServerChassisTypeWhereInput   `json:"not,omitempty"`
	And []*ServerChassisTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerChassisTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// vendor field predicates
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNeq          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGt           *string  `json:"vendorGT,omitempty"`
	VendorGte          *string  `json:"vendorGTE,omitempty"`
	VendorLt           *string  `json:"vendorLT,omitempty"`
	VendorLte          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`
	// model field predicates
	Model             *string  `json:"model,omitempty"`
	ModelNeq          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGt           *string  `json:"modelGT,omitempty"`
	ModelGte          *string  `json:"modelGTE,omitempty"`
	ModelLt           *string  `json:"modelLT,omitempty"`
	ModelLte          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`
	// height field predicates
	Height             *string  `json:"height,omitempty"`
	HeightNeq          *string  `json:"heightNEQ,omitempty"`
	HeightIn           []string `json:"heightIn,omitempty"`
	HeightNotIn        []string `json:"heightNotIn,omitempty"`
	HeightGt           *string  `json:"heightGT,omitempty"`
	HeightGte          *string  `json:"heightGTE,omitempty"`
	HeightLt           *string  `json:"heightLT,omitempty"`
	HeightLte          *string  `json:"heightLTE,omitempty"`
	HeightContains     *string  `json:"heightContains,omitempty"`
	HeightHasPrefix    *string  `json:"heightHasPrefix,omitempty"`
	HeightHasSuffix    *string  `json:"heightHasSuffix,omitempty"`
	HeightEqualFold    *string  `json:"heightEqualFold,omitempty"`
	HeightContainsFold *string  `json:"heightContainsFold,omitempty"`
	// is_full_depth field predicates
	IsFullDepth    *bool `json:"isFullDepth,omitempty"`
	IsFullDepthNeq *bool `json:"isFullDepthNEQ,omitempty"`
}

// Return response from serverChassisUpdate
type ServerChassisUpdatePayload struct {
	// The updated server chassis.
	ServerChassis ServerChassis `json:"serverChassis"`
}

// ServerChassisWhereInput is used for filtering ServerChassis objects.
// Input was generated by ent.
type ServerChassisWhereInput struct {
	Not *ServerChassisWhereInput   `json:"not,omitempty"`
	And []*ServerChassisWhereInput `json:"and,omitempty"`
	Or  []*ServerChassisWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// serial field predicates
	Serial             *string  `json:"serial,omitempty"`
	SerialNeq          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGt           *string  `json:"serialGT,omitempty"`
	SerialGte          *string  `json:"serialGTE,omitempty"`
	SerialLt           *string  `json:"serialLT,omitempty"`
	SerialLte          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`
	// server edge predicates
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
	// server_chassis_type edge predicates
	HasServerChassisType     *bool                          `json:"hasServerChassisType,omitempty"`
	HasServerChassisTypeWith []*ServerChassisTypeWhereInput `json:"hasServerChassisTypeWith,omitempty"`
}

type ServerComponent struct {
	// The ID of the server component.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server component.
	Name string `json:"name"`
	// The name of the vendor of the server component.
	Vendor string `json:"vendor"`
	// The model of the server component.
	Model string `json:"model"`
	// The serial number of the server component.
	Serial string `json:"serial"`
	// The server component type for the server component.
	ComponentType ServerComponentType `json:"serverComponentType"`
	Server        Server              `json:"server"`
}

func (ServerComponent) IsNode() {}

// The id of the object.
func (this ServerComponent) GetID() gidx.PrefixedID { return this.ID }

func (ServerComponent) IsEntity() {}

// A connection to a list of items.
type ServerComponentConnection struct {
	// A list of edges.
	Edges []*ServerComponentEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverComponentCreate
type ServerComponentCreatePayload struct {
	// The created server component.
	ServerComponent ServerComponent `json:"serverComponent"`
}

// Return response from serverComponentDelete
type ServerComponentDeletePayload struct {
	// The ID of the deleted server component.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerComponentEdge struct {
	// The item at the end of the edge.
	Node *ServerComponent `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerComponent connections
type ServerComponentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerComponents.
	Field ServerComponentOrderField `json:"field"`
}

type ServerComponentType struct {
	// The ID of the server component type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server component type.
	Name string `json:"name"`
}

func (ServerComponentType) IsNode() {}

// The id of the object.
func (this ServerComponentType) GetID() gidx.PrefixedID { return this.ID }

func (ServerComponentType) IsEntity() {}

// A connection to a list of items.
type ServerComponentTypeConnection struct {
	// A list of edges.
	Edges []*ServerComponentTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverComponentTypeCreate
type ServerComponentTypeCreatePayload struct {
	// The created server component type.
	ServerComponentType ServerComponentType `json:"serverComponentType"`
}

// Return response from serverComponentTypeDelete
type ServerComponentTypeDeletePayload struct {
	// The ID of the deleted server component type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerComponentTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerComponentType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerComponentType connections
type ServerComponentTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerComponentTypes.
	Field ServerComponentTypeOrderField `json:"field"`
}

// Return response from serverComponentTypeUpdate
type ServerComponentTypeUpdatePayload struct {
	// The updated server component type.
	ServerComponentType ServerComponentType `json:"serverComponentType"`
}

// ServerComponentTypeWhereInput is used for filtering ServerComponentType objects.
// Input was generated by ent.
type ServerComponentTypeWhereInput struct {
	Not *ServerComponentTypeWhereInput   `json:"not,omitempty"`
	And []*ServerComponentTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerComponentTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Return response from serverComponentUpdate
type ServerComponentUpdatePayload struct {
	// The updated server component.
	ServerComponent ServerComponent `json:"serverComponent"`
}

// ServerComponentWhereInput is used for filtering ServerComponent objects.
// Input was generated by ent.
type ServerComponentWhereInput struct {
	Not *ServerComponentWhereInput   `json:"not,omitempty"`
	And []*ServerComponentWhereInput `json:"and,omitempty"`
	Or  []*ServerComponentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// vendor field predicates
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNeq          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGt           *string  `json:"vendorGT,omitempty"`
	VendorGte          *string  `json:"vendorGTE,omitempty"`
	VendorLt           *string  `json:"vendorLT,omitempty"`
	VendorLte          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`
	// model field predicates
	Model             *string  `json:"model,omitempty"`
	ModelNeq          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGt           *string  `json:"modelGT,omitempty"`
	ModelGte          *string  `json:"modelGTE,omitempty"`
	ModelLt           *string  `json:"modelLT,omitempty"`
	ModelLte          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`
	// serial field predicates
	Serial             *string  `json:"serial,omitempty"`
	SerialNeq          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGt           *string  `json:"serialGT,omitempty"`
	SerialGte          *string  `json:"serialGTE,omitempty"`
	SerialLt           *string  `json:"serialLT,omitempty"`
	SerialLte          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`
	// component_type edge predicates
	HasComponentType     *bool                            `json:"hasComponentType,omitempty"`
	HasComponentTypeWith []*ServerComponentTypeWhereInput `json:"hasComponentTypeWith,omitempty"`
	// server edge predicates
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
}

// A connection to a list of items.
type ServerConnection struct {
	// A list of edges.
	Edges []*ServerEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverCreate
type ServerCreatePayload struct {
	// The created server.
	Server Server `json:"server"`
}

// Return response from serverDelete
type ServerDeletePayload struct {
	// The ID of the deleted server.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerEdge struct {
	// The item at the end of the edge.
	Node *Server `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Server connections
type ServerOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Servers.
	Field ServerOrderField `json:"field"`
}

// A connection to a list of items.
type ServerProviderConnection struct {
	// A list of edges.
	Edges []*ServerProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverProviderCreate
type ServerProviderCreatePayload struct {
	// The created server provider.
	ServerProvider generated.Provider `json:"serverProvider"`
}

// Return response from serverProviderDelete
type ServerProviderDeletePayload struct {
	// The ID of the deleted server provider.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerProviderEdge struct {
	// The item at the end of the edge.
	Node *generated.Provider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerProvider connections
type ServerProviderOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerProviders.
	Field ServerProviderOrderField `json:"field"`
}

// Return response from serverProviderUpdate
type ServerProviderUpdatePayload struct {
	// The updated server provider.
	ServerProvider generated.Provider `json:"serverProvider"`
}

// ServerProviderWhereInput is used for filtering Provider objects.
// Input was generated by ent.
type ServerProviderWhereInput struct {
	Not *ServerProviderWhereInput   `json:"not,omitempty"`
	And []*ServerProviderWhereInput `json:"and,omitempty"`
	Or  []*ServerProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// servers edge predicates
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

type ServerType struct {
	// The ID of the server type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server type.
	Name    string           `json:"name"`
	Servers ServerConnection `json:"servers"`
}

func (ServerType) IsNode() {}

// The id of the object.
func (this ServerType) GetID() gidx.PrefixedID { return this.ID }

func (ServerType) IsEntity() {}

// A connection to a list of items.
type ServerTypeConnection struct {
	// A list of edges.
	Edges []*ServerTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverTypeCreate
type ServerTypeCreatePayload struct {
	// The created server type.
	ServerType ServerType `json:"serverType"`
}

// Return response from serverTypeDelete
type ServerTypeDeletePayload struct {
	// The ID of the deleted server type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerType connections
type ServerTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerTypes.
	Field ServerTypeOrderField `json:"field"`
}

// Return response from serverTypeUpdate
type ServerTypeUpdatePayload struct {
	// The updated server type.
	ServerType ServerType `json:"serverType"`
}

// ServerTypeWhereInput is used for filtering ServerType objects.
// Input was generated by ent.
type ServerTypeWhereInput struct {
	Not *ServerTypeWhereInput   `json:"not,omitempty"`
	And []*ServerTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// servers edge predicates
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// Return response from serverUpdate
type ServerUpdatePayload struct {
	// The updated server.
	Server Server `json:"server"`
}

// ServerWhereInput is used for filtering Server objects.
// Input was generated by ent.
type ServerWhereInput struct {
	Not *ServerWhereInput   `json:"not,omitempty"`
	And []*ServerWhereInput `json:"and,omitempty"`
	Or  []*ServerWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// provider edge predicates
	HasProvider     *bool                       `json:"hasProvider,omitempty"`
	HasProviderWith []*ServerProviderWhereInput `json:"hasProviderWith,omitempty"`
	// server_type edge predicates
	HasServerType     *bool                   `json:"hasServerType,omitempty"`
	HasServerTypeWith []*ServerTypeWhereInput `json:"hasServerTypeWith,omitempty"`
	// components edge predicates
	HasComponents     *bool                        `json:"hasComponents,omitempty"`
	HasComponentsWith []*ServerComponentWhereInput `json:"hasComponentsWith,omitempty"`
}

// Input information to update a server cpu type.
type UpdateServerCPUTypeInput struct {
	// The name of the vendor for the server cpu type.
	Vendor *string `json:"vendor,omitempty"`
	// The mode of the server cpu type.
	Model *string `json:"model,omitempty"`
	// The clock speed of the server cpu type.
	ClockSpeed *string `json:"clockSpeed,omitempty"`
	// The number of cores for the server cpu type.
	CoreCount *int64 `json:"coreCount,omitempty"`
}

// Input information to update a server chassis.
type UpdateServerChassisInput struct {
	// The serial number of the server chassis.
	Serial *string `json:"serial,omitempty"`
}

// Input information to update a server chassis type.
type UpdateServerChassisTypeInput struct {
	// The name of the vendor for the server chassis type.
	Vendor *string `json:"vendor,omitempty"`
	// The mode of the server chassis type.
	Model *string `json:"model,omitempty"`
	// The height of the server chassis type.
	Height *string `json:"height,omitempty"`
	// Whether the server chassis type is full depth.
	IsFullDepth *bool `json:"isFullDepth,omitempty"`
}

// Input information to update a server component.
type UpdateServerComponentInput struct {
	// The name of the server component.
	Name *string `json:"name,omitempty"`
	// The name of the vendor of the server component.
	Vendor *string `json:"vendor,omitempty"`
	// The model of the server component.
	Model *string `json:"model,omitempty"`
	// The serial number of the server component.
	Serial *string `json:"serial,omitempty"`
}

// Input information to update a server component type.
type UpdateServerComponentTypeInput struct {
	// The name of the server component type.
	Name *string `json:"name,omitempty"`
}

// Update an existing server.
type UpdateServerInput struct {
	// The name of the server.
	Name *string `json:"name,omitempty"`
	// The description of the server.
	Description        *string           `json:"description,omitempty"`
	ClearDescription   *bool             `json:"clearDescription,omitempty"`
	AddComponentIDs    []gidx.PrefixedID `json:"addComponentIDs,omitempty"`
	RemoveComponentIDs []gidx.PrefixedID `json:"removeComponentIDs,omitempty"`
	ClearComponents    *bool             `json:"clearComponents,omitempty"`
}

// Input information to update a server provider.
type UpdateServerProviderInput struct {
	// The name of the server provider.
	Name *string `json:"name,omitempty"`
}

// Input information to update a server type.
type UpdateServerTypeInput struct {
	// The name of the server type.
	Name *string `json:"name,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerCPUType connections can be ordered.
type ServerCPUTypeOrderField string

const (
	ServerCPUTypeOrderFieldID        ServerCPUTypeOrderField = "ID"
	ServerCPUTypeOrderFieldCreatedAt ServerCPUTypeOrderField = "CREATED_AT"
	ServerCPUTypeOrderFieldUpdatedAt ServerCPUTypeOrderField = "UPDATED_AT"
	ServerCPUTypeOrderFieldName      ServerCPUTypeOrderField = "NAME"
)

var AllServerCPUTypeOrderField = []ServerCPUTypeOrderField{
	ServerCPUTypeOrderFieldID,
	ServerCPUTypeOrderFieldCreatedAt,
	ServerCPUTypeOrderFieldUpdatedAt,
	ServerCPUTypeOrderFieldName,
}

func (e ServerCPUTypeOrderField) IsValid() bool {
	switch e {
	case ServerCPUTypeOrderFieldID, ServerCPUTypeOrderFieldCreatedAt, ServerCPUTypeOrderFieldUpdatedAt, ServerCPUTypeOrderFieldName:
		return true
	}
	return false
}

func (e ServerCPUTypeOrderField) String() string {
	return string(e)
}

func (e *ServerCPUTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerCPUTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerCPUTypeOrderField", str)
	}
	return nil
}

func (e ServerCPUTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerChassis connections can be ordered.
type ServerChassisOrderField string

const (
	ServerChassisOrderFieldID                ServerChassisOrderField = "ID"
	ServerChassisOrderFieldCreatedAt         ServerChassisOrderField = "CREATED_AT"
	ServerChassisOrderFieldUpdatedAt         ServerChassisOrderField = "UPDATED_AT"
	ServerChassisOrderFieldServerChassisType ServerChassisOrderField = "SERVER_CHASSIS_TYPE"
	ServerChassisOrderFieldParentChassis     ServerChassisOrderField = "PARENT_CHASSIS"
	ServerChassisOrderFieldServer            ServerChassisOrderField = "SERVER"
)

var AllServerChassisOrderField = []ServerChassisOrderField{
	ServerChassisOrderFieldID,
	ServerChassisOrderFieldCreatedAt,
	ServerChassisOrderFieldUpdatedAt,
	ServerChassisOrderFieldServerChassisType,
	ServerChassisOrderFieldParentChassis,
	ServerChassisOrderFieldServer,
}

func (e ServerChassisOrderField) IsValid() bool {
	switch e {
	case ServerChassisOrderFieldID, ServerChassisOrderFieldCreatedAt, ServerChassisOrderFieldUpdatedAt, ServerChassisOrderFieldServerChassisType, ServerChassisOrderFieldParentChassis, ServerChassisOrderFieldServer:
		return true
	}
	return false
}

func (e ServerChassisOrderField) String() string {
	return string(e)
}

func (e *ServerChassisOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerChassisOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerChassisOrderField", str)
	}
	return nil
}

func (e ServerChassisOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerChassisType connections can be ordered.
type ServerChassisTypeOrderField string

const (
	ServerChassisTypeOrderFieldID                ServerChassisTypeOrderField = "ID"
	ServerChassisTypeOrderFieldCreatedAt         ServerChassisTypeOrderField = "CREATED_AT"
	ServerChassisTypeOrderFieldUpdatedAt         ServerChassisTypeOrderField = "UPDATED_AT"
	ServerChassisTypeOrderFieldName              ServerChassisTypeOrderField = "NAME"
	ServerChassisTypeOrderFieldParentChassisType ServerChassisTypeOrderField = "PARENT_CHASSIS_TYPE"
)

var AllServerChassisTypeOrderField = []ServerChassisTypeOrderField{
	ServerChassisTypeOrderFieldID,
	ServerChassisTypeOrderFieldCreatedAt,
	ServerChassisTypeOrderFieldUpdatedAt,
	ServerChassisTypeOrderFieldName,
	ServerChassisTypeOrderFieldParentChassisType,
}

func (e ServerChassisTypeOrderField) IsValid() bool {
	switch e {
	case ServerChassisTypeOrderFieldID, ServerChassisTypeOrderFieldCreatedAt, ServerChassisTypeOrderFieldUpdatedAt, ServerChassisTypeOrderFieldName, ServerChassisTypeOrderFieldParentChassisType:
		return true
	}
	return false
}

func (e ServerChassisTypeOrderField) String() string {
	return string(e)
}

func (e *ServerChassisTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerChassisTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerChassisTypeOrderField", str)
	}
	return nil
}

func (e ServerChassisTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerComponent connections can be ordered.
type ServerComponentOrderField string

const (
	ServerComponentOrderFieldID        ServerComponentOrderField = "ID"
	ServerComponentOrderFieldCreatedAt ServerComponentOrderField = "CREATED_AT"
	ServerComponentOrderFieldUpdatedAt ServerComponentOrderField = "UPDATED_AT"
	ServerComponentOrderFieldName      ServerComponentOrderField = "NAME"
	ServerComponentOrderFieldVendor    ServerComponentOrderField = "VENDOR"
	ServerComponentOrderFieldModel     ServerComponentOrderField = "MODEL"
	ServerComponentOrderFieldSerial    ServerComponentOrderField = "SERIAL"
)

var AllServerComponentOrderField = []ServerComponentOrderField{
	ServerComponentOrderFieldID,
	ServerComponentOrderFieldCreatedAt,
	ServerComponentOrderFieldUpdatedAt,
	ServerComponentOrderFieldName,
	ServerComponentOrderFieldVendor,
	ServerComponentOrderFieldModel,
	ServerComponentOrderFieldSerial,
}

func (e ServerComponentOrderField) IsValid() bool {
	switch e {
	case ServerComponentOrderFieldID, ServerComponentOrderFieldCreatedAt, ServerComponentOrderFieldUpdatedAt, ServerComponentOrderFieldName, ServerComponentOrderFieldVendor, ServerComponentOrderFieldModel, ServerComponentOrderFieldSerial:
		return true
	}
	return false
}

func (e ServerComponentOrderField) String() string {
	return string(e)
}

func (e *ServerComponentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerComponentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerComponentOrderField", str)
	}
	return nil
}

func (e ServerComponentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerComponentType connections can be ordered.
type ServerComponentTypeOrderField string

const (
	ServerComponentTypeOrderFieldID        ServerComponentTypeOrderField = "ID"
	ServerComponentTypeOrderFieldCreatedAt ServerComponentTypeOrderField = "CREATED_AT"
	ServerComponentTypeOrderFieldUpdatedAt ServerComponentTypeOrderField = "UPDATED_AT"
	ServerComponentTypeOrderFieldName      ServerComponentTypeOrderField = "NAME"
)

var AllServerComponentTypeOrderField = []ServerComponentTypeOrderField{
	ServerComponentTypeOrderFieldID,
	ServerComponentTypeOrderFieldCreatedAt,
	ServerComponentTypeOrderFieldUpdatedAt,
	ServerComponentTypeOrderFieldName,
}

func (e ServerComponentTypeOrderField) IsValid() bool {
	switch e {
	case ServerComponentTypeOrderFieldID, ServerComponentTypeOrderFieldCreatedAt, ServerComponentTypeOrderFieldUpdatedAt, ServerComponentTypeOrderFieldName:
		return true
	}
	return false
}

func (e ServerComponentTypeOrderField) String() string {
	return string(e)
}

func (e *ServerComponentTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerComponentTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerComponentTypeOrderField", str)
	}
	return nil
}

func (e ServerComponentTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Server connections can be ordered.
type ServerOrderField string

const (
	ServerOrderFieldID          ServerOrderField = "ID"
	ServerOrderFieldCreatedAt   ServerOrderField = "CREATED_AT"
	ServerOrderFieldUpdatedAt   ServerOrderField = "UPDATED_AT"
	ServerOrderFieldName        ServerOrderField = "NAME"
	ServerOrderFieldDescription ServerOrderField = "DESCRIPTION"
	ServerOrderFieldOwner       ServerOrderField = "OWNER"
	ServerOrderFieldServerType  ServerOrderField = "SERVER_TYPE"
)

var AllServerOrderField = []ServerOrderField{
	ServerOrderFieldID,
	ServerOrderFieldCreatedAt,
	ServerOrderFieldUpdatedAt,
	ServerOrderFieldName,
	ServerOrderFieldDescription,
	ServerOrderFieldOwner,
	ServerOrderFieldServerType,
}

func (e ServerOrderField) IsValid() bool {
	switch e {
	case ServerOrderFieldID, ServerOrderFieldCreatedAt, ServerOrderFieldUpdatedAt, ServerOrderFieldName, ServerOrderFieldDescription, ServerOrderFieldOwner, ServerOrderFieldServerType:
		return true
	}
	return false
}

func (e ServerOrderField) String() string {
	return string(e)
}

func (e *ServerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerOrderField", str)
	}
	return nil
}

func (e ServerOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerProvider connections can be ordered.
type ServerProviderOrderField string

const (
	ServerProviderOrderFieldID               ServerProviderOrderField = "ID"
	ServerProviderOrderFieldCreatedAt        ServerProviderOrderField = "CREATED_AT"
	ServerProviderOrderFieldUpdatedAt        ServerProviderOrderField = "UPDATED_AT"
	ServerProviderOrderFieldName             ServerProviderOrderField = "NAME"
	ServerProviderOrderFieldResourceProvider ServerProviderOrderField = "RESOURCE_PROVIDER"
)

var AllServerProviderOrderField = []ServerProviderOrderField{
	ServerProviderOrderFieldID,
	ServerProviderOrderFieldCreatedAt,
	ServerProviderOrderFieldUpdatedAt,
	ServerProviderOrderFieldName,
	ServerProviderOrderFieldResourceProvider,
}

func (e ServerProviderOrderField) IsValid() bool {
	switch e {
	case ServerProviderOrderFieldID, ServerProviderOrderFieldCreatedAt, ServerProviderOrderFieldUpdatedAt, ServerProviderOrderFieldName, ServerProviderOrderFieldResourceProvider:
		return true
	}
	return false
}

func (e ServerProviderOrderField) String() string {
	return string(e)
}

func (e *ServerProviderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerProviderOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerProviderOrderField", str)
	}
	return nil
}

func (e ServerProviderOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerType connections can be ordered.
type ServerTypeOrderField string

const (
	ServerTypeOrderFieldID        ServerTypeOrderField = "ID"
	ServerTypeOrderFieldCreatedAt ServerTypeOrderField = "CREATED_AT"
	ServerTypeOrderFieldUpdatedAt ServerTypeOrderField = "UPDATED_AT"
	ServerTypeOrderFieldName      ServerTypeOrderField = "NAME"
	ServerTypeOrderFieldOwner     ServerTypeOrderField = "OWNER"
)

var AllServerTypeOrderField = []ServerTypeOrderField{
	ServerTypeOrderFieldID,
	ServerTypeOrderFieldCreatedAt,
	ServerTypeOrderFieldUpdatedAt,
	ServerTypeOrderFieldName,
	ServerTypeOrderFieldOwner,
}

func (e ServerTypeOrderField) IsValid() bool {
	switch e {
	case ServerTypeOrderFieldID, ServerTypeOrderFieldCreatedAt, ServerTypeOrderFieldUpdatedAt, ServerTypeOrderFieldName, ServerTypeOrderFieldOwner:
		return true
	}
	return false
}

func (e ServerTypeOrderField) String() string {
	return string(e)
}

func (e *ServerTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerTypeOrderField", str)
	}
	return nil
}

func (e ServerTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
