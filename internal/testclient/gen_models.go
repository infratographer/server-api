// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package testclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"go.infratographer.com/server-api/internal/ent/generated"
	"go.infratographer.com/x/gidx"
)

type IPAddressable interface {
	IsIPAddressable()
	GetID() gidx.PrefixedID
}

// An object with an ID.
// Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
type Node interface {
	IsNode()
	// The id of the object.
	GetID() gidx.PrefixedID
}

type Entity interface {
	IsEntity()
}

// Input information to create a server attribute.
type CreateServerAttributeInput struct {
	// The name of the server attribute.
	Name string `json:"name"`
	// The value of the server attribute.
	Value    string          `json:"value"`
	ServerID gidx.PrefixedID `json:"serverID"`
}

// Input information to create a server component.
type CreateServerComponentInput struct {
	// The name of the server component.
	Name string `json:"name"`
	// The name of the vendor of the server component.
	Vendor string `json:"vendor"`
	// The model of the server component.
	Model string `json:"model"`
	// The serial number of the server component.
	Serial          string          `json:"serial"`
	ComponentTypeID gidx.PrefixedID `json:"componentTypeID"`
	ServerID        gidx.PrefixedID `json:"serverID"`
}

// Input information to create a server component type.
type CreateServerComponentTypeInput struct {
	// The name of the server component type.
	Name string `json:"name"`
}

// Create a new server.
type CreateServerInput struct {
	// The name of the server.
	Name string `json:"name"`
	// The description of the server.
	Description *string `json:"description,omitempty"`
	// The ID for the owner of this server.
	OwnerID gidx.PrefixedID `json:"ownerID"`
	// The ID for the location of this server.
	LocationID   gidx.PrefixedID   `json:"locationID"`
	ProviderID   gidx.PrefixedID   `json:"providerID"`
	ServerTypeID gidx.PrefixedID   `json:"serverTypeID"`
	ComponentIDs []gidx.PrefixedID `json:"componentIDs,omitempty"`
	AttributeIDs []gidx.PrefixedID `json:"attributeIDs,omitempty"`
}

// Input information to create a server provider.
type CreateServerProviderInput struct {
	// The name of the server provider.
	Name string `json:"name"`
	// The ID for the owner of this server.
	OwnerID gidx.PrefixedID `json:"ownerID"`
}

// Input information to create a server type.
type CreateServerTypeInput struct {
	// The name of the server type.
	Name string `json:"name"`
	// The ID for the owner of this server type.
	OwnerID gidx.PrefixedID `json:"ownerID"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Server struct {
	// The ID of the server.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server.
	Name string `json:"name"`
	// The description of the server.
	Description *string `json:"description,omitempty"`
	// The server provider for the server.
	Provider   generated.Provider        `json:"serverProvider"`
	ServerType ServerType                `json:"serverType"`
	Components ServerComponentConnection `json:"components"`
	Attributes ServerAttributeConnection `json:"attributes"`
}

func (Server) IsIPAddressable()            {}
func (this Server) GetID() gidx.PrefixedID { return this.ID }

func (Server) IsNode() {}

// The id of the object.

func (Server) IsEntity() {}

type ServerAttribute struct {
	// The ID of the server attribute.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server attribute.
	Name string `json:"name"`
	// The value of the server attribute.
	Value  string `json:"value"`
	Server Server `json:"server"`
}

func (ServerAttribute) IsNode() {}

// The id of the object.
func (this ServerAttribute) GetID() gidx.PrefixedID { return this.ID }

func (ServerAttribute) IsEntity() {}

// A connection to a list of items.
type ServerAttributeConnection struct {
	// A list of edges.
	Edges []*ServerAttributeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverAttributeCreate
type ServerAttributeCreatePayload struct {
	// The created server attribute.
	ServerAttribute ServerAttribute `json:"serverAttribute"`
}

// Return response from serverAttributeDelete
type ServerAttributeDeletePayload struct {
	// The ID of the deleted server attribute.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerAttributeEdge struct {
	// The item at the end of the edge.
	Node *ServerAttribute `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerAttribute connections
type ServerAttributeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerAttributes.
	Field ServerAttributeOrderField `json:"field"`
}

// Return response from serverAttributeUpdate
type ServerAttributeUpdatePayload struct {
	// The updated server attribute.
	ServerAttribute ServerAttribute `json:"serverAttribute"`
}

// ServerAttributeWhereInput is used for filtering ServerAttribute objects.
// Input was generated by ent.
type ServerAttributeWhereInput struct {
	Not *ServerAttributeWhereInput   `json:"not,omitempty"`
	And []*ServerAttributeWhereInput `json:"and,omitempty"`
	Or  []*ServerAttributeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// value field predicates
	Value             *string  `json:"value,omitempty"`
	ValueNeq          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGt           *string  `json:"valueGT,omitempty"`
	ValueGte          *string  `json:"valueGTE,omitempty"`
	ValueLt           *string  `json:"valueLT,omitempty"`
	ValueLte          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
	// server edge predicates
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
}

type ServerComponent struct {
	// The ID of the server component.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server component.
	Name string `json:"name"`
	// The name of the vendor of the server component.
	Vendor string `json:"vendor"`
	// The model of the server component.
	Model string `json:"model"`
	// The serial number of the server component.
	Serial string `json:"serial"`
	// The server component type for the server component.
	ComponentType ServerComponentType `json:"serverComponentType"`
	Server        Server              `json:"server"`
}

func (ServerComponent) IsNode() {}

// The id of the object.
func (this ServerComponent) GetID() gidx.PrefixedID { return this.ID }

func (ServerComponent) IsEntity() {}

// A connection to a list of items.
type ServerComponentConnection struct {
	// A list of edges.
	Edges []*ServerComponentEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverComponentCreate
type ServerComponentCreatePayload struct {
	// The created server component.
	ServerComponent ServerComponent `json:"serverComponent"`
}

// Return response from serverComponentDelete
type ServerComponentDeletePayload struct {
	// The ID of the deleted server component.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerComponentEdge struct {
	// The item at the end of the edge.
	Node *ServerComponent `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerComponent connections
type ServerComponentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerComponents.
	Field ServerComponentOrderField `json:"field"`
}

type ServerComponentType struct {
	// The ID of the server component type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server component type.
	Name string `json:"name"`
}

func (ServerComponentType) IsNode() {}

// The id of the object.
func (this ServerComponentType) GetID() gidx.PrefixedID { return this.ID }

func (ServerComponentType) IsEntity() {}

// A connection to a list of items.
type ServerComponentTypeConnection struct {
	// A list of edges.
	Edges []*ServerComponentTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverComponentTypeCreate
type ServerComponentTypeCreatePayload struct {
	// The created server component type.
	ServerComponentType ServerComponentType `json:"serverComponentType"`
}

// Return response from serverComponentTypeDelete
type ServerComponentTypeDeletePayload struct {
	// The ID of the deleted server component type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerComponentTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerComponentType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerComponentType connections
type ServerComponentTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerComponentTypes.
	Field ServerComponentTypeOrderField `json:"field"`
}

// Return response from serverComponentTypeUpdate
type ServerComponentTypeUpdatePayload struct {
	// The updated server component type.
	ServerComponentType ServerComponentType `json:"serverComponentType"`
}

// ServerComponentTypeWhereInput is used for filtering ServerComponentType objects.
// Input was generated by ent.
type ServerComponentTypeWhereInput struct {
	Not *ServerComponentTypeWhereInput   `json:"not,omitempty"`
	And []*ServerComponentTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerComponentTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Return response from serverComponentUpdate
type ServerComponentUpdatePayload struct {
	// The updated server component.
	ServerComponent ServerComponent `json:"serverComponent"`
}

// ServerComponentWhereInput is used for filtering ServerComponent objects.
// Input was generated by ent.
type ServerComponentWhereInput struct {
	Not *ServerComponentWhereInput   `json:"not,omitempty"`
	And []*ServerComponentWhereInput `json:"and,omitempty"`
	Or  []*ServerComponentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// vendor field predicates
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNeq          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGt           *string  `json:"vendorGT,omitempty"`
	VendorGte          *string  `json:"vendorGTE,omitempty"`
	VendorLt           *string  `json:"vendorLT,omitempty"`
	VendorLte          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`
	// model field predicates
	Model             *string  `json:"model,omitempty"`
	ModelNeq          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGt           *string  `json:"modelGT,omitempty"`
	ModelGte          *string  `json:"modelGTE,omitempty"`
	ModelLt           *string  `json:"modelLT,omitempty"`
	ModelLte          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`
	// serial field predicates
	Serial             *string  `json:"serial,omitempty"`
	SerialNeq          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGt           *string  `json:"serialGT,omitempty"`
	SerialGte          *string  `json:"serialGTE,omitempty"`
	SerialLt           *string  `json:"serialLT,omitempty"`
	SerialLte          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`
	// component_type edge predicates
	HasComponentType     *bool                            `json:"hasComponentType,omitempty"`
	HasComponentTypeWith []*ServerComponentTypeWhereInput `json:"hasComponentTypeWith,omitempty"`
	// server edge predicates
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
}

// A connection to a list of items.
type ServerConnection struct {
	// A list of edges.
	Edges []*ServerEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverCreate
type ServerCreatePayload struct {
	// The created server.
	Server Server `json:"server"`
}

// Return response from serverDelete
type ServerDeletePayload struct {
	// The ID of the deleted server.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerEdge struct {
	// The item at the end of the edge.
	Node *Server `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Server connections
type ServerOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Servers.
	Field ServerOrderField `json:"field"`
}

// A connection to a list of items.
type ServerProviderConnection struct {
	// A list of edges.
	Edges []*ServerProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverProviderCreate
type ServerProviderCreatePayload struct {
	// The created server provider.
	ServerProvider generated.Provider `json:"serverProvider"`
}

// Return response from serverProviderDelete
type ServerProviderDeletePayload struct {
	// The ID of the deleted server provider.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerProviderEdge struct {
	// The item at the end of the edge.
	Node *generated.Provider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerProvider connections
type ServerProviderOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerProviders.
	Field ServerProviderOrderField `json:"field"`
}

// Return response from serverProviderUpdate
type ServerProviderUpdatePayload struct {
	// The updated server provider.
	ServerProvider generated.Provider `json:"serverProvider"`
}

// ServerProviderWhereInput is used for filtering Provider objects.
// Input was generated by ent.
type ServerProviderWhereInput struct {
	Not *ServerProviderWhereInput   `json:"not,omitempty"`
	And []*ServerProviderWhereInput `json:"and,omitempty"`
	Or  []*ServerProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// servers edge predicates
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

type ServerType struct {
	// The ID of the server type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the server type.
	Name    string           `json:"name"`
	Servers ServerConnection `json:"servers"`
}

func (ServerType) IsNode() {}

// The id of the object.
func (this ServerType) GetID() gidx.PrefixedID { return this.ID }

func (ServerType) IsEntity() {}

// A connection to a list of items.
type ServerTypeConnection struct {
	// A list of edges.
	Edges []*ServerTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response from serverTypeCreate
type ServerTypeCreatePayload struct {
	// The created server type.
	ServerType ServerType `json:"serverType"`
}

// Return response from serverTypeDelete
type ServerTypeDeletePayload struct {
	// The ID of the deleted server type.
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type ServerTypeEdge struct {
	// The item at the end of the edge.
	Node *ServerType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ServerType connections
type ServerTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ServerTypes.
	Field ServerTypeOrderField `json:"field"`
}

// Return response from serverTypeUpdate
type ServerTypeUpdatePayload struct {
	// The updated server type.
	ServerType ServerType `json:"serverType"`
}

// ServerTypeWhereInput is used for filtering ServerType objects.
// Input was generated by ent.
type ServerTypeWhereInput struct {
	Not *ServerTypeWhereInput   `json:"not,omitempty"`
	And []*ServerTypeWhereInput `json:"and,omitempty"`
	Or  []*ServerTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// servers edge predicates
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// Return response from serverUpdate
type ServerUpdatePayload struct {
	// The updated server.
	Server Server `json:"server"`
}

// ServerWhereInput is used for filtering Server objects.
// Input was generated by ent.
type ServerWhereInput struct {
	Not *ServerWhereInput   `json:"not,omitempty"`
	And []*ServerWhereInput `json:"and,omitempty"`
	Or  []*ServerWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// provider edge predicates
	HasProvider     *bool                       `json:"hasProvider,omitempty"`
	HasProviderWith []*ServerProviderWhereInput `json:"hasProviderWith,omitempty"`
	// server_type edge predicates
	HasServerType     *bool                   `json:"hasServerType,omitempty"`
	HasServerTypeWith []*ServerTypeWhereInput `json:"hasServerTypeWith,omitempty"`
	// components edge predicates
	HasComponents     *bool                        `json:"hasComponents,omitempty"`
	HasComponentsWith []*ServerComponentWhereInput `json:"hasComponentsWith,omitempty"`
	// attributes edge predicates
	HasAttributes     *bool                        `json:"hasAttributes,omitempty"`
	HasAttributesWith []*ServerAttributeWhereInput `json:"hasAttributesWith,omitempty"`
}

// Input information to update a server attribute.
type UpdateServerAttributeInput struct {
	// The name of the server attribute.
	Name *string `json:"name,omitempty"`
	// The value of the server attribute.
	Value *string `json:"value,omitempty"`
}

// Input information to update a server component.
type UpdateServerComponentInput struct {
	// The name of the server component.
	Name *string `json:"name,omitempty"`
	// The name of the vendor of the server component.
	Vendor *string `json:"vendor,omitempty"`
	// The model of the server component.
	Model *string `json:"model,omitempty"`
	// The serial number of the server component.
	Serial *string `json:"serial,omitempty"`
}

// Input information to update a server component type.
type UpdateServerComponentTypeInput struct {
	// The name of the server component type.
	Name *string `json:"name,omitempty"`
}

// Update an existing server.
type UpdateServerInput struct {
	// The name of the server.
	Name *string `json:"name,omitempty"`
	// The description of the server.
	Description        *string           `json:"description,omitempty"`
	ClearDescription   *bool             `json:"clearDescription,omitempty"`
	AddComponentIDs    []gidx.PrefixedID `json:"addComponentIDs,omitempty"`
	RemoveComponentIDs []gidx.PrefixedID `json:"removeComponentIDs,omitempty"`
	ClearComponents    *bool             `json:"clearComponents,omitempty"`
	AddAttributeIDs    []gidx.PrefixedID `json:"addAttributeIDs,omitempty"`
	RemoveAttributeIDs []gidx.PrefixedID `json:"removeAttributeIDs,omitempty"`
	ClearAttributes    *bool             `json:"clearAttributes,omitempty"`
}

// Input information to update a server provider.
type UpdateServerProviderInput struct {
	// The name of the server provider.
	Name *string `json:"name,omitempty"`
}

// Input information to update a server type.
type UpdateServerTypeInput struct {
	// The name of the server type.
	Name *string `json:"name,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerAttribute connections can be ordered.
type ServerAttributeOrderField string

const (
	ServerAttributeOrderFieldID        ServerAttributeOrderField = "ID"
	ServerAttributeOrderFieldCreatedAt ServerAttributeOrderField = "CREATED_AT"
	ServerAttributeOrderFieldUpdatedAt ServerAttributeOrderField = "UPDATED_AT"
	ServerAttributeOrderFieldName      ServerAttributeOrderField = "NAME"
	ServerAttributeOrderFieldValue     ServerAttributeOrderField = "VALUE"
)

var AllServerAttributeOrderField = []ServerAttributeOrderField{
	ServerAttributeOrderFieldID,
	ServerAttributeOrderFieldCreatedAt,
	ServerAttributeOrderFieldUpdatedAt,
	ServerAttributeOrderFieldName,
	ServerAttributeOrderFieldValue,
}

func (e ServerAttributeOrderField) IsValid() bool {
	switch e {
	case ServerAttributeOrderFieldID, ServerAttributeOrderFieldCreatedAt, ServerAttributeOrderFieldUpdatedAt, ServerAttributeOrderFieldName, ServerAttributeOrderFieldValue:
		return true
	}
	return false
}

func (e ServerAttributeOrderField) String() string {
	return string(e)
}

func (e *ServerAttributeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerAttributeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerAttributeOrderField", str)
	}
	return nil
}

func (e ServerAttributeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerComponent connections can be ordered.
type ServerComponentOrderField string

const (
	ServerComponentOrderFieldID        ServerComponentOrderField = "ID"
	ServerComponentOrderFieldCreatedAt ServerComponentOrderField = "CREATED_AT"
	ServerComponentOrderFieldUpdatedAt ServerComponentOrderField = "UPDATED_AT"
	ServerComponentOrderFieldName      ServerComponentOrderField = "NAME"
	ServerComponentOrderFieldVendor    ServerComponentOrderField = "VENDOR"
	ServerComponentOrderFieldModel     ServerComponentOrderField = "MODEL"
	ServerComponentOrderFieldSerial    ServerComponentOrderField = "SERIAL"
)

var AllServerComponentOrderField = []ServerComponentOrderField{
	ServerComponentOrderFieldID,
	ServerComponentOrderFieldCreatedAt,
	ServerComponentOrderFieldUpdatedAt,
	ServerComponentOrderFieldName,
	ServerComponentOrderFieldVendor,
	ServerComponentOrderFieldModel,
	ServerComponentOrderFieldSerial,
}

func (e ServerComponentOrderField) IsValid() bool {
	switch e {
	case ServerComponentOrderFieldID, ServerComponentOrderFieldCreatedAt, ServerComponentOrderFieldUpdatedAt, ServerComponentOrderFieldName, ServerComponentOrderFieldVendor, ServerComponentOrderFieldModel, ServerComponentOrderFieldSerial:
		return true
	}
	return false
}

func (e ServerComponentOrderField) String() string {
	return string(e)
}

func (e *ServerComponentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerComponentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerComponentOrderField", str)
	}
	return nil
}

func (e ServerComponentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerComponentType connections can be ordered.
type ServerComponentTypeOrderField string

const (
	ServerComponentTypeOrderFieldID        ServerComponentTypeOrderField = "ID"
	ServerComponentTypeOrderFieldCreatedAt ServerComponentTypeOrderField = "CREATED_AT"
	ServerComponentTypeOrderFieldUpdatedAt ServerComponentTypeOrderField = "UPDATED_AT"
	ServerComponentTypeOrderFieldName      ServerComponentTypeOrderField = "NAME"
)

var AllServerComponentTypeOrderField = []ServerComponentTypeOrderField{
	ServerComponentTypeOrderFieldID,
	ServerComponentTypeOrderFieldCreatedAt,
	ServerComponentTypeOrderFieldUpdatedAt,
	ServerComponentTypeOrderFieldName,
}

func (e ServerComponentTypeOrderField) IsValid() bool {
	switch e {
	case ServerComponentTypeOrderFieldID, ServerComponentTypeOrderFieldCreatedAt, ServerComponentTypeOrderFieldUpdatedAt, ServerComponentTypeOrderFieldName:
		return true
	}
	return false
}

func (e ServerComponentTypeOrderField) String() string {
	return string(e)
}

func (e *ServerComponentTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerComponentTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerComponentTypeOrderField", str)
	}
	return nil
}

func (e ServerComponentTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Server connections can be ordered.
type ServerOrderField string

const (
	ServerOrderFieldID          ServerOrderField = "ID"
	ServerOrderFieldCreatedAt   ServerOrderField = "CREATED_AT"
	ServerOrderFieldUpdatedAt   ServerOrderField = "UPDATED_AT"
	ServerOrderFieldName        ServerOrderField = "NAME"
	ServerOrderFieldDescription ServerOrderField = "DESCRIPTION"
	ServerOrderFieldOwner       ServerOrderField = "OWNER"
	ServerOrderFieldServerType  ServerOrderField = "SERVER_TYPE"
)

var AllServerOrderField = []ServerOrderField{
	ServerOrderFieldID,
	ServerOrderFieldCreatedAt,
	ServerOrderFieldUpdatedAt,
	ServerOrderFieldName,
	ServerOrderFieldDescription,
	ServerOrderFieldOwner,
	ServerOrderFieldServerType,
}

func (e ServerOrderField) IsValid() bool {
	switch e {
	case ServerOrderFieldID, ServerOrderFieldCreatedAt, ServerOrderFieldUpdatedAt, ServerOrderFieldName, ServerOrderFieldDescription, ServerOrderFieldOwner, ServerOrderFieldServerType:
		return true
	}
	return false
}

func (e ServerOrderField) String() string {
	return string(e)
}

func (e *ServerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerOrderField", str)
	}
	return nil
}

func (e ServerOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerProvider connections can be ordered.
type ServerProviderOrderField string

const (
	ServerProviderOrderFieldID        ServerProviderOrderField = "ID"
	ServerProviderOrderFieldCreatedAt ServerProviderOrderField = "CREATED_AT"
	ServerProviderOrderFieldUpdatedAt ServerProviderOrderField = "UPDATED_AT"
	ServerProviderOrderFieldName      ServerProviderOrderField = "NAME"
	ServerProviderOrderFieldOwner     ServerProviderOrderField = "OWNER"
)

var AllServerProviderOrderField = []ServerProviderOrderField{
	ServerProviderOrderFieldID,
	ServerProviderOrderFieldCreatedAt,
	ServerProviderOrderFieldUpdatedAt,
	ServerProviderOrderFieldName,
	ServerProviderOrderFieldOwner,
}

func (e ServerProviderOrderField) IsValid() bool {
	switch e {
	case ServerProviderOrderFieldID, ServerProviderOrderFieldCreatedAt, ServerProviderOrderFieldUpdatedAt, ServerProviderOrderFieldName, ServerProviderOrderFieldOwner:
		return true
	}
	return false
}

func (e ServerProviderOrderField) String() string {
	return string(e)
}

func (e *ServerProviderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerProviderOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerProviderOrderField", str)
	}
	return nil
}

func (e ServerProviderOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ServerType connections can be ordered.
type ServerTypeOrderField string

const (
	ServerTypeOrderFieldID        ServerTypeOrderField = "ID"
	ServerTypeOrderFieldCreatedAt ServerTypeOrderField = "CREATED_AT"
	ServerTypeOrderFieldUpdatedAt ServerTypeOrderField = "UPDATED_AT"
	ServerTypeOrderFieldName      ServerTypeOrderField = "NAME"
	ServerTypeOrderFieldOwner     ServerTypeOrderField = "OWNER"
)

var AllServerTypeOrderField = []ServerTypeOrderField{
	ServerTypeOrderFieldID,
	ServerTypeOrderFieldCreatedAt,
	ServerTypeOrderFieldUpdatedAt,
	ServerTypeOrderFieldName,
	ServerTypeOrderFieldOwner,
}

func (e ServerTypeOrderField) IsValid() bool {
	switch e {
	case ServerTypeOrderFieldID, ServerTypeOrderFieldCreatedAt, ServerTypeOrderFieldUpdatedAt, ServerTypeOrderFieldName, ServerTypeOrderFieldOwner:
		return true
	}
	return false
}

func (e ServerTypeOrderField) String() string {
	return string(e)
}

func (e *ServerTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerTypeOrderField", str)
	}
	return nil
}

func (e ServerTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
