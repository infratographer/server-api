// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"time"

	"go.infratographer.com/server-api/internal/ent/generated/predicate"
	"go.infratographer.com/server-api/internal/ent/generated/provider"
	"go.infratographer.com/server-api/internal/ent/generated/server"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassis"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassistype"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponent"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponenttype"
	"go.infratographer.com/server-api/internal/ent/generated/servercpu"
	"go.infratographer.com/server-api/internal/ent/generated/servercputype"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboard"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboardtype"
	"go.infratographer.com/server-api/internal/ent/generated/servertype"
	"go.infratographer.com/x/gidx"
)

// ServerProviderWhereInput represents a where input for filtering Provider queries.
type ServerProviderWhereInput struct {
	Predicates []predicate.Provider        `json:"-"`
	Not        *ServerProviderWhereInput   `json:"not,omitempty"`
	Or         []*ServerProviderWhereInput `json:"or,omitempty"`
	And        []*ServerProviderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "servers" edge predicates.
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerProviderWhereInput) AddPredicates(predicates ...predicate.Provider) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerProviderWhereInput filter on the ProviderQuery builder.
func (i *ServerProviderWhereInput) Filter(q *ProviderQuery) (*ProviderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerProviderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerProviderWhereInput is returned in case the ServerProviderWhereInput is empty.
var ErrEmptyServerProviderWhereInput = errors.New("generated: empty predicate ServerProviderWhereInput")

// P returns a predicate for filtering providers.
// An error is returned if the input is empty or invalid.
func (i *ServerProviderWhereInput) P() (predicate.Provider, error) {
	var predicates []predicate.Provider
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, provider.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Provider, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, provider.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Provider, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, provider.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, provider.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, provider.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, provider.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, provider.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, provider.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, provider.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, provider.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, provider.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, provider.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, provider.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, provider.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, provider.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, provider.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, provider.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, provider.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, provider.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, provider.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, provider.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, provider.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, provider.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, provider.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, provider.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, provider.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, provider.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, provider.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, provider.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, provider.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, provider.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, provider.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, provider.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, provider.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, provider.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, provider.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, provider.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, provider.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, provider.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, provider.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasServers != nil {
		p := provider.HasServers()
		if !*i.HasServers {
			p = provider.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServersWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServersWith))
		for _, w := range i.HasServersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, provider.HasServersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerProviderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return provider.And(predicates...), nil
	}
}

// ServerWhereInput represents a where input for filtering Server queries.
type ServerWhereInput struct {
	Predicates []predicate.Server  `json:"-"`
	Not        *ServerWhereInput   `json:"not,omitempty"`
	Or         []*ServerWhereInput `json:"or,omitempty"`
	And        []*ServerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "provider" edge predicates.
	HasProvider     *bool                       `json:"hasProvider,omitempty"`
	HasProviderWith []*ServerProviderWhereInput `json:"hasProviderWith,omitempty"`

	// "server_type" edge predicates.
	HasServerType     *bool                   `json:"hasServerType,omitempty"`
	HasServerTypeWith []*ServerTypeWhereInput `json:"hasServerTypeWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                        `json:"hasComponents,omitempty"`
	HasComponentsWith []*ServerComponentWhereInput `json:"hasComponentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerWhereInput) AddPredicates(predicates ...predicate.Server) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerWhereInput filter on the ServerQuery builder.
func (i *ServerWhereInput) Filter(q *ServerQuery) (*ServerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerWhereInput is returned in case the ServerWhereInput is empty.
var ErrEmptyServerWhereInput = errors.New("generated: empty predicate ServerWhereInput")

// P returns a predicate for filtering servers.
// An error is returned if the input is empty or invalid.
func (i *ServerWhereInput) P() (predicate.Server, error) {
	var predicates []predicate.Server
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, server.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Server, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, server.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Server, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, server.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, server.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, server.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, server.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, server.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, server.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, server.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, server.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, server.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, server.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, server.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, server.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, server.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, server.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, server.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, server.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, server.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, server.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, server.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, server.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, server.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, server.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, server.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, server.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, server.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, server.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, server.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, server.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, server.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, server.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, server.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, server.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, server.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, server.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, server.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, server.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, server.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, server.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, server.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, server.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, server.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, server.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, server.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, server.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, server.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, server.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, server.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, server.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, server.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, server.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, server.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, server.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, server.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasProvider != nil {
		p := server.HasProvider()
		if !*i.HasProvider {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProviderWith) > 0 {
		with := make([]predicate.Provider, 0, len(i.HasProviderWith))
		for _, w := range i.HasProviderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProviderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasProviderWith(with...))
	}
	if i.HasServerType != nil {
		p := server.HasServerType()
		if !*i.HasServerType {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerTypeWith) > 0 {
		with := make([]predicate.ServerType, 0, len(i.HasServerTypeWith))
		for _, w := range i.HasServerTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasServerTypeWith(with...))
	}
	if i.HasComponents != nil {
		p := server.HasComponents()
		if !*i.HasComponents {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ServerComponent, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasComponentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasComponentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return server.And(predicates...), nil
	}
}

// ServerCPUWhereInput represents a where input for filtering ServerCPU queries.
type ServerCPUWhereInput struct {
	Predicates []predicate.ServerCPU  `json:"-"`
	Not        *ServerCPUWhereInput   `json:"not,omitempty"`
	Or         []*ServerCPUWhereInput `json:"or,omitempty"`
	And        []*ServerCPUWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_cpu_type" edge predicates.
	HasServerCPUType     *bool                      `json:"hasServerCPUType,omitempty"`
	HasServerCPUTypeWith []*ServerCPUTypeWhereInput `json:"hasServerCPUTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerCPUWhereInput) AddPredicates(predicates ...predicate.ServerCPU) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerCPUWhereInput filter on the ServerCPUQuery builder.
func (i *ServerCPUWhereInput) Filter(q *ServerCPUQuery) (*ServerCPUQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerCPUWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerCPUWhereInput is returned in case the ServerCPUWhereInput is empty.
var ErrEmptyServerCPUWhereInput = errors.New("generated: empty predicate ServerCPUWhereInput")

// P returns a predicate for filtering servercpus.
// An error is returned if the input is empty or invalid.
func (i *ServerCPUWhereInput) P() (predicate.ServerCPU, error) {
	var predicates []predicate.ServerCPU
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercpu.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerCPU, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercpu.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerCPU, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercpu.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercpu.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercpu.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercpu.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercpu.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercpu.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercpu.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercpu.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercpu.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercpu.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercpu.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercpu.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercpu.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercpu.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercpu.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercpu.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercpu.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercpu.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercpu.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercpu.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercpu.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercpu.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercpu.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercpu.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercpu.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servercpu.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servercpu.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servercpu.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servercpu.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servercpu.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servercpu.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servercpu.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servercpu.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servercpu.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servercpu.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servercpu.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servercpu.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servercpu.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := servercpu.HasServer()
		if !*i.HasServer {
			p = servercpu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercpu.HasServerWith(with...))
	}
	if i.HasServerCPUType != nil {
		p := servercpu.HasServerCPUType()
		if !*i.HasServerCPUType {
			p = servercpu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerCPUTypeWith) > 0 {
		with := make([]predicate.ServerCPUType, 0, len(i.HasServerCPUTypeWith))
		for _, w := range i.HasServerCPUTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerCPUTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercpu.HasServerCPUTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerCPUWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercpu.And(predicates...), nil
	}
}

// ServerCPUTypeWhereInput represents a where input for filtering ServerCPUType queries.
type ServerCPUTypeWhereInput struct {
	Predicates []predicate.ServerCPUType  `json:"-"`
	Not        *ServerCPUTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerCPUTypeWhereInput `json:"or,omitempty"`
	And        []*ServerCPUTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "clock_speed" field predicates.
	ClockSpeed             *string  `json:"clockSpeed,omitempty"`
	ClockSpeedNEQ          *string  `json:"clockSpeedNEQ,omitempty"`
	ClockSpeedIn           []string `json:"clockSpeedIn,omitempty"`
	ClockSpeedNotIn        []string `json:"clockSpeedNotIn,omitempty"`
	ClockSpeedGT           *string  `json:"clockSpeedGT,omitempty"`
	ClockSpeedGTE          *string  `json:"clockSpeedGTE,omitempty"`
	ClockSpeedLT           *string  `json:"clockSpeedLT,omitempty"`
	ClockSpeedLTE          *string  `json:"clockSpeedLTE,omitempty"`
	ClockSpeedContains     *string  `json:"clockSpeedContains,omitempty"`
	ClockSpeedHasPrefix    *string  `json:"clockSpeedHasPrefix,omitempty"`
	ClockSpeedHasSuffix    *string  `json:"clockSpeedHasSuffix,omitempty"`
	ClockSpeedEqualFold    *string  `json:"clockSpeedEqualFold,omitempty"`
	ClockSpeedContainsFold *string  `json:"clockSpeedContainsFold,omitempty"`

	// "core_count" field predicates.
	CoreCount      *int  `json:"coreCount,omitempty"`
	CoreCountNEQ   *int  `json:"coreCountNEQ,omitempty"`
	CoreCountIn    []int `json:"coreCountIn,omitempty"`
	CoreCountNotIn []int `json:"coreCountNotIn,omitempty"`
	CoreCountGT    *int  `json:"coreCountGT,omitempty"`
	CoreCountGTE   *int  `json:"coreCountGTE,omitempty"`
	CoreCountLT    *int  `json:"coreCountLT,omitempty"`
	CoreCountLTE   *int  `json:"coreCountLTE,omitempty"`

	// "cpu" edge predicates.
	HasCPU     *bool                  `json:"hasCPU,omitempty"`
	HasCPUWith []*ServerCPUWhereInput `json:"hasCPUWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerCPUTypeWhereInput) AddPredicates(predicates ...predicate.ServerCPUType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerCPUTypeWhereInput filter on the ServerCPUTypeQuery builder.
func (i *ServerCPUTypeWhereInput) Filter(q *ServerCPUTypeQuery) (*ServerCPUTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerCPUTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerCPUTypeWhereInput is returned in case the ServerCPUTypeWhereInput is empty.
var ErrEmptyServerCPUTypeWhereInput = errors.New("generated: empty predicate ServerCPUTypeWhereInput")

// P returns a predicate for filtering servercputypes.
// An error is returned if the input is empty or invalid.
func (i *ServerCPUTypeWhereInput) P() (predicate.ServerCPUType, error) {
	var predicates []predicate.ServerCPUType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercputype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerCPUType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercputype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerCPUType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercputype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercputype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercputype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercputype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercputype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercputype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercputype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercputype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercputype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercputype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercputype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercputype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercputype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercputype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercputype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercputype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercputype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercputype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercputype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercputype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercputype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercputype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercputype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercputype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercputype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servercputype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servercputype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servercputype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servercputype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servercputype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servercputype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servercputype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servercputype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servercputype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servercputype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servercputype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servercputype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servercputype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servercputype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servercputype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servercputype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servercputype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servercputype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servercputype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servercputype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servercputype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servercputype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servercputype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servercputype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servercputype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servercputype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.ClockSpeed != nil {
		predicates = append(predicates, servercputype.ClockSpeedEQ(*i.ClockSpeed))
	}
	if i.ClockSpeedNEQ != nil {
		predicates = append(predicates, servercputype.ClockSpeedNEQ(*i.ClockSpeedNEQ))
	}
	if len(i.ClockSpeedIn) > 0 {
		predicates = append(predicates, servercputype.ClockSpeedIn(i.ClockSpeedIn...))
	}
	if len(i.ClockSpeedNotIn) > 0 {
		predicates = append(predicates, servercputype.ClockSpeedNotIn(i.ClockSpeedNotIn...))
	}
	if i.ClockSpeedGT != nil {
		predicates = append(predicates, servercputype.ClockSpeedGT(*i.ClockSpeedGT))
	}
	if i.ClockSpeedGTE != nil {
		predicates = append(predicates, servercputype.ClockSpeedGTE(*i.ClockSpeedGTE))
	}
	if i.ClockSpeedLT != nil {
		predicates = append(predicates, servercputype.ClockSpeedLT(*i.ClockSpeedLT))
	}
	if i.ClockSpeedLTE != nil {
		predicates = append(predicates, servercputype.ClockSpeedLTE(*i.ClockSpeedLTE))
	}
	if i.ClockSpeedContains != nil {
		predicates = append(predicates, servercputype.ClockSpeedContains(*i.ClockSpeedContains))
	}
	if i.ClockSpeedHasPrefix != nil {
		predicates = append(predicates, servercputype.ClockSpeedHasPrefix(*i.ClockSpeedHasPrefix))
	}
	if i.ClockSpeedHasSuffix != nil {
		predicates = append(predicates, servercputype.ClockSpeedHasSuffix(*i.ClockSpeedHasSuffix))
	}
	if i.ClockSpeedEqualFold != nil {
		predicates = append(predicates, servercputype.ClockSpeedEqualFold(*i.ClockSpeedEqualFold))
	}
	if i.ClockSpeedContainsFold != nil {
		predicates = append(predicates, servercputype.ClockSpeedContainsFold(*i.ClockSpeedContainsFold))
	}
	if i.CoreCount != nil {
		predicates = append(predicates, servercputype.CoreCountEQ(*i.CoreCount))
	}
	if i.CoreCountNEQ != nil {
		predicates = append(predicates, servercputype.CoreCountNEQ(*i.CoreCountNEQ))
	}
	if len(i.CoreCountIn) > 0 {
		predicates = append(predicates, servercputype.CoreCountIn(i.CoreCountIn...))
	}
	if len(i.CoreCountNotIn) > 0 {
		predicates = append(predicates, servercputype.CoreCountNotIn(i.CoreCountNotIn...))
	}
	if i.CoreCountGT != nil {
		predicates = append(predicates, servercputype.CoreCountGT(*i.CoreCountGT))
	}
	if i.CoreCountGTE != nil {
		predicates = append(predicates, servercputype.CoreCountGTE(*i.CoreCountGTE))
	}
	if i.CoreCountLT != nil {
		predicates = append(predicates, servercputype.CoreCountLT(*i.CoreCountLT))
	}
	if i.CoreCountLTE != nil {
		predicates = append(predicates, servercputype.CoreCountLTE(*i.CoreCountLTE))
	}

	if i.HasCPU != nil {
		p := servercputype.HasCPU()
		if !*i.HasCPU {
			p = servercputype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCPUWith) > 0 {
		with := make([]predicate.ServerCPU, 0, len(i.HasCPUWith))
		for _, w := range i.HasCPUWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCPUWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercputype.HasCPUWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerCPUTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercputype.And(predicates...), nil
	}
}

// ServerChassisWhereInput represents a where input for filtering ServerChassis queries.
type ServerChassisWhereInput struct {
	Predicates []predicate.ServerChassis  `json:"-"`
	Not        *ServerChassisWhereInput   `json:"not,omitempty"`
	Or         []*ServerChassisWhereInput `json:"or,omitempty"`
	And        []*ServerChassisWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_chassis_type" edge predicates.
	HasServerChassisType     *bool                          `json:"hasServerChassisType,omitempty"`
	HasServerChassisTypeWith []*ServerChassisTypeWhereInput `json:"hasServerChassisTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerChassisWhereInput) AddPredicates(predicates ...predicate.ServerChassis) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerChassisWhereInput filter on the ServerChassisQuery builder.
func (i *ServerChassisWhereInput) Filter(q *ServerChassisQuery) (*ServerChassisQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerChassisWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerChassisWhereInput is returned in case the ServerChassisWhereInput is empty.
var ErrEmptyServerChassisWhereInput = errors.New("generated: empty predicate ServerChassisWhereInput")

// P returns a predicate for filtering serverchasses.
// An error is returned if the input is empty or invalid.
func (i *ServerChassisWhereInput) P() (predicate.ServerChassis, error) {
	var predicates []predicate.ServerChassis
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverchassis.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerChassis, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverchassis.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerChassis, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverchassis.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverchassis.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverchassis.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverchassis.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverchassis.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverchassis.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverchassis.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverchassis.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverchassis.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverchassis.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverchassis.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverchassis.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassis.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverchassis.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverchassis.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverchassis.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverchassis.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverchassis.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverchassis.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverchassis.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassis.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverchassis.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverchassis.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverchassis.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverchassis.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, serverchassis.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, serverchassis.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, serverchassis.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, serverchassis.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, serverchassis.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, serverchassis.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, serverchassis.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, serverchassis.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, serverchassis.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, serverchassis.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, serverchassis.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, serverchassis.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, serverchassis.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := serverchassis.HasServer()
		if !*i.HasServer {
			p = serverchassis.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassis.HasServerWith(with...))
	}
	if i.HasServerChassisType != nil {
		p := serverchassis.HasServerChassisType()
		if !*i.HasServerChassisType {
			p = serverchassis.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerChassisTypeWith) > 0 {
		with := make([]predicate.ServerChassisType, 0, len(i.HasServerChassisTypeWith))
		for _, w := range i.HasServerChassisTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerChassisTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassis.HasServerChassisTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerChassisWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverchassis.And(predicates...), nil
	}
}

// ServerChassisTypeWhereInput represents a where input for filtering ServerChassisType queries.
type ServerChassisTypeWhereInput struct {
	Predicates []predicate.ServerChassisType  `json:"-"`
	Not        *ServerChassisTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerChassisTypeWhereInput `json:"or,omitempty"`
	And        []*ServerChassisTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "height" field predicates.
	Height             *string  `json:"height,omitempty"`
	HeightNEQ          *string  `json:"heightNEQ,omitempty"`
	HeightIn           []string `json:"heightIn,omitempty"`
	HeightNotIn        []string `json:"heightNotIn,omitempty"`
	HeightGT           *string  `json:"heightGT,omitempty"`
	HeightGTE          *string  `json:"heightGTE,omitempty"`
	HeightLT           *string  `json:"heightLT,omitempty"`
	HeightLTE          *string  `json:"heightLTE,omitempty"`
	HeightContains     *string  `json:"heightContains,omitempty"`
	HeightHasPrefix    *string  `json:"heightHasPrefix,omitempty"`
	HeightHasSuffix    *string  `json:"heightHasSuffix,omitempty"`
	HeightEqualFold    *string  `json:"heightEqualFold,omitempty"`
	HeightContainsFold *string  `json:"heightContainsFold,omitempty"`

	// "is_full_depth" field predicates.
	IsFullDepth    *bool `json:"isFullDepth,omitempty"`
	IsFullDepthNEQ *bool `json:"isFullDepthNEQ,omitempty"`

	// "chassis" edge predicates.
	HasChassis     *bool                      `json:"hasChassis,omitempty"`
	HasChassisWith []*ServerChassisWhereInput `json:"hasChassisWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerChassisTypeWhereInput) AddPredicates(predicates ...predicate.ServerChassisType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerChassisTypeWhereInput filter on the ServerChassisTypeQuery builder.
func (i *ServerChassisTypeWhereInput) Filter(q *ServerChassisTypeQuery) (*ServerChassisTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerChassisTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerChassisTypeWhereInput is returned in case the ServerChassisTypeWhereInput is empty.
var ErrEmptyServerChassisTypeWhereInput = errors.New("generated: empty predicate ServerChassisTypeWhereInput")

// P returns a predicate for filtering serverchassistypes.
// An error is returned if the input is empty or invalid.
func (i *ServerChassisTypeWhereInput) P() (predicate.ServerChassisType, error) {
	var predicates []predicate.ServerChassisType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverchassistype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerChassisType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverchassistype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerChassisType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverchassistype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverchassistype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverchassistype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverchassistype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverchassistype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverchassistype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverchassistype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverchassistype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverchassistype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverchassistype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverchassistype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverchassistype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassistype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverchassistype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverchassistype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverchassistype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverchassistype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverchassistype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassistype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, serverchassistype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, serverchassistype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, serverchassistype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, serverchassistype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, serverchassistype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, serverchassistype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, serverchassistype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, serverchassistype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, serverchassistype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, serverchassistype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, serverchassistype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, serverchassistype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, serverchassistype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, serverchassistype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, serverchassistype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, serverchassistype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, serverchassistype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, serverchassistype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, serverchassistype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, serverchassistype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, serverchassistype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, serverchassistype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, serverchassistype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, serverchassistype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, serverchassistype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, serverchassistype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Height != nil {
		predicates = append(predicates, serverchassistype.HeightEQ(*i.Height))
	}
	if i.HeightNEQ != nil {
		predicates = append(predicates, serverchassistype.HeightNEQ(*i.HeightNEQ))
	}
	if len(i.HeightIn) > 0 {
		predicates = append(predicates, serverchassistype.HeightIn(i.HeightIn...))
	}
	if len(i.HeightNotIn) > 0 {
		predicates = append(predicates, serverchassistype.HeightNotIn(i.HeightNotIn...))
	}
	if i.HeightGT != nil {
		predicates = append(predicates, serverchassistype.HeightGT(*i.HeightGT))
	}
	if i.HeightGTE != nil {
		predicates = append(predicates, serverchassistype.HeightGTE(*i.HeightGTE))
	}
	if i.HeightLT != nil {
		predicates = append(predicates, serverchassistype.HeightLT(*i.HeightLT))
	}
	if i.HeightLTE != nil {
		predicates = append(predicates, serverchassistype.HeightLTE(*i.HeightLTE))
	}
	if i.HeightContains != nil {
		predicates = append(predicates, serverchassistype.HeightContains(*i.HeightContains))
	}
	if i.HeightHasPrefix != nil {
		predicates = append(predicates, serverchassistype.HeightHasPrefix(*i.HeightHasPrefix))
	}
	if i.HeightHasSuffix != nil {
		predicates = append(predicates, serverchassistype.HeightHasSuffix(*i.HeightHasSuffix))
	}
	if i.HeightEqualFold != nil {
		predicates = append(predicates, serverchassistype.HeightEqualFold(*i.HeightEqualFold))
	}
	if i.HeightContainsFold != nil {
		predicates = append(predicates, serverchassistype.HeightContainsFold(*i.HeightContainsFold))
	}
	if i.IsFullDepth != nil {
		predicates = append(predicates, serverchassistype.IsFullDepthEQ(*i.IsFullDepth))
	}
	if i.IsFullDepthNEQ != nil {
		predicates = append(predicates, serverchassistype.IsFullDepthNEQ(*i.IsFullDepthNEQ))
	}

	if i.HasChassis != nil {
		p := serverchassistype.HasChassis()
		if !*i.HasChassis {
			p = serverchassistype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChassisWith) > 0 {
		with := make([]predicate.ServerChassis, 0, len(i.HasChassisWith))
		for _, w := range i.HasChassisWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChassisWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassistype.HasChassisWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerChassisTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverchassistype.And(predicates...), nil
	}
}

// ServerComponentWhereInput represents a where input for filtering ServerComponent queries.
type ServerComponentWhereInput struct {
	Predicates []predicate.ServerComponent  `json:"-"`
	Not        *ServerComponentWhereInput   `json:"not,omitempty"`
	Or         []*ServerComponentWhereInput `json:"or,omitempty"`
	And        []*ServerComponentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "component_type" edge predicates.
	HasComponentType     *bool                            `json:"hasComponentType,omitempty"`
	HasComponentTypeWith []*ServerComponentTypeWhereInput `json:"hasComponentTypeWith,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerComponentWhereInput) AddPredicates(predicates ...predicate.ServerComponent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerComponentWhereInput filter on the ServerComponentQuery builder.
func (i *ServerComponentWhereInput) Filter(q *ServerComponentQuery) (*ServerComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerComponentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerComponentWhereInput is returned in case the ServerComponentWhereInput is empty.
var ErrEmptyServerComponentWhereInput = errors.New("generated: empty predicate ServerComponentWhereInput")

// P returns a predicate for filtering servercomponents.
// An error is returned if the input is empty or invalid.
func (i *ServerComponentWhereInput) P() (predicate.ServerComponent, error) {
	var predicates []predicate.ServerComponent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercomponent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerComponent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercomponent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerComponent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercomponent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercomponent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercomponent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercomponent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercomponent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercomponent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercomponent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercomponent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercomponent.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercomponent.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercomponent.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercomponent.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponent.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercomponent.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercomponent.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercomponent.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercomponent.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercomponent.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercomponent.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercomponent.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponent.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercomponent.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercomponent.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercomponent.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercomponent.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servercomponent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servercomponent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servercomponent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servercomponent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servercomponent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servercomponent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servercomponent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servercomponent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servercomponent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servercomponent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servercomponent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servercomponent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servercomponent.NameContainsFold(*i.NameContainsFold))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servercomponent.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servercomponent.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servercomponent.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servercomponent.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servercomponent.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servercomponent.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servercomponent.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servercomponent.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servercomponent.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servercomponent.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servercomponent.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servercomponent.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servercomponent.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servercomponent.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servercomponent.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servercomponent.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servercomponent.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servercomponent.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servercomponent.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servercomponent.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servercomponent.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servercomponent.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servercomponent.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servercomponent.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servercomponent.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servercomponent.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Serial != nil {
		predicates = append(predicates, servercomponent.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servercomponent.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servercomponent.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servercomponent.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servercomponent.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servercomponent.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servercomponent.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servercomponent.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servercomponent.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servercomponent.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servercomponent.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servercomponent.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servercomponent.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasComponentType != nil {
		p := servercomponent.HasComponentType()
		if !*i.HasComponentType {
			p = servercomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentTypeWith) > 0 {
		with := make([]predicate.ServerComponentType, 0, len(i.HasComponentTypeWith))
		for _, w := range i.HasComponentTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasComponentTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercomponent.HasComponentTypeWith(with...))
	}
	if i.HasServer != nil {
		p := servercomponent.HasServer()
		if !*i.HasServer {
			p = servercomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercomponent.HasServerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerComponentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercomponent.And(predicates...), nil
	}
}

// ServerComponentTypeWhereInput represents a where input for filtering ServerComponentType queries.
type ServerComponentTypeWhereInput struct {
	Predicates []predicate.ServerComponentType  `json:"-"`
	Not        *ServerComponentTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerComponentTypeWhereInput `json:"or,omitempty"`
	And        []*ServerComponentTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerComponentTypeWhereInput) AddPredicates(predicates ...predicate.ServerComponentType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerComponentTypeWhereInput filter on the ServerComponentTypeQuery builder.
func (i *ServerComponentTypeWhereInput) Filter(q *ServerComponentTypeQuery) (*ServerComponentTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerComponentTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerComponentTypeWhereInput is returned in case the ServerComponentTypeWhereInput is empty.
var ErrEmptyServerComponentTypeWhereInput = errors.New("generated: empty predicate ServerComponentTypeWhereInput")

// P returns a predicate for filtering servercomponenttypes.
// An error is returned if the input is empty or invalid.
func (i *ServerComponentTypeWhereInput) P() (predicate.ServerComponentType, error) {
	var predicates []predicate.ServerComponentType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercomponenttype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerComponentType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercomponenttype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerComponentType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercomponenttype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercomponenttype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercomponenttype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercomponenttype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercomponenttype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercomponenttype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercomponenttype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercomponenttype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercomponenttype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercomponenttype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servercomponenttype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servercomponenttype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servercomponenttype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servercomponenttype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servercomponenttype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servercomponenttype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servercomponenttype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servercomponenttype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servercomponenttype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servercomponenttype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servercomponenttype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servercomponenttype.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerComponentTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercomponenttype.And(predicates...), nil
	}
}

// ServerMotherboardWhereInput represents a where input for filtering ServerMotherboard queries.
type ServerMotherboardWhereInput struct {
	Predicates []predicate.ServerMotherboard  `json:"-"`
	Not        *ServerMotherboardWhereInput   `json:"not,omitempty"`
	Or         []*ServerMotherboardWhereInput `json:"or,omitempty"`
	And        []*ServerMotherboardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_motherboard_type" edge predicates.
	HasServerMotherboardType     *bool                              `json:"hasServerMotherboardType,omitempty"`
	HasServerMotherboardTypeWith []*ServerMotherboardTypeWhereInput `json:"hasServerMotherboardTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMotherboardWhereInput) AddPredicates(predicates ...predicate.ServerMotherboard) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMotherboardWhereInput filter on the ServerMotherboardQuery builder.
func (i *ServerMotherboardWhereInput) Filter(q *ServerMotherboardQuery) (*ServerMotherboardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMotherboardWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMotherboardWhereInput is returned in case the ServerMotherboardWhereInput is empty.
var ErrEmptyServerMotherboardWhereInput = errors.New("generated: empty predicate ServerMotherboardWhereInput")

// P returns a predicate for filtering servermotherboards.
// An error is returned if the input is empty or invalid.
func (i *ServerMotherboardWhereInput) P() (predicate.ServerMotherboard, error) {
	var predicates []predicate.ServerMotherboard
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermotherboard.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMotherboard, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermotherboard.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMotherboard, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermotherboard.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermotherboard.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermotherboard.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermotherboard.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermotherboard.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermotherboard.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermotherboard.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermotherboard.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermotherboard.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermotherboard.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermotherboard.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermotherboard.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboard.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermotherboard.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermotherboard.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermotherboard.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermotherboard.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermotherboard.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboard.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servermotherboard.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servermotherboard.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servermotherboard.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servermotherboard.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servermotherboard.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servermotherboard.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servermotherboard.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servermotherboard.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servermotherboard.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servermotherboard.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servermotherboard.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servermotherboard.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servermotherboard.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := servermotherboard.HasServer()
		if !*i.HasServer {
			p = servermotherboard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboard.HasServerWith(with...))
	}
	if i.HasServerMotherboardType != nil {
		p := servermotherboard.HasServerMotherboardType()
		if !*i.HasServerMotherboardType {
			p = servermotherboard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerMotherboardTypeWith) > 0 {
		with := make([]predicate.ServerMotherboardType, 0, len(i.HasServerMotherboardTypeWith))
		for _, w := range i.HasServerMotherboardTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerMotherboardTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboard.HasServerMotherboardTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMotherboardWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermotherboard.And(predicates...), nil
	}
}

// ServerMotherboardTypeWhereInput represents a where input for filtering ServerMotherboardType queries.
type ServerMotherboardTypeWhereInput struct {
	Predicates []predicate.ServerMotherboardType  `json:"-"`
	Not        *ServerMotherboardTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerMotherboardTypeWhereInput `json:"or,omitempty"`
	And        []*ServerMotherboardTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "motherboard" edge predicates.
	HasMotherboard     *bool                          `json:"hasMotherboard,omitempty"`
	HasMotherboardWith []*ServerMotherboardWhereInput `json:"hasMotherboardWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMotherboardTypeWhereInput) AddPredicates(predicates ...predicate.ServerMotherboardType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMotherboardTypeWhereInput filter on the ServerMotherboardTypeQuery builder.
func (i *ServerMotherboardTypeWhereInput) Filter(q *ServerMotherboardTypeQuery) (*ServerMotherboardTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMotherboardTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMotherboardTypeWhereInput is returned in case the ServerMotherboardTypeWhereInput is empty.
var ErrEmptyServerMotherboardTypeWhereInput = errors.New("generated: empty predicate ServerMotherboardTypeWhereInput")

// P returns a predicate for filtering servermotherboardtypes.
// An error is returned if the input is empty or invalid.
func (i *ServerMotherboardTypeWhereInput) P() (predicate.ServerMotherboardType, error) {
	var predicates []predicate.ServerMotherboardType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermotherboardtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMotherboardType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermotherboardtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMotherboardType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermotherboardtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermotherboardtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermotherboardtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermotherboardtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermotherboardtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermotherboardtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermotherboardtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermotherboardtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermotherboardtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermotherboardtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servermotherboardtype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servermotherboardtype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servermotherboardtype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servermotherboardtype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servermotherboardtype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servermotherboardtype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servermotherboardtype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servermotherboardtype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servermotherboardtype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servermotherboardtype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servermotherboardtype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servermotherboardtype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servermotherboardtype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servermotherboardtype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servermotherboardtype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servermotherboardtype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servermotherboardtype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servermotherboardtype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servermotherboardtype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servermotherboardtype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servermotherboardtype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servermotherboardtype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servermotherboardtype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servermotherboardtype.ModelContainsFold(*i.ModelContainsFold))
	}

	if i.HasMotherboard != nil {
		p := servermotherboardtype.HasMotherboard()
		if !*i.HasMotherboard {
			p = servermotherboardtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMotherboardWith) > 0 {
		with := make([]predicate.ServerMotherboard, 0, len(i.HasMotherboardWith))
		for _, w := range i.HasMotherboardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMotherboardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboardtype.HasMotherboardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMotherboardTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermotherboardtype.And(predicates...), nil
	}
}

// ServerTypeWhereInput represents a where input for filtering ServerType queries.
type ServerTypeWhereInput struct {
	Predicates []predicate.ServerType  `json:"-"`
	Not        *ServerTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerTypeWhereInput `json:"or,omitempty"`
	And        []*ServerTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "servers" edge predicates.
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerTypeWhereInput) AddPredicates(predicates ...predicate.ServerType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerTypeWhereInput filter on the ServerTypeQuery builder.
func (i *ServerTypeWhereInput) Filter(q *ServerTypeQuery) (*ServerTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerTypeWhereInput is returned in case the ServerTypeWhereInput is empty.
var ErrEmptyServerTypeWhereInput = errors.New("generated: empty predicate ServerTypeWhereInput")

// P returns a predicate for filtering servertypes.
// An error is returned if the input is empty or invalid.
func (i *ServerTypeWhereInput) P() (predicate.ServerType, error) {
	var predicates []predicate.ServerType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servertype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servertype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servertype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servertype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servertype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servertype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servertype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servertype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servertype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servertype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servertype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servertype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servertype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servertype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servertype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servertype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servertype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servertype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servertype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servertype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servertype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servertype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servertype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servertype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servertype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servertype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servertype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servertype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servertype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servertype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servertype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servertype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servertype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servertype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servertype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servertype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servertype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servertype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servertype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servertype.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasServers != nil {
		p := servertype.HasServers()
		if !*i.HasServers {
			p = servertype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServersWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServersWith))
		for _, w := range i.HasServersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servertype.HasServersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servertype.And(predicates...), nil
	}
}
