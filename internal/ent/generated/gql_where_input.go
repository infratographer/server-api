// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"time"

	"go.infratographer.com/server-api/internal/ent/generated/predicate"
	"go.infratographer.com/server-api/internal/ent/generated/provider"
	"go.infratographer.com/server-api/internal/ent/generated/server"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassis"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassistype"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponent"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponenttype"
	"go.infratographer.com/server-api/internal/ent/generated/servercpu"
	"go.infratographer.com/server-api/internal/ent/generated/servercputype"
	"go.infratographer.com/server-api/internal/ent/generated/serverharddrive"
	"go.infratographer.com/server-api/internal/ent/generated/serverharddrivetype"
	"go.infratographer.com/server-api/internal/ent/generated/servermemory"
	"go.infratographer.com/server-api/internal/ent/generated/servermemorytype"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboard"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboardtype"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkcard"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkcardtype"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkport"
	"go.infratographer.com/server-api/internal/ent/generated/serverpowersupply"
	"go.infratographer.com/server-api/internal/ent/generated/serverpowersupplytype"
	"go.infratographer.com/server-api/internal/ent/generated/servertype"
	"go.infratographer.com/x/gidx"
)

// ServerProviderWhereInput represents a where input for filtering Provider queries.
type ServerProviderWhereInput struct {
	Predicates []predicate.Provider        `json:"-"`
	Not        *ServerProviderWhereInput   `json:"not,omitempty"`
	Or         []*ServerProviderWhereInput `json:"or,omitempty"`
	And        []*ServerProviderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "servers" edge predicates.
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerProviderWhereInput) AddPredicates(predicates ...predicate.Provider) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerProviderWhereInput filter on the ProviderQuery builder.
func (i *ServerProviderWhereInput) Filter(q *ProviderQuery) (*ProviderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerProviderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerProviderWhereInput is returned in case the ServerProviderWhereInput is empty.
var ErrEmptyServerProviderWhereInput = errors.New("generated: empty predicate ServerProviderWhereInput")

// P returns a predicate for filtering providers.
// An error is returned if the input is empty or invalid.
func (i *ServerProviderWhereInput) P() (predicate.Provider, error) {
	var predicates []predicate.Provider
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, provider.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Provider, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, provider.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Provider, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, provider.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, provider.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, provider.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, provider.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, provider.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, provider.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, provider.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, provider.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, provider.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, provider.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, provider.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, provider.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, provider.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, provider.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, provider.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, provider.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, provider.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, provider.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, provider.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, provider.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, provider.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, provider.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, provider.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, provider.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, provider.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, provider.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, provider.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, provider.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, provider.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, provider.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, provider.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, provider.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, provider.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, provider.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, provider.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, provider.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, provider.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, provider.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasServers != nil {
		p := provider.HasServers()
		if !*i.HasServers {
			p = provider.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServersWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServersWith))
		for _, w := range i.HasServersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, provider.HasServersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerProviderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return provider.And(predicates...), nil
	}
}

// ServerWhereInput represents a where input for filtering Server queries.
type ServerWhereInput struct {
	Predicates []predicate.Server  `json:"-"`
	Not        *ServerWhereInput   `json:"not,omitempty"`
	Or         []*ServerWhereInput `json:"or,omitempty"`
	And        []*ServerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "provider" edge predicates.
	HasProvider     *bool                       `json:"hasProvider,omitempty"`
	HasProviderWith []*ServerProviderWhereInput `json:"hasProviderWith,omitempty"`

	// "server_type" edge predicates.
	HasServerType     *bool                   `json:"hasServerType,omitempty"`
	HasServerTypeWith []*ServerTypeWhereInput `json:"hasServerTypeWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                        `json:"hasComponents,omitempty"`
	HasComponentsWith []*ServerComponentWhereInput `json:"hasComponentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerWhereInput) AddPredicates(predicates ...predicate.Server) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerWhereInput filter on the ServerQuery builder.
func (i *ServerWhereInput) Filter(q *ServerQuery) (*ServerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerWhereInput is returned in case the ServerWhereInput is empty.
var ErrEmptyServerWhereInput = errors.New("generated: empty predicate ServerWhereInput")

// P returns a predicate for filtering servers.
// An error is returned if the input is empty or invalid.
func (i *ServerWhereInput) P() (predicate.Server, error) {
	var predicates []predicate.Server
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, server.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Server, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, server.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Server, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, server.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, server.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, server.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, server.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, server.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, server.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, server.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, server.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, server.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, server.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, server.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, server.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, server.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, server.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, server.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, server.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, server.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, server.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, server.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, server.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, server.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, server.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, server.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, server.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, server.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, server.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, server.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, server.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, server.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, server.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, server.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, server.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, server.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, server.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, server.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, server.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, server.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, server.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, server.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, server.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, server.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, server.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, server.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, server.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, server.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, server.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, server.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, server.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, server.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, server.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, server.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, server.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, server.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasProvider != nil {
		p := server.HasProvider()
		if !*i.HasProvider {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProviderWith) > 0 {
		with := make([]predicate.Provider, 0, len(i.HasProviderWith))
		for _, w := range i.HasProviderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProviderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasProviderWith(with...))
	}
	if i.HasServerType != nil {
		p := server.HasServerType()
		if !*i.HasServerType {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerTypeWith) > 0 {
		with := make([]predicate.ServerType, 0, len(i.HasServerTypeWith))
		for _, w := range i.HasServerTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasServerTypeWith(with...))
	}
	if i.HasComponents != nil {
		p := server.HasComponents()
		if !*i.HasComponents {
			p = server.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ServerComponent, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasComponentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, server.HasComponentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return server.And(predicates...), nil
	}
}

// ServerCPUWhereInput represents a where input for filtering ServerCPU queries.
type ServerCPUWhereInput struct {
	Predicates []predicate.ServerCPU  `json:"-"`
	Not        *ServerCPUWhereInput   `json:"not,omitempty"`
	Or         []*ServerCPUWhereInput `json:"or,omitempty"`
	And        []*ServerCPUWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_cpu_type" edge predicates.
	HasServerCPUType     *bool                      `json:"hasServerCPUType,omitempty"`
	HasServerCPUTypeWith []*ServerCPUTypeWhereInput `json:"hasServerCPUTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerCPUWhereInput) AddPredicates(predicates ...predicate.ServerCPU) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerCPUWhereInput filter on the ServerCPUQuery builder.
func (i *ServerCPUWhereInput) Filter(q *ServerCPUQuery) (*ServerCPUQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerCPUWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerCPUWhereInput is returned in case the ServerCPUWhereInput is empty.
var ErrEmptyServerCPUWhereInput = errors.New("generated: empty predicate ServerCPUWhereInput")

// P returns a predicate for filtering servercpus.
// An error is returned if the input is empty or invalid.
func (i *ServerCPUWhereInput) P() (predicate.ServerCPU, error) {
	var predicates []predicate.ServerCPU
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercpu.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerCPU, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercpu.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerCPU, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercpu.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercpu.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercpu.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercpu.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercpu.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercpu.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercpu.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercpu.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercpu.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercpu.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercpu.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercpu.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercpu.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercpu.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercpu.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercpu.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercpu.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercpu.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercpu.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercpu.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercpu.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercpu.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercpu.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercpu.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercpu.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servercpu.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servercpu.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servercpu.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servercpu.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servercpu.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servercpu.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servercpu.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servercpu.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servercpu.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servercpu.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servercpu.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servercpu.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servercpu.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := servercpu.HasServer()
		if !*i.HasServer {
			p = servercpu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercpu.HasServerWith(with...))
	}
	if i.HasServerCPUType != nil {
		p := servercpu.HasServerCPUType()
		if !*i.HasServerCPUType {
			p = servercpu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerCPUTypeWith) > 0 {
		with := make([]predicate.ServerCPUType, 0, len(i.HasServerCPUTypeWith))
		for _, w := range i.HasServerCPUTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerCPUTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercpu.HasServerCPUTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerCPUWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercpu.And(predicates...), nil
	}
}

// ServerCPUTypeWhereInput represents a where input for filtering ServerCPUType queries.
type ServerCPUTypeWhereInput struct {
	Predicates []predicate.ServerCPUType  `json:"-"`
	Not        *ServerCPUTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerCPUTypeWhereInput `json:"or,omitempty"`
	And        []*ServerCPUTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "clock_speed" field predicates.
	ClockSpeed             *string  `json:"clockSpeed,omitempty"`
	ClockSpeedNEQ          *string  `json:"clockSpeedNEQ,omitempty"`
	ClockSpeedIn           []string `json:"clockSpeedIn,omitempty"`
	ClockSpeedNotIn        []string `json:"clockSpeedNotIn,omitempty"`
	ClockSpeedGT           *string  `json:"clockSpeedGT,omitempty"`
	ClockSpeedGTE          *string  `json:"clockSpeedGTE,omitempty"`
	ClockSpeedLT           *string  `json:"clockSpeedLT,omitempty"`
	ClockSpeedLTE          *string  `json:"clockSpeedLTE,omitempty"`
	ClockSpeedContains     *string  `json:"clockSpeedContains,omitempty"`
	ClockSpeedHasPrefix    *string  `json:"clockSpeedHasPrefix,omitempty"`
	ClockSpeedHasSuffix    *string  `json:"clockSpeedHasSuffix,omitempty"`
	ClockSpeedEqualFold    *string  `json:"clockSpeedEqualFold,omitempty"`
	ClockSpeedContainsFold *string  `json:"clockSpeedContainsFold,omitempty"`

	// "core_count" field predicates.
	CoreCount      *int64  `json:"coreCount,omitempty"`
	CoreCountNEQ   *int64  `json:"coreCountNEQ,omitempty"`
	CoreCountIn    []int64 `json:"coreCountIn,omitempty"`
	CoreCountNotIn []int64 `json:"coreCountNotIn,omitempty"`
	CoreCountGT    *int64  `json:"coreCountGT,omitempty"`
	CoreCountGTE   *int64  `json:"coreCountGTE,omitempty"`
	CoreCountLT    *int64  `json:"coreCountLT,omitempty"`
	CoreCountLTE   *int64  `json:"coreCountLTE,omitempty"`

	// "cpu" edge predicates.
	HasCPU     *bool                  `json:"hasCPU,omitempty"`
	HasCPUWith []*ServerCPUWhereInput `json:"hasCPUWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerCPUTypeWhereInput) AddPredicates(predicates ...predicate.ServerCPUType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerCPUTypeWhereInput filter on the ServerCPUTypeQuery builder.
func (i *ServerCPUTypeWhereInput) Filter(q *ServerCPUTypeQuery) (*ServerCPUTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerCPUTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerCPUTypeWhereInput is returned in case the ServerCPUTypeWhereInput is empty.
var ErrEmptyServerCPUTypeWhereInput = errors.New("generated: empty predicate ServerCPUTypeWhereInput")

// P returns a predicate for filtering servercputypes.
// An error is returned if the input is empty or invalid.
func (i *ServerCPUTypeWhereInput) P() (predicate.ServerCPUType, error) {
	var predicates []predicate.ServerCPUType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercputype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerCPUType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercputype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerCPUType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercputype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercputype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercputype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercputype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercputype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercputype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercputype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercputype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercputype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercputype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercputype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercputype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercputype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercputype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercputype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercputype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercputype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercputype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercputype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercputype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercputype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercputype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercputype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercputype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercputype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servercputype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servercputype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servercputype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servercputype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servercputype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servercputype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servercputype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servercputype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servercputype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servercputype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servercputype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servercputype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servercputype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servercputype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servercputype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servercputype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servercputype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servercputype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servercputype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servercputype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servercputype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servercputype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servercputype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servercputype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servercputype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servercputype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.ClockSpeed != nil {
		predicates = append(predicates, servercputype.ClockSpeedEQ(*i.ClockSpeed))
	}
	if i.ClockSpeedNEQ != nil {
		predicates = append(predicates, servercputype.ClockSpeedNEQ(*i.ClockSpeedNEQ))
	}
	if len(i.ClockSpeedIn) > 0 {
		predicates = append(predicates, servercputype.ClockSpeedIn(i.ClockSpeedIn...))
	}
	if len(i.ClockSpeedNotIn) > 0 {
		predicates = append(predicates, servercputype.ClockSpeedNotIn(i.ClockSpeedNotIn...))
	}
	if i.ClockSpeedGT != nil {
		predicates = append(predicates, servercputype.ClockSpeedGT(*i.ClockSpeedGT))
	}
	if i.ClockSpeedGTE != nil {
		predicates = append(predicates, servercputype.ClockSpeedGTE(*i.ClockSpeedGTE))
	}
	if i.ClockSpeedLT != nil {
		predicates = append(predicates, servercputype.ClockSpeedLT(*i.ClockSpeedLT))
	}
	if i.ClockSpeedLTE != nil {
		predicates = append(predicates, servercputype.ClockSpeedLTE(*i.ClockSpeedLTE))
	}
	if i.ClockSpeedContains != nil {
		predicates = append(predicates, servercputype.ClockSpeedContains(*i.ClockSpeedContains))
	}
	if i.ClockSpeedHasPrefix != nil {
		predicates = append(predicates, servercputype.ClockSpeedHasPrefix(*i.ClockSpeedHasPrefix))
	}
	if i.ClockSpeedHasSuffix != nil {
		predicates = append(predicates, servercputype.ClockSpeedHasSuffix(*i.ClockSpeedHasSuffix))
	}
	if i.ClockSpeedEqualFold != nil {
		predicates = append(predicates, servercputype.ClockSpeedEqualFold(*i.ClockSpeedEqualFold))
	}
	if i.ClockSpeedContainsFold != nil {
		predicates = append(predicates, servercputype.ClockSpeedContainsFold(*i.ClockSpeedContainsFold))
	}
	if i.CoreCount != nil {
		predicates = append(predicates, servercputype.CoreCountEQ(*i.CoreCount))
	}
	if i.CoreCountNEQ != nil {
		predicates = append(predicates, servercputype.CoreCountNEQ(*i.CoreCountNEQ))
	}
	if len(i.CoreCountIn) > 0 {
		predicates = append(predicates, servercputype.CoreCountIn(i.CoreCountIn...))
	}
	if len(i.CoreCountNotIn) > 0 {
		predicates = append(predicates, servercputype.CoreCountNotIn(i.CoreCountNotIn...))
	}
	if i.CoreCountGT != nil {
		predicates = append(predicates, servercputype.CoreCountGT(*i.CoreCountGT))
	}
	if i.CoreCountGTE != nil {
		predicates = append(predicates, servercputype.CoreCountGTE(*i.CoreCountGTE))
	}
	if i.CoreCountLT != nil {
		predicates = append(predicates, servercputype.CoreCountLT(*i.CoreCountLT))
	}
	if i.CoreCountLTE != nil {
		predicates = append(predicates, servercputype.CoreCountLTE(*i.CoreCountLTE))
	}

	if i.HasCPU != nil {
		p := servercputype.HasCPU()
		if !*i.HasCPU {
			p = servercputype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCPUWith) > 0 {
		with := make([]predicate.ServerCPU, 0, len(i.HasCPUWith))
		for _, w := range i.HasCPUWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCPUWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercputype.HasCPUWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerCPUTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercputype.And(predicates...), nil
	}
}

// ServerChassisWhereInput represents a where input for filtering ServerChassis queries.
type ServerChassisWhereInput struct {
	Predicates []predicate.ServerChassis  `json:"-"`
	Not        *ServerChassisWhereInput   `json:"not,omitempty"`
	Or         []*ServerChassisWhereInput `json:"or,omitempty"`
	And        []*ServerChassisWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_chassis_type" edge predicates.
	HasServerChassisType     *bool                          `json:"hasServerChassisType,omitempty"`
	HasServerChassisTypeWith []*ServerChassisTypeWhereInput `json:"hasServerChassisTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerChassisWhereInput) AddPredicates(predicates ...predicate.ServerChassis) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerChassisWhereInput filter on the ServerChassisQuery builder.
func (i *ServerChassisWhereInput) Filter(q *ServerChassisQuery) (*ServerChassisQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerChassisWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerChassisWhereInput is returned in case the ServerChassisWhereInput is empty.
var ErrEmptyServerChassisWhereInput = errors.New("generated: empty predicate ServerChassisWhereInput")

// P returns a predicate for filtering serverchasses.
// An error is returned if the input is empty or invalid.
func (i *ServerChassisWhereInput) P() (predicate.ServerChassis, error) {
	var predicates []predicate.ServerChassis
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverchassis.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerChassis, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverchassis.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerChassis, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverchassis.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverchassis.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverchassis.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverchassis.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverchassis.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverchassis.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverchassis.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverchassis.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverchassis.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverchassis.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverchassis.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverchassis.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassis.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverchassis.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverchassis.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverchassis.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverchassis.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverchassis.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverchassis.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverchassis.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassis.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverchassis.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverchassis.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverchassis.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverchassis.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, serverchassis.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, serverchassis.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, serverchassis.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, serverchassis.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, serverchassis.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, serverchassis.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, serverchassis.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, serverchassis.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, serverchassis.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, serverchassis.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, serverchassis.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, serverchassis.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, serverchassis.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := serverchassis.HasServer()
		if !*i.HasServer {
			p = serverchassis.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassis.HasServerWith(with...))
	}
	if i.HasServerChassisType != nil {
		p := serverchassis.HasServerChassisType()
		if !*i.HasServerChassisType {
			p = serverchassis.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerChassisTypeWith) > 0 {
		with := make([]predicate.ServerChassisType, 0, len(i.HasServerChassisTypeWith))
		for _, w := range i.HasServerChassisTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerChassisTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassis.HasServerChassisTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerChassisWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverchassis.And(predicates...), nil
	}
}

// ServerChassisTypeWhereInput represents a where input for filtering ServerChassisType queries.
type ServerChassisTypeWhereInput struct {
	Predicates []predicate.ServerChassisType  `json:"-"`
	Not        *ServerChassisTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerChassisTypeWhereInput `json:"or,omitempty"`
	And        []*ServerChassisTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "height" field predicates.
	Height             *string  `json:"height,omitempty"`
	HeightNEQ          *string  `json:"heightNEQ,omitempty"`
	HeightIn           []string `json:"heightIn,omitempty"`
	HeightNotIn        []string `json:"heightNotIn,omitempty"`
	HeightGT           *string  `json:"heightGT,omitempty"`
	HeightGTE          *string  `json:"heightGTE,omitempty"`
	HeightLT           *string  `json:"heightLT,omitempty"`
	HeightLTE          *string  `json:"heightLTE,omitempty"`
	HeightContains     *string  `json:"heightContains,omitempty"`
	HeightHasPrefix    *string  `json:"heightHasPrefix,omitempty"`
	HeightHasSuffix    *string  `json:"heightHasSuffix,omitempty"`
	HeightEqualFold    *string  `json:"heightEqualFold,omitempty"`
	HeightContainsFold *string  `json:"heightContainsFold,omitempty"`

	// "is_full_depth" field predicates.
	IsFullDepth    *bool `json:"isFullDepth,omitempty"`
	IsFullDepthNEQ *bool `json:"isFullDepthNEQ,omitempty"`

	// "chassis" edge predicates.
	HasChassis     *bool                      `json:"hasChassis,omitempty"`
	HasChassisWith []*ServerChassisWhereInput `json:"hasChassisWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerChassisTypeWhereInput) AddPredicates(predicates ...predicate.ServerChassisType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerChassisTypeWhereInput filter on the ServerChassisTypeQuery builder.
func (i *ServerChassisTypeWhereInput) Filter(q *ServerChassisTypeQuery) (*ServerChassisTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerChassisTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerChassisTypeWhereInput is returned in case the ServerChassisTypeWhereInput is empty.
var ErrEmptyServerChassisTypeWhereInput = errors.New("generated: empty predicate ServerChassisTypeWhereInput")

// P returns a predicate for filtering serverchassistypes.
// An error is returned if the input is empty or invalid.
func (i *ServerChassisTypeWhereInput) P() (predicate.ServerChassisType, error) {
	var predicates []predicate.ServerChassisType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverchassistype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerChassisType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverchassistype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerChassisType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverchassistype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverchassistype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverchassistype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverchassistype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverchassistype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverchassistype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverchassistype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverchassistype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverchassistype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverchassistype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverchassistype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverchassistype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassistype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverchassistype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverchassistype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverchassistype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverchassistype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverchassistype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverchassistype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverchassistype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, serverchassistype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, serverchassistype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, serverchassistype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, serverchassistype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, serverchassistype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, serverchassistype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, serverchassistype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, serverchassistype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, serverchassistype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, serverchassistype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, serverchassistype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, serverchassistype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, serverchassistype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, serverchassistype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, serverchassistype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, serverchassistype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, serverchassistype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, serverchassistype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, serverchassistype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, serverchassistype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, serverchassistype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, serverchassistype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, serverchassistype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, serverchassistype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, serverchassistype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, serverchassistype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Height != nil {
		predicates = append(predicates, serverchassistype.HeightEQ(*i.Height))
	}
	if i.HeightNEQ != nil {
		predicates = append(predicates, serverchassistype.HeightNEQ(*i.HeightNEQ))
	}
	if len(i.HeightIn) > 0 {
		predicates = append(predicates, serverchassistype.HeightIn(i.HeightIn...))
	}
	if len(i.HeightNotIn) > 0 {
		predicates = append(predicates, serverchassistype.HeightNotIn(i.HeightNotIn...))
	}
	if i.HeightGT != nil {
		predicates = append(predicates, serverchassistype.HeightGT(*i.HeightGT))
	}
	if i.HeightGTE != nil {
		predicates = append(predicates, serverchassistype.HeightGTE(*i.HeightGTE))
	}
	if i.HeightLT != nil {
		predicates = append(predicates, serverchassistype.HeightLT(*i.HeightLT))
	}
	if i.HeightLTE != nil {
		predicates = append(predicates, serverchassistype.HeightLTE(*i.HeightLTE))
	}
	if i.HeightContains != nil {
		predicates = append(predicates, serverchassistype.HeightContains(*i.HeightContains))
	}
	if i.HeightHasPrefix != nil {
		predicates = append(predicates, serverchassistype.HeightHasPrefix(*i.HeightHasPrefix))
	}
	if i.HeightHasSuffix != nil {
		predicates = append(predicates, serverchassistype.HeightHasSuffix(*i.HeightHasSuffix))
	}
	if i.HeightEqualFold != nil {
		predicates = append(predicates, serverchassistype.HeightEqualFold(*i.HeightEqualFold))
	}
	if i.HeightContainsFold != nil {
		predicates = append(predicates, serverchassistype.HeightContainsFold(*i.HeightContainsFold))
	}
	if i.IsFullDepth != nil {
		predicates = append(predicates, serverchassistype.IsFullDepthEQ(*i.IsFullDepth))
	}
	if i.IsFullDepthNEQ != nil {
		predicates = append(predicates, serverchassistype.IsFullDepthNEQ(*i.IsFullDepthNEQ))
	}

	if i.HasChassis != nil {
		p := serverchassistype.HasChassis()
		if !*i.HasChassis {
			p = serverchassistype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChassisWith) > 0 {
		with := make([]predicate.ServerChassis, 0, len(i.HasChassisWith))
		for _, w := range i.HasChassisWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChassisWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverchassistype.HasChassisWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerChassisTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverchassistype.And(predicates...), nil
	}
}

// ServerComponentWhereInput represents a where input for filtering ServerComponent queries.
type ServerComponentWhereInput struct {
	Predicates []predicate.ServerComponent  `json:"-"`
	Not        *ServerComponentWhereInput   `json:"not,omitempty"`
	Or         []*ServerComponentWhereInput `json:"or,omitempty"`
	And        []*ServerComponentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "component_type" edge predicates.
	HasComponentType     *bool                            `json:"hasComponentType,omitempty"`
	HasComponentTypeWith []*ServerComponentTypeWhereInput `json:"hasComponentTypeWith,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerComponentWhereInput) AddPredicates(predicates ...predicate.ServerComponent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerComponentWhereInput filter on the ServerComponentQuery builder.
func (i *ServerComponentWhereInput) Filter(q *ServerComponentQuery) (*ServerComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerComponentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerComponentWhereInput is returned in case the ServerComponentWhereInput is empty.
var ErrEmptyServerComponentWhereInput = errors.New("generated: empty predicate ServerComponentWhereInput")

// P returns a predicate for filtering servercomponents.
// An error is returned if the input is empty or invalid.
func (i *ServerComponentWhereInput) P() (predicate.ServerComponent, error) {
	var predicates []predicate.ServerComponent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercomponent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerComponent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercomponent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerComponent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercomponent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercomponent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercomponent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercomponent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercomponent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercomponent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercomponent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercomponent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercomponent.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercomponent.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercomponent.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercomponent.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponent.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercomponent.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercomponent.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercomponent.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercomponent.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercomponent.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercomponent.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercomponent.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponent.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercomponent.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercomponent.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercomponent.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercomponent.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servercomponent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servercomponent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servercomponent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servercomponent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servercomponent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servercomponent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servercomponent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servercomponent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servercomponent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servercomponent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servercomponent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servercomponent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servercomponent.NameContainsFold(*i.NameContainsFold))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servercomponent.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servercomponent.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servercomponent.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servercomponent.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servercomponent.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servercomponent.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servercomponent.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servercomponent.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servercomponent.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servercomponent.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servercomponent.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servercomponent.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servercomponent.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servercomponent.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servercomponent.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servercomponent.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servercomponent.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servercomponent.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servercomponent.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servercomponent.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servercomponent.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servercomponent.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servercomponent.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servercomponent.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servercomponent.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servercomponent.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Serial != nil {
		predicates = append(predicates, servercomponent.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servercomponent.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servercomponent.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servercomponent.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servercomponent.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servercomponent.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servercomponent.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servercomponent.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servercomponent.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servercomponent.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servercomponent.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servercomponent.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servercomponent.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasComponentType != nil {
		p := servercomponent.HasComponentType()
		if !*i.HasComponentType {
			p = servercomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentTypeWith) > 0 {
		with := make([]predicate.ServerComponentType, 0, len(i.HasComponentTypeWith))
		for _, w := range i.HasComponentTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasComponentTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercomponent.HasComponentTypeWith(with...))
	}
	if i.HasServer != nil {
		p := servercomponent.HasServer()
		if !*i.HasServer {
			p = servercomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servercomponent.HasServerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerComponentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercomponent.And(predicates...), nil
	}
}

// ServerComponentTypeWhereInput represents a where input for filtering ServerComponentType queries.
type ServerComponentTypeWhereInput struct {
	Predicates []predicate.ServerComponentType  `json:"-"`
	Not        *ServerComponentTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerComponentTypeWhereInput `json:"or,omitempty"`
	And        []*ServerComponentTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerComponentTypeWhereInput) AddPredicates(predicates ...predicate.ServerComponentType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerComponentTypeWhereInput filter on the ServerComponentTypeQuery builder.
func (i *ServerComponentTypeWhereInput) Filter(q *ServerComponentTypeQuery) (*ServerComponentTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerComponentTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerComponentTypeWhereInput is returned in case the ServerComponentTypeWhereInput is empty.
var ErrEmptyServerComponentTypeWhereInput = errors.New("generated: empty predicate ServerComponentTypeWhereInput")

// P returns a predicate for filtering servercomponenttypes.
// An error is returned if the input is empty or invalid.
func (i *ServerComponentTypeWhereInput) P() (predicate.ServerComponentType, error) {
	var predicates []predicate.ServerComponentType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servercomponenttype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerComponentType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servercomponenttype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerComponentType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servercomponenttype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servercomponenttype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servercomponenttype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servercomponenttype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servercomponenttype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servercomponenttype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servercomponenttype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servercomponenttype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servercomponenttype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servercomponenttype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servercomponenttype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servercomponenttype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servercomponenttype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servercomponenttype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servercomponenttype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servercomponenttype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servercomponenttype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servercomponenttype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servercomponenttype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servercomponenttype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servercomponenttype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servercomponenttype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servercomponenttype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servercomponenttype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servercomponenttype.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerComponentTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servercomponenttype.And(predicates...), nil
	}
}

// ServerHardDriveWhereInput represents a where input for filtering ServerHardDrive queries.
type ServerHardDriveWhereInput struct {
	Predicates []predicate.ServerHardDrive  `json:"-"`
	Not        *ServerHardDriveWhereInput   `json:"not,omitempty"`
	Or         []*ServerHardDriveWhereInput `json:"or,omitempty"`
	And        []*ServerHardDriveWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "hard_drive_type" edge predicates.
	HasHardDriveType     *bool                            `json:"hasHardDriveType,omitempty"`
	HasHardDriveTypeWith []*ServerHardDriveTypeWhereInput `json:"hasHardDriveTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerHardDriveWhereInput) AddPredicates(predicates ...predicate.ServerHardDrive) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerHardDriveWhereInput filter on the ServerHardDriveQuery builder.
func (i *ServerHardDriveWhereInput) Filter(q *ServerHardDriveQuery) (*ServerHardDriveQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerHardDriveWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerHardDriveWhereInput is returned in case the ServerHardDriveWhereInput is empty.
var ErrEmptyServerHardDriveWhereInput = errors.New("generated: empty predicate ServerHardDriveWhereInput")

// P returns a predicate for filtering serverharddrives.
// An error is returned if the input is empty or invalid.
func (i *ServerHardDriveWhereInput) P() (predicate.ServerHardDrive, error) {
	var predicates []predicate.ServerHardDrive
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverharddrive.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerHardDrive, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverharddrive.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerHardDrive, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverharddrive.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverharddrive.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverharddrive.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverharddrive.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverharddrive.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverharddrive.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverharddrive.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverharddrive.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverharddrive.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverharddrive.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverharddrive.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverharddrive.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverharddrive.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverharddrive.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverharddrive.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverharddrive.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverharddrive.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverharddrive.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverharddrive.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverharddrive.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, serverharddrive.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, serverharddrive.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, serverharddrive.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, serverharddrive.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, serverharddrive.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, serverharddrive.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, serverharddrive.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, serverharddrive.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, serverharddrive.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, serverharddrive.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, serverharddrive.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, serverharddrive.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, serverharddrive.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := serverharddrive.HasServer()
		if !*i.HasServer {
			p = serverharddrive.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverharddrive.HasServerWith(with...))
	}
	if i.HasHardDriveType != nil {
		p := serverharddrive.HasHardDriveType()
		if !*i.HasHardDriveType {
			p = serverharddrive.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHardDriveTypeWith) > 0 {
		with := make([]predicate.ServerHardDriveType, 0, len(i.HasHardDriveTypeWith))
		for _, w := range i.HasHardDriveTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHardDriveTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverharddrive.HasHardDriveTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerHardDriveWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverharddrive.And(predicates...), nil
	}
}

// ServerHardDriveTypeWhereInput represents a where input for filtering ServerHardDriveType queries.
type ServerHardDriveTypeWhereInput struct {
	Predicates []predicate.ServerHardDriveType  `json:"-"`
	Not        *ServerHardDriveTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerHardDriveTypeWhereInput `json:"or,omitempty"`
	And        []*ServerHardDriveTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "speed" field predicates.
	Speed             *string  `json:"speed,omitempty"`
	SpeedNEQ          *string  `json:"speedNEQ,omitempty"`
	SpeedIn           []string `json:"speedIn,omitempty"`
	SpeedNotIn        []string `json:"speedNotIn,omitempty"`
	SpeedGT           *string  `json:"speedGT,omitempty"`
	SpeedGTE          *string  `json:"speedGTE,omitempty"`
	SpeedLT           *string  `json:"speedLT,omitempty"`
	SpeedLTE          *string  `json:"speedLTE,omitempty"`
	SpeedContains     *string  `json:"speedContains,omitempty"`
	SpeedHasPrefix    *string  `json:"speedHasPrefix,omitempty"`
	SpeedHasSuffix    *string  `json:"speedHasSuffix,omitempty"`
	SpeedEqualFold    *string  `json:"speedEqualFold,omitempty"`
	SpeedContainsFold *string  `json:"speedContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "capacity" field predicates.
	Capacity             *string  `json:"capacity,omitempty"`
	CapacityNEQ          *string  `json:"capacityNEQ,omitempty"`
	CapacityIn           []string `json:"capacityIn,omitempty"`
	CapacityNotIn        []string `json:"capacityNotIn,omitempty"`
	CapacityGT           *string  `json:"capacityGT,omitempty"`
	CapacityGTE          *string  `json:"capacityGTE,omitempty"`
	CapacityLT           *string  `json:"capacityLT,omitempty"`
	CapacityLTE          *string  `json:"capacityLTE,omitempty"`
	CapacityContains     *string  `json:"capacityContains,omitempty"`
	CapacityHasPrefix    *string  `json:"capacityHasPrefix,omitempty"`
	CapacityHasSuffix    *string  `json:"capacityHasSuffix,omitempty"`
	CapacityEqualFold    *string  `json:"capacityEqualFold,omitempty"`
	CapacityContainsFold *string  `json:"capacityContainsFold,omitempty"`

	// "hard_drive" edge predicates.
	HasHardDrive     *bool                        `json:"hasHardDrive,omitempty"`
	HasHardDriveWith []*ServerHardDriveWhereInput `json:"hasHardDriveWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerHardDriveTypeWhereInput) AddPredicates(predicates ...predicate.ServerHardDriveType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerHardDriveTypeWhereInput filter on the ServerHardDriveTypeQuery builder.
func (i *ServerHardDriveTypeWhereInput) Filter(q *ServerHardDriveTypeQuery) (*ServerHardDriveTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerHardDriveTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerHardDriveTypeWhereInput is returned in case the ServerHardDriveTypeWhereInput is empty.
var ErrEmptyServerHardDriveTypeWhereInput = errors.New("generated: empty predicate ServerHardDriveTypeWhereInput")

// P returns a predicate for filtering serverharddrivetypes.
// An error is returned if the input is empty or invalid.
func (i *ServerHardDriveTypeWhereInput) P() (predicate.ServerHardDriveType, error) {
	var predicates []predicate.ServerHardDriveType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverharddrivetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerHardDriveType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverharddrivetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerHardDriveType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverharddrivetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverharddrivetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverharddrivetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverharddrivetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverharddrivetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverharddrivetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverharddrivetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverharddrivetype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverharddrivetype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverharddrivetype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverharddrivetype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverharddrivetype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, serverharddrivetype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, serverharddrivetype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, serverharddrivetype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, serverharddrivetype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, serverharddrivetype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, serverharddrivetype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, serverharddrivetype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, serverharddrivetype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, serverharddrivetype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, serverharddrivetype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, serverharddrivetype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, serverharddrivetype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, serverharddrivetype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, serverharddrivetype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, serverharddrivetype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, serverharddrivetype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, serverharddrivetype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, serverharddrivetype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, serverharddrivetype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, serverharddrivetype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, serverharddrivetype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, serverharddrivetype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, serverharddrivetype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, serverharddrivetype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Speed != nil {
		predicates = append(predicates, serverharddrivetype.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, serverharddrivetype.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, serverharddrivetype.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, serverharddrivetype.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, serverharddrivetype.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, serverharddrivetype.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, serverharddrivetype.SpeedLTE(*i.SpeedLTE))
	}
	if i.SpeedContains != nil {
		predicates = append(predicates, serverharddrivetype.SpeedContains(*i.SpeedContains))
	}
	if i.SpeedHasPrefix != nil {
		predicates = append(predicates, serverharddrivetype.SpeedHasPrefix(*i.SpeedHasPrefix))
	}
	if i.SpeedHasSuffix != nil {
		predicates = append(predicates, serverharddrivetype.SpeedHasSuffix(*i.SpeedHasSuffix))
	}
	if i.SpeedEqualFold != nil {
		predicates = append(predicates, serverharddrivetype.SpeedEqualFold(*i.SpeedEqualFold))
	}
	if i.SpeedContainsFold != nil {
		predicates = append(predicates, serverharddrivetype.SpeedContainsFold(*i.SpeedContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, serverharddrivetype.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, serverharddrivetype.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, serverharddrivetype.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, serverharddrivetype.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, serverharddrivetype.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, serverharddrivetype.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, serverharddrivetype.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, serverharddrivetype.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, serverharddrivetype.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, serverharddrivetype.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, serverharddrivetype.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, serverharddrivetype.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Capacity != nil {
		predicates = append(predicates, serverharddrivetype.CapacityEQ(*i.Capacity))
	}
	if i.CapacityNEQ != nil {
		predicates = append(predicates, serverharddrivetype.CapacityNEQ(*i.CapacityNEQ))
	}
	if len(i.CapacityIn) > 0 {
		predicates = append(predicates, serverharddrivetype.CapacityIn(i.CapacityIn...))
	}
	if len(i.CapacityNotIn) > 0 {
		predicates = append(predicates, serverharddrivetype.CapacityNotIn(i.CapacityNotIn...))
	}
	if i.CapacityGT != nil {
		predicates = append(predicates, serverharddrivetype.CapacityGT(*i.CapacityGT))
	}
	if i.CapacityGTE != nil {
		predicates = append(predicates, serverharddrivetype.CapacityGTE(*i.CapacityGTE))
	}
	if i.CapacityLT != nil {
		predicates = append(predicates, serverharddrivetype.CapacityLT(*i.CapacityLT))
	}
	if i.CapacityLTE != nil {
		predicates = append(predicates, serverharddrivetype.CapacityLTE(*i.CapacityLTE))
	}
	if i.CapacityContains != nil {
		predicates = append(predicates, serverharddrivetype.CapacityContains(*i.CapacityContains))
	}
	if i.CapacityHasPrefix != nil {
		predicates = append(predicates, serverharddrivetype.CapacityHasPrefix(*i.CapacityHasPrefix))
	}
	if i.CapacityHasSuffix != nil {
		predicates = append(predicates, serverharddrivetype.CapacityHasSuffix(*i.CapacityHasSuffix))
	}
	if i.CapacityEqualFold != nil {
		predicates = append(predicates, serverharddrivetype.CapacityEqualFold(*i.CapacityEqualFold))
	}
	if i.CapacityContainsFold != nil {
		predicates = append(predicates, serverharddrivetype.CapacityContainsFold(*i.CapacityContainsFold))
	}

	if i.HasHardDrive != nil {
		p := serverharddrivetype.HasHardDrive()
		if !*i.HasHardDrive {
			p = serverharddrivetype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHardDriveWith) > 0 {
		with := make([]predicate.ServerHardDrive, 0, len(i.HasHardDriveWith))
		for _, w := range i.HasHardDriveWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHardDriveWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverharddrivetype.HasHardDriveWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerHardDriveTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverharddrivetype.And(predicates...), nil
	}
}

// ServerMemoryWhereInput represents a where input for filtering ServerMemory queries.
type ServerMemoryWhereInput struct {
	Predicates []predicate.ServerMemory  `json:"-"`
	Not        *ServerMemoryWhereInput   `json:"not,omitempty"`
	Or         []*ServerMemoryWhereInput `json:"or,omitempty"`
	And        []*ServerMemoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_memory_type" edge predicates.
	HasServerMemoryType     *bool                         `json:"hasServerMemoryType,omitempty"`
	HasServerMemoryTypeWith []*ServerMemoryTypeWhereInput `json:"hasServerMemoryTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMemoryWhereInput) AddPredicates(predicates ...predicate.ServerMemory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMemoryWhereInput filter on the ServerMemoryQuery builder.
func (i *ServerMemoryWhereInput) Filter(q *ServerMemoryQuery) (*ServerMemoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMemoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMemoryWhereInput is returned in case the ServerMemoryWhereInput is empty.
var ErrEmptyServerMemoryWhereInput = errors.New("generated: empty predicate ServerMemoryWhereInput")

// P returns a predicate for filtering servermemories.
// An error is returned if the input is empty or invalid.
func (i *ServerMemoryWhereInput) P() (predicate.ServerMemory, error) {
	var predicates []predicate.ServerMemory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermemory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMemory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermemory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMemory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermemory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermemory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermemory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermemory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermemory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermemory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermemory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermemory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermemory.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermemory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermemory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermemory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermemory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermemory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermemory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermemory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermemory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermemory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermemory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermemory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermemory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermemory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermemory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermemory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermemory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servermemory.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servermemory.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servermemory.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servermemory.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servermemory.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servermemory.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servermemory.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servermemory.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servermemory.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servermemory.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servermemory.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servermemory.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servermemory.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := servermemory.HasServer()
		if !*i.HasServer {
			p = servermemory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermemory.HasServerWith(with...))
	}
	if i.HasServerMemoryType != nil {
		p := servermemory.HasServerMemoryType()
		if !*i.HasServerMemoryType {
			p = servermemory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerMemoryTypeWith) > 0 {
		with := make([]predicate.ServerMemoryType, 0, len(i.HasServerMemoryTypeWith))
		for _, w := range i.HasServerMemoryTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerMemoryTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermemory.HasServerMemoryTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMemoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermemory.And(predicates...), nil
	}
}

// ServerMemoryTypeWhereInput represents a where input for filtering ServerMemoryType queries.
type ServerMemoryTypeWhereInput struct {
	Predicates []predicate.ServerMemoryType  `json:"-"`
	Not        *ServerMemoryTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerMemoryTypeWhereInput `json:"or,omitempty"`
	And        []*ServerMemoryTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "speed" field predicates.
	Speed             *string  `json:"speed,omitempty"`
	SpeedNEQ          *string  `json:"speedNEQ,omitempty"`
	SpeedIn           []string `json:"speedIn,omitempty"`
	SpeedNotIn        []string `json:"speedNotIn,omitempty"`
	SpeedGT           *string  `json:"speedGT,omitempty"`
	SpeedGTE          *string  `json:"speedGTE,omitempty"`
	SpeedLT           *string  `json:"speedLT,omitempty"`
	SpeedLTE          *string  `json:"speedLTE,omitempty"`
	SpeedContains     *string  `json:"speedContains,omitempty"`
	SpeedHasPrefix    *string  `json:"speedHasPrefix,omitempty"`
	SpeedHasSuffix    *string  `json:"speedHasSuffix,omitempty"`
	SpeedEqualFold    *string  `json:"speedEqualFold,omitempty"`
	SpeedContainsFold *string  `json:"speedContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "memory" edge predicates.
	HasMemory     *bool                     `json:"hasMemory,omitempty"`
	HasMemoryWith []*ServerMemoryWhereInput `json:"hasMemoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMemoryTypeWhereInput) AddPredicates(predicates ...predicate.ServerMemoryType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMemoryTypeWhereInput filter on the ServerMemoryTypeQuery builder.
func (i *ServerMemoryTypeWhereInput) Filter(q *ServerMemoryTypeQuery) (*ServerMemoryTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMemoryTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMemoryTypeWhereInput is returned in case the ServerMemoryTypeWhereInput is empty.
var ErrEmptyServerMemoryTypeWhereInput = errors.New("generated: empty predicate ServerMemoryTypeWhereInput")

// P returns a predicate for filtering servermemorytypes.
// An error is returned if the input is empty or invalid.
func (i *ServerMemoryTypeWhereInput) P() (predicate.ServerMemoryType, error) {
	var predicates []predicate.ServerMemoryType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermemorytype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMemoryType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermemorytype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMemoryType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermemorytype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermemorytype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermemorytype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermemorytype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermemorytype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermemorytype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermemorytype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermemorytype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermemorytype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermemorytype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermemorytype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermemorytype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermemorytype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermemorytype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermemorytype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermemorytype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermemorytype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermemorytype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermemorytype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermemorytype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servermemorytype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servermemorytype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servermemorytype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servermemorytype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servermemorytype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servermemorytype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servermemorytype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servermemorytype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servermemorytype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servermemorytype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servermemorytype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servermemorytype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servermemorytype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servermemorytype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servermemorytype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servermemorytype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servermemorytype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servermemorytype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servermemorytype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servermemorytype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servermemorytype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servermemorytype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servermemorytype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servermemorytype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servermemorytype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servermemorytype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Speed != nil {
		predicates = append(predicates, servermemorytype.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, servermemorytype.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, servermemorytype.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, servermemorytype.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, servermemorytype.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, servermemorytype.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, servermemorytype.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, servermemorytype.SpeedLTE(*i.SpeedLTE))
	}
	if i.SpeedContains != nil {
		predicates = append(predicates, servermemorytype.SpeedContains(*i.SpeedContains))
	}
	if i.SpeedHasPrefix != nil {
		predicates = append(predicates, servermemorytype.SpeedHasPrefix(*i.SpeedHasPrefix))
	}
	if i.SpeedHasSuffix != nil {
		predicates = append(predicates, servermemorytype.SpeedHasSuffix(*i.SpeedHasSuffix))
	}
	if i.SpeedEqualFold != nil {
		predicates = append(predicates, servermemorytype.SpeedEqualFold(*i.SpeedEqualFold))
	}
	if i.SpeedContainsFold != nil {
		predicates = append(predicates, servermemorytype.SpeedContainsFold(*i.SpeedContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, servermemorytype.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, servermemorytype.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, servermemorytype.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, servermemorytype.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, servermemorytype.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, servermemorytype.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, servermemorytype.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, servermemorytype.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, servermemorytype.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, servermemorytype.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, servermemorytype.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, servermemorytype.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, servermemorytype.SizeContainsFold(*i.SizeContainsFold))
	}

	if i.HasMemory != nil {
		p := servermemorytype.HasMemory()
		if !*i.HasMemory {
			p = servermemorytype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMemoryWith) > 0 {
		with := make([]predicate.ServerMemory, 0, len(i.HasMemoryWith))
		for _, w := range i.HasMemoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMemoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermemorytype.HasMemoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMemoryTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermemorytype.And(predicates...), nil
	}
}

// ServerMotherboardWhereInput represents a where input for filtering ServerMotherboard queries.
type ServerMotherboardWhereInput struct {
	Predicates []predicate.ServerMotherboard  `json:"-"`
	Not        *ServerMotherboardWhereInput   `json:"not,omitempty"`
	Or         []*ServerMotherboardWhereInput `json:"or,omitempty"`
	And        []*ServerMotherboardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_motherboard_type" edge predicates.
	HasServerMotherboardType     *bool                              `json:"hasServerMotherboardType,omitempty"`
	HasServerMotherboardTypeWith []*ServerMotherboardTypeWhereInput `json:"hasServerMotherboardTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMotherboardWhereInput) AddPredicates(predicates ...predicate.ServerMotherboard) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMotherboardWhereInput filter on the ServerMotherboardQuery builder.
func (i *ServerMotherboardWhereInput) Filter(q *ServerMotherboardQuery) (*ServerMotherboardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMotherboardWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMotherboardWhereInput is returned in case the ServerMotherboardWhereInput is empty.
var ErrEmptyServerMotherboardWhereInput = errors.New("generated: empty predicate ServerMotherboardWhereInput")

// P returns a predicate for filtering servermotherboards.
// An error is returned if the input is empty or invalid.
func (i *ServerMotherboardWhereInput) P() (predicate.ServerMotherboard, error) {
	var predicates []predicate.ServerMotherboard
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermotherboard.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMotherboard, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermotherboard.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMotherboard, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermotherboard.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermotherboard.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermotherboard.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermotherboard.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermotherboard.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermotherboard.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermotherboard.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermotherboard.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermotherboard.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermotherboard.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermotherboard.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermotherboard.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboard.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermotherboard.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermotherboard.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermotherboard.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermotherboard.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermotherboard.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboard.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermotherboard.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servermotherboard.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servermotherboard.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servermotherboard.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servermotherboard.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servermotherboard.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servermotherboard.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servermotherboard.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servermotherboard.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servermotherboard.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servermotherboard.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servermotherboard.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servermotherboard.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servermotherboard.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := servermotherboard.HasServer()
		if !*i.HasServer {
			p = servermotherboard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboard.HasServerWith(with...))
	}
	if i.HasServerMotherboardType != nil {
		p := servermotherboard.HasServerMotherboardType()
		if !*i.HasServerMotherboardType {
			p = servermotherboard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerMotherboardTypeWith) > 0 {
		with := make([]predicate.ServerMotherboardType, 0, len(i.HasServerMotherboardTypeWith))
		for _, w := range i.HasServerMotherboardTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerMotherboardTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboard.HasServerMotherboardTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMotherboardWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermotherboard.And(predicates...), nil
	}
}

// ServerMotherboardTypeWhereInput represents a where input for filtering ServerMotherboardType queries.
type ServerMotherboardTypeWhereInput struct {
	Predicates []predicate.ServerMotherboardType  `json:"-"`
	Not        *ServerMotherboardTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerMotherboardTypeWhereInput `json:"or,omitempty"`
	And        []*ServerMotherboardTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "motherboard" edge predicates.
	HasMotherboard     *bool                          `json:"hasMotherboard,omitempty"`
	HasMotherboardWith []*ServerMotherboardWhereInput `json:"hasMotherboardWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerMotherboardTypeWhereInput) AddPredicates(predicates ...predicate.ServerMotherboardType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerMotherboardTypeWhereInput filter on the ServerMotherboardTypeQuery builder.
func (i *ServerMotherboardTypeWhereInput) Filter(q *ServerMotherboardTypeQuery) (*ServerMotherboardTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerMotherboardTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerMotherboardTypeWhereInput is returned in case the ServerMotherboardTypeWhereInput is empty.
var ErrEmptyServerMotherboardTypeWhereInput = errors.New("generated: empty predicate ServerMotherboardTypeWhereInput")

// P returns a predicate for filtering servermotherboardtypes.
// An error is returned if the input is empty or invalid.
func (i *ServerMotherboardTypeWhereInput) P() (predicate.ServerMotherboardType, error) {
	var predicates []predicate.ServerMotherboardType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servermotherboardtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerMotherboardType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servermotherboardtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerMotherboardType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servermotherboardtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servermotherboardtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servermotherboardtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servermotherboardtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servermotherboardtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servermotherboardtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servermotherboardtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servermotherboardtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servermotherboardtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servermotherboardtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servermotherboardtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servermotherboardtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servermotherboardtype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servermotherboardtype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servermotherboardtype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servermotherboardtype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servermotherboardtype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servermotherboardtype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servermotherboardtype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servermotherboardtype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servermotherboardtype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servermotherboardtype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servermotherboardtype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servermotherboardtype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servermotherboardtype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servermotherboardtype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servermotherboardtype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servermotherboardtype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servermotherboardtype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servermotherboardtype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servermotherboardtype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servermotherboardtype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servermotherboardtype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servermotherboardtype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servermotherboardtype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servermotherboardtype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servermotherboardtype.ModelContainsFold(*i.ModelContainsFold))
	}

	if i.HasMotherboard != nil {
		p := servermotherboardtype.HasMotherboard()
		if !*i.HasMotherboard {
			p = servermotherboardtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMotherboardWith) > 0 {
		with := make([]predicate.ServerMotherboard, 0, len(i.HasMotherboardWith))
		for _, w := range i.HasMotherboardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMotherboardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servermotherboardtype.HasMotherboardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerMotherboardTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servermotherboardtype.And(predicates...), nil
	}
}

// ServerNetworkCardWhereInput represents a where input for filtering ServerNetworkCard queries.
type ServerNetworkCardWhereInput struct {
	Predicates []predicate.ServerNetworkCard  `json:"-"`
	Not        *ServerNetworkCardWhereInput   `json:"not,omitempty"`
	Or         []*ServerNetworkCardWhereInput `json:"or,omitempty"`
	And        []*ServerNetworkCardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "network_card_type" edge predicates.
	HasNetworkCardType     *bool                              `json:"hasNetworkCardType,omitempty"`
	HasNetworkCardTypeWith []*ServerNetworkCardTypeWhereInput `json:"hasNetworkCardTypeWith,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "network_port" edge predicates.
	HasNetworkPort     *bool                          `json:"hasNetworkPort,omitempty"`
	HasNetworkPortWith []*ServerNetworkPortWhereInput `json:"hasNetworkPortWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerNetworkCardWhereInput) AddPredicates(predicates ...predicate.ServerNetworkCard) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerNetworkCardWhereInput filter on the ServerNetworkCardQuery builder.
func (i *ServerNetworkCardWhereInput) Filter(q *ServerNetworkCardQuery) (*ServerNetworkCardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerNetworkCardWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerNetworkCardWhereInput is returned in case the ServerNetworkCardWhereInput is empty.
var ErrEmptyServerNetworkCardWhereInput = errors.New("generated: empty predicate ServerNetworkCardWhereInput")

// P returns a predicate for filtering servernetworkcards.
// An error is returned if the input is empty or invalid.
func (i *ServerNetworkCardWhereInput) P() (predicate.ServerNetworkCard, error) {
	var predicates []predicate.ServerNetworkCard
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servernetworkcard.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerNetworkCard, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servernetworkcard.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerNetworkCard, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servernetworkcard.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servernetworkcard.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servernetworkcard.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servernetworkcard.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servernetworkcard.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servernetworkcard.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servernetworkcard.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servernetworkcard.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servernetworkcard.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servernetworkcard.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkcard.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servernetworkcard.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servernetworkcard.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkcard.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servernetworkcard.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, servernetworkcard.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, servernetworkcard.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, servernetworkcard.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, servernetworkcard.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, servernetworkcard.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, servernetworkcard.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, servernetworkcard.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, servernetworkcard.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, servernetworkcard.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, servernetworkcard.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, servernetworkcard.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, servernetworkcard.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, servernetworkcard.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasNetworkCardType != nil {
		p := servernetworkcard.HasNetworkCardType()
		if !*i.HasNetworkCardType {
			p = servernetworkcard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkCardTypeWith) > 0 {
		with := make([]predicate.ServerNetworkCardType, 0, len(i.HasNetworkCardTypeWith))
		for _, w := range i.HasNetworkCardTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkCardTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servernetworkcard.HasNetworkCardTypeWith(with...))
	}
	if i.HasServer != nil {
		p := servernetworkcard.HasServer()
		if !*i.HasServer {
			p = servernetworkcard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servernetworkcard.HasServerWith(with...))
	}
	if i.HasNetworkPort != nil {
		p := servernetworkcard.HasNetworkPort()
		if !*i.HasNetworkPort {
			p = servernetworkcard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkPortWith) > 0 {
		with := make([]predicate.ServerNetworkPort, 0, len(i.HasNetworkPortWith))
		for _, w := range i.HasNetworkPortWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkPortWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servernetworkcard.HasNetworkPortWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerNetworkCardWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servernetworkcard.And(predicates...), nil
	}
}

// ServerNetworkCardTypeWhereInput represents a where input for filtering ServerNetworkCardType queries.
type ServerNetworkCardTypeWhereInput struct {
	Predicates []predicate.ServerNetworkCardType  `json:"-"`
	Not        *ServerNetworkCardTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerNetworkCardTypeWhereInput `json:"or,omitempty"`
	And        []*ServerNetworkCardTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "port_count" field predicates.
	PortCount      *int  `json:"portCount,omitempty"`
	PortCountNEQ   *int  `json:"portCountNEQ,omitempty"`
	PortCountIn    []int `json:"portCountIn,omitempty"`
	PortCountNotIn []int `json:"portCountNotIn,omitempty"`
	PortCountGT    *int  `json:"portCountGT,omitempty"`
	PortCountGTE   *int  `json:"portCountGTE,omitempty"`
	PortCountLT    *int  `json:"portCountLT,omitempty"`
	PortCountLTE   *int  `json:"portCountLTE,omitempty"`

	// "network_card" edge predicates.
	HasNetworkCard     *bool                          `json:"hasNetworkCard,omitempty"`
	HasNetworkCardWith []*ServerNetworkCardWhereInput `json:"hasNetworkCardWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerNetworkCardTypeWhereInput) AddPredicates(predicates ...predicate.ServerNetworkCardType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerNetworkCardTypeWhereInput filter on the ServerNetworkCardTypeQuery builder.
func (i *ServerNetworkCardTypeWhereInput) Filter(q *ServerNetworkCardTypeQuery) (*ServerNetworkCardTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerNetworkCardTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerNetworkCardTypeWhereInput is returned in case the ServerNetworkCardTypeWhereInput is empty.
var ErrEmptyServerNetworkCardTypeWhereInput = errors.New("generated: empty predicate ServerNetworkCardTypeWhereInput")

// P returns a predicate for filtering servernetworkcardtypes.
// An error is returned if the input is empty or invalid.
func (i *ServerNetworkCardTypeWhereInput) P() (predicate.ServerNetworkCardType, error) {
	var predicates []predicate.ServerNetworkCardType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servernetworkcardtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerNetworkCardType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servernetworkcardtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerNetworkCardType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servernetworkcardtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servernetworkcardtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servernetworkcardtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servernetworkcardtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servernetworkcardtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servernetworkcardtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servernetworkcardtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servernetworkcardtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, servernetworkcardtype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, servernetworkcardtype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, servernetworkcardtype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, servernetworkcardtype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, servernetworkcardtype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, servernetworkcardtype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, servernetworkcardtype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, servernetworkcardtype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, servernetworkcardtype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, servernetworkcardtype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, servernetworkcardtype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, servernetworkcardtype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, servernetworkcardtype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, servernetworkcardtype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, servernetworkcardtype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, servernetworkcardtype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, servernetworkcardtype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, servernetworkcardtype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, servernetworkcardtype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, servernetworkcardtype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.PortCount != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountEQ(*i.PortCount))
	}
	if i.PortCountNEQ != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountNEQ(*i.PortCountNEQ))
	}
	if len(i.PortCountIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.PortCountIn(i.PortCountIn...))
	}
	if len(i.PortCountNotIn) > 0 {
		predicates = append(predicates, servernetworkcardtype.PortCountNotIn(i.PortCountNotIn...))
	}
	if i.PortCountGT != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountGT(*i.PortCountGT))
	}
	if i.PortCountGTE != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountGTE(*i.PortCountGTE))
	}
	if i.PortCountLT != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountLT(*i.PortCountLT))
	}
	if i.PortCountLTE != nil {
		predicates = append(predicates, servernetworkcardtype.PortCountLTE(*i.PortCountLTE))
	}

	if i.HasNetworkCard != nil {
		p := servernetworkcardtype.HasNetworkCard()
		if !*i.HasNetworkCard {
			p = servernetworkcardtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkCardWith) > 0 {
		with := make([]predicate.ServerNetworkCard, 0, len(i.HasNetworkCardWith))
		for _, w := range i.HasNetworkCardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkCardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servernetworkcardtype.HasNetworkCardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerNetworkCardTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servernetworkcardtype.And(predicates...), nil
	}
}

// ServerNetworkPortWhereInput represents a where input for filtering ServerNetworkPort queries.
type ServerNetworkPortWhereInput struct {
	Predicates []predicate.ServerNetworkPort  `json:"-"`
	Not        *ServerNetworkPortWhereInput   `json:"not,omitempty"`
	Or         []*ServerNetworkPortWhereInput `json:"or,omitempty"`
	And        []*ServerNetworkPortWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "mac_address" field predicates.
	MACAddress             *string  `json:"macAddress,omitempty"`
	MACAddressNEQ          *string  `json:"macAddressNEQ,omitempty"`
	MACAddressIn           []string `json:"macAddressIn,omitempty"`
	MACAddressNotIn        []string `json:"macAddressNotIn,omitempty"`
	MACAddressGT           *string  `json:"macAddressGT,omitempty"`
	MACAddressGTE          *string  `json:"macAddressGTE,omitempty"`
	MACAddressLT           *string  `json:"macAddressLT,omitempty"`
	MACAddressLTE          *string  `json:"macAddressLTE,omitempty"`
	MACAddressContains     *string  `json:"macAddressContains,omitempty"`
	MACAddressHasPrefix    *string  `json:"macAddressHasPrefix,omitempty"`
	MACAddressHasSuffix    *string  `json:"macAddressHasSuffix,omitempty"`
	MACAddressEqualFold    *string  `json:"macAddressEqualFold,omitempty"`
	MACAddressContainsFold *string  `json:"macAddressContainsFold,omitempty"`

	// "network_card" edge predicates.
	HasNetworkCard     *bool                          `json:"hasNetworkCard,omitempty"`
	HasNetworkCardWith []*ServerNetworkCardWhereInput `json:"hasNetworkCardWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerNetworkPortWhereInput) AddPredicates(predicates ...predicate.ServerNetworkPort) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerNetworkPortWhereInput filter on the ServerNetworkPortQuery builder.
func (i *ServerNetworkPortWhereInput) Filter(q *ServerNetworkPortQuery) (*ServerNetworkPortQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerNetworkPortWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerNetworkPortWhereInput is returned in case the ServerNetworkPortWhereInput is empty.
var ErrEmptyServerNetworkPortWhereInput = errors.New("generated: empty predicate ServerNetworkPortWhereInput")

// P returns a predicate for filtering servernetworkports.
// An error is returned if the input is empty or invalid.
func (i *ServerNetworkPortWhereInput) P() (predicate.ServerNetworkPort, error) {
	var predicates []predicate.ServerNetworkPort
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servernetworkport.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerNetworkPort, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servernetworkport.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerNetworkPort, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servernetworkport.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servernetworkport.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servernetworkport.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servernetworkport.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servernetworkport.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servernetworkport.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servernetworkport.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servernetworkport.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servernetworkport.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servernetworkport.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servernetworkport.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servernetworkport.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkport.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servernetworkport.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servernetworkport.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servernetworkport.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servernetworkport.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servernetworkport.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servernetworkport.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servernetworkport.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.MACAddress != nil {
		predicates = append(predicates, servernetworkport.MACAddressEQ(*i.MACAddress))
	}
	if i.MACAddressNEQ != nil {
		predicates = append(predicates, servernetworkport.MACAddressNEQ(*i.MACAddressNEQ))
	}
	if len(i.MACAddressIn) > 0 {
		predicates = append(predicates, servernetworkport.MACAddressIn(i.MACAddressIn...))
	}
	if len(i.MACAddressNotIn) > 0 {
		predicates = append(predicates, servernetworkport.MACAddressNotIn(i.MACAddressNotIn...))
	}
	if i.MACAddressGT != nil {
		predicates = append(predicates, servernetworkport.MACAddressGT(*i.MACAddressGT))
	}
	if i.MACAddressGTE != nil {
		predicates = append(predicates, servernetworkport.MACAddressGTE(*i.MACAddressGTE))
	}
	if i.MACAddressLT != nil {
		predicates = append(predicates, servernetworkport.MACAddressLT(*i.MACAddressLT))
	}
	if i.MACAddressLTE != nil {
		predicates = append(predicates, servernetworkport.MACAddressLTE(*i.MACAddressLTE))
	}
	if i.MACAddressContains != nil {
		predicates = append(predicates, servernetworkport.MACAddressContains(*i.MACAddressContains))
	}
	if i.MACAddressHasPrefix != nil {
		predicates = append(predicates, servernetworkport.MACAddressHasPrefix(*i.MACAddressHasPrefix))
	}
	if i.MACAddressHasSuffix != nil {
		predicates = append(predicates, servernetworkport.MACAddressHasSuffix(*i.MACAddressHasSuffix))
	}
	if i.MACAddressEqualFold != nil {
		predicates = append(predicates, servernetworkport.MACAddressEqualFold(*i.MACAddressEqualFold))
	}
	if i.MACAddressContainsFold != nil {
		predicates = append(predicates, servernetworkport.MACAddressContainsFold(*i.MACAddressContainsFold))
	}

	if i.HasNetworkCard != nil {
		p := servernetworkport.HasNetworkCard()
		if !*i.HasNetworkCard {
			p = servernetworkport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkCardWith) > 0 {
		with := make([]predicate.ServerNetworkCard, 0, len(i.HasNetworkCardWith))
		for _, w := range i.HasNetworkCardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkCardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servernetworkport.HasNetworkCardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerNetworkPortWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servernetworkport.And(predicates...), nil
	}
}

// ServerPowerSupplyWhereInput represents a where input for filtering ServerPowerSupply queries.
type ServerPowerSupplyWhereInput struct {
	Predicates []predicate.ServerPowerSupply  `json:"-"`
	Not        *ServerPowerSupplyWhereInput   `json:"not,omitempty"`
	Or         []*ServerPowerSupplyWhereInput `json:"or,omitempty"`
	And        []*ServerPowerSupplyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "serial" field predicates.
	Serial             *string  `json:"serial,omitempty"`
	SerialNEQ          *string  `json:"serialNEQ,omitempty"`
	SerialIn           []string `json:"serialIn,omitempty"`
	SerialNotIn        []string `json:"serialNotIn,omitempty"`
	SerialGT           *string  `json:"serialGT,omitempty"`
	SerialGTE          *string  `json:"serialGTE,omitempty"`
	SerialLT           *string  `json:"serialLT,omitempty"`
	SerialLTE          *string  `json:"serialLTE,omitempty"`
	SerialContains     *string  `json:"serialContains,omitempty"`
	SerialHasPrefix    *string  `json:"serialHasPrefix,omitempty"`
	SerialHasSuffix    *string  `json:"serialHasSuffix,omitempty"`
	SerialEqualFold    *string  `json:"serialEqualFold,omitempty"`
	SerialContainsFold *string  `json:"serialContainsFold,omitempty"`

	// "server" edge predicates.
	HasServer     *bool               `json:"hasServer,omitempty"`
	HasServerWith []*ServerWhereInput `json:"hasServerWith,omitempty"`

	// "server_power_supply_type" edge predicates.
	HasServerPowerSupplyType     *bool                              `json:"hasServerPowerSupplyType,omitempty"`
	HasServerPowerSupplyTypeWith []*ServerPowerSupplyTypeWhereInput `json:"hasServerPowerSupplyTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerPowerSupplyWhereInput) AddPredicates(predicates ...predicate.ServerPowerSupply) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerPowerSupplyWhereInput filter on the ServerPowerSupplyQuery builder.
func (i *ServerPowerSupplyWhereInput) Filter(q *ServerPowerSupplyQuery) (*ServerPowerSupplyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerPowerSupplyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerPowerSupplyWhereInput is returned in case the ServerPowerSupplyWhereInput is empty.
var ErrEmptyServerPowerSupplyWhereInput = errors.New("generated: empty predicate ServerPowerSupplyWhereInput")

// P returns a predicate for filtering serverpowersupplies.
// An error is returned if the input is empty or invalid.
func (i *ServerPowerSupplyWhereInput) P() (predicate.ServerPowerSupply, error) {
	var predicates []predicate.ServerPowerSupply
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverpowersupply.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerPowerSupply, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverpowersupply.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerPowerSupply, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverpowersupply.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverpowersupply.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverpowersupply.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverpowersupply.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverpowersupply.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverpowersupply.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverpowersupply.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverpowersupply.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverpowersupply.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverpowersupply.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverpowersupply.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverpowersupply.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverpowersupply.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverpowersupply.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverpowersupply.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Serial != nil {
		predicates = append(predicates, serverpowersupply.SerialEQ(*i.Serial))
	}
	if i.SerialNEQ != nil {
		predicates = append(predicates, serverpowersupply.SerialNEQ(*i.SerialNEQ))
	}
	if len(i.SerialIn) > 0 {
		predicates = append(predicates, serverpowersupply.SerialIn(i.SerialIn...))
	}
	if len(i.SerialNotIn) > 0 {
		predicates = append(predicates, serverpowersupply.SerialNotIn(i.SerialNotIn...))
	}
	if i.SerialGT != nil {
		predicates = append(predicates, serverpowersupply.SerialGT(*i.SerialGT))
	}
	if i.SerialGTE != nil {
		predicates = append(predicates, serverpowersupply.SerialGTE(*i.SerialGTE))
	}
	if i.SerialLT != nil {
		predicates = append(predicates, serverpowersupply.SerialLT(*i.SerialLT))
	}
	if i.SerialLTE != nil {
		predicates = append(predicates, serverpowersupply.SerialLTE(*i.SerialLTE))
	}
	if i.SerialContains != nil {
		predicates = append(predicates, serverpowersupply.SerialContains(*i.SerialContains))
	}
	if i.SerialHasPrefix != nil {
		predicates = append(predicates, serverpowersupply.SerialHasPrefix(*i.SerialHasPrefix))
	}
	if i.SerialHasSuffix != nil {
		predicates = append(predicates, serverpowersupply.SerialHasSuffix(*i.SerialHasSuffix))
	}
	if i.SerialEqualFold != nil {
		predicates = append(predicates, serverpowersupply.SerialEqualFold(*i.SerialEqualFold))
	}
	if i.SerialContainsFold != nil {
		predicates = append(predicates, serverpowersupply.SerialContainsFold(*i.SerialContainsFold))
	}

	if i.HasServer != nil {
		p := serverpowersupply.HasServer()
		if !*i.HasServer {
			p = serverpowersupply.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServerWith))
		for _, w := range i.HasServerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverpowersupply.HasServerWith(with...))
	}
	if i.HasServerPowerSupplyType != nil {
		p := serverpowersupply.HasServerPowerSupplyType()
		if !*i.HasServerPowerSupplyType {
			p = serverpowersupply.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServerPowerSupplyTypeWith) > 0 {
		with := make([]predicate.ServerPowerSupplyType, 0, len(i.HasServerPowerSupplyTypeWith))
		for _, w := range i.HasServerPowerSupplyTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServerPowerSupplyTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serverpowersupply.HasServerPowerSupplyTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerPowerSupplyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverpowersupply.And(predicates...), nil
	}
}

// ServerPowerSupplyTypeWhereInput represents a where input for filtering ServerPowerSupplyType queries.
type ServerPowerSupplyTypeWhereInput struct {
	Predicates []predicate.ServerPowerSupplyType  `json:"-"`
	Not        *ServerPowerSupplyTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerPowerSupplyTypeWhereInput `json:"or,omitempty"`
	And        []*ServerPowerSupplyTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "watts" field predicates.
	Watts             *string  `json:"watts,omitempty"`
	WattsNEQ          *string  `json:"wattsNEQ,omitempty"`
	WattsIn           []string `json:"wattsIn,omitempty"`
	WattsNotIn        []string `json:"wattsNotIn,omitempty"`
	WattsGT           *string  `json:"wattsGT,omitempty"`
	WattsGTE          *string  `json:"wattsGTE,omitempty"`
	WattsLT           *string  `json:"wattsLT,omitempty"`
	WattsLTE          *string  `json:"wattsLTE,omitempty"`
	WattsContains     *string  `json:"wattsContains,omitempty"`
	WattsHasPrefix    *string  `json:"wattsHasPrefix,omitempty"`
	WattsHasSuffix    *string  `json:"wattsHasSuffix,omitempty"`
	WattsEqualFold    *string  `json:"wattsEqualFold,omitempty"`
	WattsContainsFold *string  `json:"wattsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerPowerSupplyTypeWhereInput) AddPredicates(predicates ...predicate.ServerPowerSupplyType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerPowerSupplyTypeWhereInput filter on the ServerPowerSupplyTypeQuery builder.
func (i *ServerPowerSupplyTypeWhereInput) Filter(q *ServerPowerSupplyTypeQuery) (*ServerPowerSupplyTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerPowerSupplyTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerPowerSupplyTypeWhereInput is returned in case the ServerPowerSupplyTypeWhereInput is empty.
var ErrEmptyServerPowerSupplyTypeWhereInput = errors.New("generated: empty predicate ServerPowerSupplyTypeWhereInput")

// P returns a predicate for filtering serverpowersupplytypes.
// An error is returned if the input is empty or invalid.
func (i *ServerPowerSupplyTypeWhereInput) P() (predicate.ServerPowerSupplyType, error) {
	var predicates []predicate.ServerPowerSupplyType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serverpowersupplytype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerPowerSupplyType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serverpowersupplytype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerPowerSupplyType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serverpowersupplytype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serverpowersupplytype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serverpowersupplytype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serverpowersupplytype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serverpowersupplytype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serverpowersupplytype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, serverpowersupplytype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, serverpowersupplytype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, serverpowersupplytype.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, serverpowersupplytype.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, serverpowersupplytype.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, serverpowersupplytype.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, serverpowersupplytype.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, serverpowersupplytype.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, serverpowersupplytype.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, serverpowersupplytype.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, serverpowersupplytype.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, serverpowersupplytype.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, serverpowersupplytype.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, serverpowersupplytype.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, serverpowersupplytype.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, serverpowersupplytype.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, serverpowersupplytype.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, serverpowersupplytype.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, serverpowersupplytype.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, serverpowersupplytype.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, serverpowersupplytype.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, serverpowersupplytype.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Watts != nil {
		predicates = append(predicates, serverpowersupplytype.WattsEQ(*i.Watts))
	}
	if i.WattsNEQ != nil {
		predicates = append(predicates, serverpowersupplytype.WattsNEQ(*i.WattsNEQ))
	}
	if len(i.WattsIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.WattsIn(i.WattsIn...))
	}
	if len(i.WattsNotIn) > 0 {
		predicates = append(predicates, serverpowersupplytype.WattsNotIn(i.WattsNotIn...))
	}
	if i.WattsGT != nil {
		predicates = append(predicates, serverpowersupplytype.WattsGT(*i.WattsGT))
	}
	if i.WattsGTE != nil {
		predicates = append(predicates, serverpowersupplytype.WattsGTE(*i.WattsGTE))
	}
	if i.WattsLT != nil {
		predicates = append(predicates, serverpowersupplytype.WattsLT(*i.WattsLT))
	}
	if i.WattsLTE != nil {
		predicates = append(predicates, serverpowersupplytype.WattsLTE(*i.WattsLTE))
	}
	if i.WattsContains != nil {
		predicates = append(predicates, serverpowersupplytype.WattsContains(*i.WattsContains))
	}
	if i.WattsHasPrefix != nil {
		predicates = append(predicates, serverpowersupplytype.WattsHasPrefix(*i.WattsHasPrefix))
	}
	if i.WattsHasSuffix != nil {
		predicates = append(predicates, serverpowersupplytype.WattsHasSuffix(*i.WattsHasSuffix))
	}
	if i.WattsEqualFold != nil {
		predicates = append(predicates, serverpowersupplytype.WattsEqualFold(*i.WattsEqualFold))
	}
	if i.WattsContainsFold != nil {
		predicates = append(predicates, serverpowersupplytype.WattsContainsFold(*i.WattsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerPowerSupplyTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serverpowersupplytype.And(predicates...), nil
	}
}

// ServerTypeWhereInput represents a where input for filtering ServerType queries.
type ServerTypeWhereInput struct {
	Predicates []predicate.ServerType  `json:"-"`
	Not        *ServerTypeWhereInput   `json:"not,omitempty"`
	Or         []*ServerTypeWhereInput `json:"or,omitempty"`
	And        []*ServerTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNEQ   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGT    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGTE   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLT    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLTE   *gidx.PrefixedID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "servers" edge predicates.
	HasServers     *bool               `json:"hasServers,omitempty"`
	HasServersWith []*ServerWhereInput `json:"hasServersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServerTypeWhereInput) AddPredicates(predicates ...predicate.ServerType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServerTypeWhereInput filter on the ServerTypeQuery builder.
func (i *ServerTypeWhereInput) Filter(q *ServerTypeQuery) (*ServerTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServerTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServerTypeWhereInput is returned in case the ServerTypeWhereInput is empty.
var ErrEmptyServerTypeWhereInput = errors.New("generated: empty predicate ServerTypeWhereInput")

// P returns a predicate for filtering servertypes.
// An error is returned if the input is empty or invalid.
func (i *ServerTypeWhereInput) P() (predicate.ServerType, error) {
	var predicates []predicate.ServerType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servertype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServerType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servertype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServerType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servertype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servertype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servertype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servertype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servertype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servertype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servertype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servertype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servertype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, servertype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, servertype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, servertype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, servertype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, servertype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, servertype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, servertype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, servertype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, servertype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, servertype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, servertype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, servertype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, servertype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, servertype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, servertype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, servertype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, servertype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, servertype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, servertype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, servertype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, servertype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, servertype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, servertype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, servertype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, servertype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, servertype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, servertype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, servertype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, servertype.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasServers != nil {
		p := servertype.HasServers()
		if !*i.HasServers {
			p = servertype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServersWith) > 0 {
		with := make([]predicate.Server, 0, len(i.HasServersWith))
		for _, w := range i.HasServersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servertype.HasServersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServerTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servertype.And(predicates...), nil
	}
}
