// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"go.infratographer.com/server-api/internal/ent/generated/predicate"
	"go.infratographer.com/server-api/internal/ent/generated/provider"
	"go.infratographer.com/server-api/internal/ent/generated/server"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassis"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassistype"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponent"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponenttype"
	"go.infratographer.com/server-api/internal/ent/generated/servercputype"
	"go.infratographer.com/server-api/internal/ent/generated/servertype"
	"go.infratographer.com/x/gidx"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeProvider            = "Provider"
	TypeServer              = "Server"
	TypeServerCPUType       = "ServerCPUType"
	TypeServerChassis       = "ServerChassis"
	TypeServerChassisType   = "ServerChassisType"
	TypeServerComponent     = "ServerComponent"
	TypeServerComponentType = "ServerComponentType"
	TypeServerType          = "ServerType"
)

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *gidx.PrefixedID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	resource_provider_id *gidx.PrefixedID
	clearedFields        map[string]struct{}
	servers              map[gidx.PrefixedID]struct{}
	removedservers       map[gidx.PrefixedID]struct{}
	clearedservers       bool
	done                 bool
	oldValue             func(context.Context) (*Provider, error)
	predicates           []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id gidx.PrefixedID) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provider entities.
func (m *ProviderMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderMutation) ResetName() {
	m.name = nil
}

// SetResourceProviderID sets the "resource_provider_id" field.
func (m *ProviderMutation) SetResourceProviderID(gi gidx.PrefixedID) {
	m.resource_provider_id = &gi
}

// ResourceProviderID returns the value of the "resource_provider_id" field in the mutation.
func (m *ProviderMutation) ResourceProviderID() (r gidx.PrefixedID, exists bool) {
	v := m.resource_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceProviderID returns the old "resource_provider_id" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldResourceProviderID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceProviderID: %w", err)
	}
	return oldValue.ResourceProviderID, nil
}

// ResetResourceProviderID resets all changes to the "resource_provider_id" field.
func (m *ProviderMutation) ResetResourceProviderID() {
	m.resource_provider_id = nil
}

// AddServerIDs adds the "servers" edge to the Server entity by ids.
func (m *ProviderMutation) AddServerIDs(ids ...gidx.PrefixedID) {
	if m.servers == nil {
		m.servers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the Server entity.
func (m *ProviderMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the Server entity was cleared.
func (m *ProviderMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the Server entity by IDs.
func (m *ProviderMutation) RemoveServerIDs(ids ...gidx.PrefixedID) {
	if m.removedservers == nil {
		m.removedservers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the Server entity.
func (m *ProviderMutation) RemovedServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *ProviderMutation) ServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *ProviderMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, provider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, provider.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, provider.FieldName)
	}
	if m.resource_provider_id != nil {
		fields = append(fields, provider.FieldResourceProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldCreatedAt:
		return m.CreatedAt()
	case provider.FieldUpdatedAt:
		return m.UpdatedAt()
	case provider.FieldName:
		return m.Name()
	case provider.FieldResourceProviderID:
		return m.ResourceProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case provider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case provider.FieldName:
		return m.OldName(ctx)
	case provider.FieldResourceProviderID:
		return m.OldResourceProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case provider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case provider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provider.FieldResourceProviderID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case provider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case provider.FieldName:
		m.ResetName()
		return nil
	case provider.FieldResourceProviderID:
		m.ResetResourceProviderID()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servers != nil {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservers != nil {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservers {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op                 Op
	typ                string
	id                 *gidx.PrefixedID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	owner_id           *gidx.PrefixedID
	location_id        *gidx.PrefixedID
	clearedFields      map[string]struct{}
	provider           *gidx.PrefixedID
	clearedprovider    bool
	server_type        *gidx.PrefixedID
	clearedserver_type bool
	components         map[gidx.PrefixedID]struct{}
	removedcomponents  map[gidx.PrefixedID]struct{}
	clearedcomponents  bool
	done               bool
	oldValue           func(context.Context) (*Server, error)
	predicates         []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id gidx.PrefixedID) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Server entities.
func (m *ServerMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[server.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[server.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, server.FieldDescription)
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerMutation) SetOwnerID(gi gidx.PrefixedID) {
	m.owner_id = &gi
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerMutation) OwnerID() (r gidx.PrefixedID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOwnerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetLocationID sets the "location_id" field.
func (m *ServerMutation) SetLocationID(gi gidx.PrefixedID) {
	m.location_id = &gi
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ServerMutation) LocationID() (r gidx.PrefixedID, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldLocationID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ServerMutation) ResetLocationID() {
	m.location_id = nil
}

// SetProviderID sets the "provider_id" field.
func (m *ServerMutation) SetProviderID(gi gidx.PrefixedID) {
	m.provider = &gi
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *ServerMutation) ProviderID() (r gidx.PrefixedID, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldProviderID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *ServerMutation) ResetProviderID() {
	m.provider = nil
}

// SetServerTypeID sets the "server_type_id" field.
func (m *ServerMutation) SetServerTypeID(gi gidx.PrefixedID) {
	m.server_type = &gi
}

// ServerTypeID returns the value of the "server_type_id" field in the mutation.
func (m *ServerMutation) ServerTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerTypeID returns the old "server_type_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldServerTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerTypeID: %w", err)
	}
	return oldValue.ServerTypeID, nil
}

// ResetServerTypeID resets all changes to the "server_type_id" field.
func (m *ServerMutation) ResetServerTypeID() {
	m.server_type = nil
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *ServerMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *ServerMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ProviderIDs() (ids []gidx.PrefixedID) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *ServerMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// ClearServerType clears the "server_type" edge to the ServerType entity.
func (m *ServerMutation) ClearServerType() {
	m.clearedserver_type = true
}

// ServerTypeCleared reports if the "server_type" edge to the ServerType entity was cleared.
func (m *ServerMutation) ServerTypeCleared() bool {
	return m.clearedserver_type
}

// ServerTypeIDs returns the "server_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ServerTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerType resets all changes to the "server_type" edge.
func (m *ServerMutation) ResetServerType() {
	m.server_type = nil
	m.clearedserver_type = false
}

// AddComponentIDs adds the "components" edge to the ServerComponent entity by ids.
func (m *ServerMutation) AddComponentIDs(ids ...gidx.PrefixedID) {
	if m.components == nil {
		m.components = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ServerComponent entity.
func (m *ServerMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ServerComponent entity was cleared.
func (m *ServerMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ServerComponent entity by IDs.
func (m *ServerMutation) RemoveComponentIDs(ids ...gidx.PrefixedID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ServerComponent entity.
func (m *ServerMutation) RemovedComponentsIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ServerMutation) ComponentsIDs() (ids []gidx.PrefixedID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ServerMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, server.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, server.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, server.FieldName)
	}
	if m.description != nil {
		fields = append(fields, server.FieldDescription)
	}
	if m.owner_id != nil {
		fields = append(fields, server.FieldOwnerID)
	}
	if m.location_id != nil {
		fields = append(fields, server.FieldLocationID)
	}
	if m.provider != nil {
		fields = append(fields, server.FieldProviderID)
	}
	if m.server_type != nil {
		fields = append(fields, server.FieldServerTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCreatedAt:
		return m.CreatedAt()
	case server.FieldUpdatedAt:
		return m.UpdatedAt()
	case server.FieldName:
		return m.Name()
	case server.FieldDescription:
		return m.Description()
	case server.FieldOwnerID:
		return m.OwnerID()
	case server.FieldLocationID:
		return m.LocationID()
	case server.FieldProviderID:
		return m.ProviderID()
	case server.FieldServerTypeID:
		return m.ServerTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case server.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case server.FieldName:
		return m.OldName(ctx)
	case server.FieldDescription:
		return m.OldDescription(ctx)
	case server.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case server.FieldLocationID:
		return m.OldLocationID(ctx)
	case server.FieldProviderID:
		return m.OldProviderID(ctx)
	case server.FieldServerTypeID:
		return m.OldServerTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case server.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case server.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case server.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case server.FieldOwnerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case server.FieldLocationID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case server.FieldProviderID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case server.FieldServerTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldDescription) {
		fields = append(fields, server.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case server.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case server.FieldName:
		m.ResetName()
		return nil
	case server.FieldDescription:
		m.ResetDescription()
		return nil
	case server.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case server.FieldLocationID:
		m.ResetLocationID()
		return nil
	case server.FieldProviderID:
		m.ResetProviderID()
		return nil
	case server.FieldServerTypeID:
		m.ResetServerTypeID()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.provider != nil {
		edges = append(edges, server.EdgeProvider)
	}
	if m.server_type != nil {
		edges = append(edges, server.EdgeServerType)
	}
	if m.components != nil {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeServerType:
		if id := m.server_type; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcomponents != nil {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprovider {
		edges = append(edges, server.EdgeProvider)
	}
	if m.clearedserver_type {
		edges = append(edges, server.EdgeServerType)
	}
	if m.clearedcomponents {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeProvider:
		return m.clearedprovider
	case server.EdgeServerType:
		return m.clearedserver_type
	case server.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	case server.EdgeProvider:
		m.ClearProvider()
		return nil
	case server.EdgeServerType:
		m.ClearServerType()
		return nil
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeProvider:
		m.ResetProvider()
		return nil
	case server.EdgeServerType:
		m.ResetServerType()
		return nil
	case server.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// ServerCPUTypeMutation represents an operation that mutates the ServerCPUType nodes in the graph.
type ServerCPUTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	vendor        *string
	model         *string
	clock_speed   *string
	core_count    *int
	addcore_count *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ServerCPUType, error)
	predicates    []predicate.ServerCPUType
}

var _ ent.Mutation = (*ServerCPUTypeMutation)(nil)

// servercputypeOption allows management of the mutation configuration using functional options.
type servercputypeOption func(*ServerCPUTypeMutation)

// newServerCPUTypeMutation creates new mutation for the ServerCPUType entity.
func newServerCPUTypeMutation(c config, op Op, opts ...servercputypeOption) *ServerCPUTypeMutation {
	m := &ServerCPUTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerCPUType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerCPUTypeID sets the ID field of the mutation.
func withServerCPUTypeID(id gidx.PrefixedID) servercputypeOption {
	return func(m *ServerCPUTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerCPUType
		)
		m.oldValue = func(ctx context.Context) (*ServerCPUType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerCPUType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerCPUType sets the old ServerCPUType of the mutation.
func withServerCPUType(node *ServerCPUType) servercputypeOption {
	return func(m *ServerCPUTypeMutation) {
		m.oldValue = func(context.Context) (*ServerCPUType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerCPUTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerCPUTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerCPUType entities.
func (m *ServerCPUTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerCPUTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerCPUTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerCPUType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerCPUTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerCPUTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerCPUTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerCPUTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerCPUTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerCPUTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerCPUTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerCPUTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerCPUTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerCPUTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerCPUTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerCPUTypeMutation) ResetModel() {
	m.model = nil
}

// SetClockSpeed sets the "clock_speed" field.
func (m *ServerCPUTypeMutation) SetClockSpeed(s string) {
	m.clock_speed = &s
}

// ClockSpeed returns the value of the "clock_speed" field in the mutation.
func (m *ServerCPUTypeMutation) ClockSpeed() (r string, exists bool) {
	v := m.clock_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldClockSpeed returns the old "clock_speed" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldClockSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockSpeed: %w", err)
	}
	return oldValue.ClockSpeed, nil
}

// ResetClockSpeed resets all changes to the "clock_speed" field.
func (m *ServerCPUTypeMutation) ResetClockSpeed() {
	m.clock_speed = nil
}

// SetCoreCount sets the "core_count" field.
func (m *ServerCPUTypeMutation) SetCoreCount(i int) {
	m.core_count = &i
	m.addcore_count = nil
}

// CoreCount returns the value of the "core_count" field in the mutation.
func (m *ServerCPUTypeMutation) CoreCount() (r int, exists bool) {
	v := m.core_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCoreCount returns the old "core_count" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldCoreCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoreCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoreCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoreCount: %w", err)
	}
	return oldValue.CoreCount, nil
}

// AddCoreCount adds i to the "core_count" field.
func (m *ServerCPUTypeMutation) AddCoreCount(i int) {
	if m.addcore_count != nil {
		*m.addcore_count += i
	} else {
		m.addcore_count = &i
	}
}

// AddedCoreCount returns the value that was added to the "core_count" field in this mutation.
func (m *ServerCPUTypeMutation) AddedCoreCount() (r int, exists bool) {
	v := m.addcore_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoreCount resets all changes to the "core_count" field.
func (m *ServerCPUTypeMutation) ResetCoreCount() {
	m.core_count = nil
	m.addcore_count = nil
}

// Where appends a list predicates to the ServerCPUTypeMutation builder.
func (m *ServerCPUTypeMutation) Where(ps ...predicate.ServerCPUType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerCPUTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerCPUTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerCPUType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerCPUTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerCPUTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerCPUType).
func (m *ServerCPUTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerCPUTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, servercputype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercputype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, servercputype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servercputype.FieldModel)
	}
	if m.clock_speed != nil {
		fields = append(fields, servercputype.FieldClockSpeed)
	}
	if m.core_count != nil {
		fields = append(fields, servercputype.FieldCoreCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerCPUTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercputype.FieldCreatedAt:
		return m.CreatedAt()
	case servercputype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercputype.FieldVendor:
		return m.Vendor()
	case servercputype.FieldModel:
		return m.Model()
	case servercputype.FieldClockSpeed:
		return m.ClockSpeed()
	case servercputype.FieldCoreCount:
		return m.CoreCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerCPUTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercputype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercputype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercputype.FieldVendor:
		return m.OldVendor(ctx)
	case servercputype.FieldModel:
		return m.OldModel(ctx)
	case servercputype.FieldClockSpeed:
		return m.OldClockSpeed(ctx)
	case servercputype.FieldCoreCount:
		return m.OldCoreCount(ctx)
	}
	return nil, fmt.Errorf("unknown ServerCPUType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercputype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercputype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercputype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servercputype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servercputype.FieldClockSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockSpeed(v)
		return nil
	case servercputype.FieldCoreCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerCPUTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcore_count != nil {
		fields = append(fields, servercputype.FieldCoreCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerCPUTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servercputype.FieldCoreCount:
		return m.AddedCoreCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servercputype.FieldCoreCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerCPUTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerCPUTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerCPUTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerCPUType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerCPUTypeMutation) ResetField(name string) error {
	switch name {
	case servercputype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercputype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercputype.FieldVendor:
		m.ResetVendor()
		return nil
	case servercputype.FieldModel:
		m.ResetModel()
		return nil
	case servercputype.FieldClockSpeed:
		m.ResetClockSpeed()
		return nil
	case servercputype.FieldCoreCount:
		m.ResetCoreCount()
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerCPUTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerCPUTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerCPUTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerCPUTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerCPUTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerCPUTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerCPUTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServerCPUType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerCPUTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServerCPUType edge %s", name)
}

// ServerChassisMutation represents an operation that mutates the ServerChassis nodes in the graph.
type ServerChassisMutation struct {
	config
	op                         Op
	typ                        string
	id                         *gidx.PrefixedID
	created_at                 *time.Time
	updated_at                 *time.Time
	parent_chassis_id          *gidx.PrefixedID
	serial                     *string
	clearedFields              map[string]struct{}
	server                     *gidx.PrefixedID
	clearedserver              bool
	server_chassis_type        *gidx.PrefixedID
	clearedserver_chassis_type bool
	done                       bool
	oldValue                   func(context.Context) (*ServerChassis, error)
	predicates                 []predicate.ServerChassis
}

var _ ent.Mutation = (*ServerChassisMutation)(nil)

// serverchassisOption allows management of the mutation configuration using functional options.
type serverchassisOption func(*ServerChassisMutation)

// newServerChassisMutation creates new mutation for the ServerChassis entity.
func newServerChassisMutation(c config, op Op, opts ...serverchassisOption) *ServerChassisMutation {
	m := &ServerChassisMutation{
		config:        c,
		op:            op,
		typ:           TypeServerChassis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerChassisID sets the ID field of the mutation.
func withServerChassisID(id gidx.PrefixedID) serverchassisOption {
	return func(m *ServerChassisMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerChassis
		)
		m.oldValue = func(ctx context.Context) (*ServerChassis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerChassis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerChassis sets the old ServerChassis of the mutation.
func withServerChassis(node *ServerChassis) serverchassisOption {
	return func(m *ServerChassisMutation) {
		m.oldValue = func(context.Context) (*ServerChassis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerChassisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerChassisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerChassis entities.
func (m *ServerChassisMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerChassisMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerChassisMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerChassis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerChassisMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerChassisMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerChassisMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerChassisMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerChassisMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerChassisMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServerChassisTypeID sets the "server_chassis_type_id" field.
func (m *ServerChassisMutation) SetServerChassisTypeID(gi gidx.PrefixedID) {
	m.server_chassis_type = &gi
}

// ServerChassisTypeID returns the value of the "server_chassis_type_id" field in the mutation.
func (m *ServerChassisMutation) ServerChassisTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_chassis_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerChassisTypeID returns the old "server_chassis_type_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldServerChassisTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerChassisTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerChassisTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerChassisTypeID: %w", err)
	}
	return oldValue.ServerChassisTypeID, nil
}

// ResetServerChassisTypeID resets all changes to the "server_chassis_type_id" field.
func (m *ServerChassisMutation) ResetServerChassisTypeID() {
	m.server_chassis_type = nil
}

// SetParentChassisID sets the "parent_chassis_id" field.
func (m *ServerChassisMutation) SetParentChassisID(gi gidx.PrefixedID) {
	m.parent_chassis_id = &gi
}

// ParentChassisID returns the value of the "parent_chassis_id" field in the mutation.
func (m *ServerChassisMutation) ParentChassisID() (r gidx.PrefixedID, exists bool) {
	v := m.parent_chassis_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentChassisID returns the old "parent_chassis_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldParentChassisID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentChassisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentChassisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentChassisID: %w", err)
	}
	return oldValue.ParentChassisID, nil
}

// ResetParentChassisID resets all changes to the "parent_chassis_id" field.
func (m *ServerChassisMutation) ResetParentChassisID() {
	m.parent_chassis_id = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerChassisMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerChassisMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerChassisMutation) ResetServerID() {
	m.server = nil
}

// SetSerial sets the "serial" field.
func (m *ServerChassisMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerChassisMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerChassisMutation) ResetSerial() {
	m.serial = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerChassisMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerChassisMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerChassisMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerChassisMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerChassisType clears the "server_chassis_type" edge to the ServerChassisType entity.
func (m *ServerChassisMutation) ClearServerChassisType() {
	m.clearedserver_chassis_type = true
}

// ServerChassisTypeCleared reports if the "server_chassis_type" edge to the ServerChassisType entity was cleared.
func (m *ServerChassisMutation) ServerChassisTypeCleared() bool {
	return m.clearedserver_chassis_type
}

// ServerChassisTypeIDs returns the "server_chassis_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerChassisTypeID instead. It exists only for internal usage by the builders.
func (m *ServerChassisMutation) ServerChassisTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_chassis_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerChassisType resets all changes to the "server_chassis_type" edge.
func (m *ServerChassisMutation) ResetServerChassisType() {
	m.server_chassis_type = nil
	m.clearedserver_chassis_type = false
}

// Where appends a list predicates to the ServerChassisMutation builder.
func (m *ServerChassisMutation) Where(ps ...predicate.ServerChassis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerChassisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerChassisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerChassis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerChassisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerChassisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerChassis).
func (m *ServerChassisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerChassisMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, serverchassis.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverchassis.FieldUpdatedAt)
	}
	if m.server_chassis_type != nil {
		fields = append(fields, serverchassis.FieldServerChassisTypeID)
	}
	if m.parent_chassis_id != nil {
		fields = append(fields, serverchassis.FieldParentChassisID)
	}
	if m.server != nil {
		fields = append(fields, serverchassis.FieldServerID)
	}
	if m.serial != nil {
		fields = append(fields, serverchassis.FieldSerial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerChassisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverchassis.FieldCreatedAt:
		return m.CreatedAt()
	case serverchassis.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverchassis.FieldServerChassisTypeID:
		return m.ServerChassisTypeID()
	case serverchassis.FieldParentChassisID:
		return m.ParentChassisID()
	case serverchassis.FieldServerID:
		return m.ServerID()
	case serverchassis.FieldSerial:
		return m.Serial()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerChassisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverchassis.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverchassis.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverchassis.FieldServerChassisTypeID:
		return m.OldServerChassisTypeID(ctx)
	case serverchassis.FieldParentChassisID:
		return m.OldParentChassisID(ctx)
	case serverchassis.FieldServerID:
		return m.OldServerID(ctx)
	case serverchassis.FieldSerial:
		return m.OldSerial(ctx)
	}
	return nil, fmt.Errorf("unknown ServerChassis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverchassis.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverchassis.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverchassis.FieldServerChassisTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerChassisTypeID(v)
		return nil
	case serverchassis.FieldParentChassisID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentChassisID(v)
		return nil
	case serverchassis.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case serverchassis.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	}
	return fmt.Errorf("unknown ServerChassis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerChassisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerChassisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerChassisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerChassisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerChassisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerChassis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerChassisMutation) ResetField(name string) error {
	switch name {
	case serverchassis.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverchassis.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverchassis.FieldServerChassisTypeID:
		m.ResetServerChassisTypeID()
		return nil
	case serverchassis.FieldParentChassisID:
		m.ResetParentChassisID()
		return nil
	case serverchassis.FieldServerID:
		m.ResetServerID()
		return nil
	case serverchassis.FieldSerial:
		m.ResetSerial()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerChassisMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, serverchassis.EdgeServer)
	}
	if m.server_chassis_type != nil {
		edges = append(edges, serverchassis.EdgeServerChassisType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerChassisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverchassis.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case serverchassis.EdgeServerChassisType:
		if id := m.server_chassis_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerChassisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerChassisMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerChassisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, serverchassis.EdgeServer)
	}
	if m.clearedserver_chassis_type {
		edges = append(edges, serverchassis.EdgeServerChassisType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerChassisMutation) EdgeCleared(name string) bool {
	switch name {
	case serverchassis.EdgeServer:
		return m.clearedserver
	case serverchassis.EdgeServerChassisType:
		return m.clearedserver_chassis_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerChassisMutation) ClearEdge(name string) error {
	switch name {
	case serverchassis.EdgeServer:
		m.ClearServer()
		return nil
	case serverchassis.EdgeServerChassisType:
		m.ClearServerChassisType()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerChassisMutation) ResetEdge(name string) error {
	switch name {
	case serverchassis.EdgeServer:
		m.ResetServer()
		return nil
	case serverchassis.EdgeServerChassisType:
		m.ResetServerChassisType()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis edge %s", name)
}

// ServerChassisTypeMutation represents an operation that mutates the ServerChassisType nodes in the graph.
type ServerChassisTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *gidx.PrefixedID
	created_at             *time.Time
	updated_at             *time.Time
	vendor                 *string
	model                  *string
	height                 *string
	is_full_depth          *bool
	parent_chassis_type_id *gidx.PrefixedID
	clearedFields          map[string]struct{}
	chassis                map[gidx.PrefixedID]struct{}
	removedchassis         map[gidx.PrefixedID]struct{}
	clearedchassis         bool
	done                   bool
	oldValue               func(context.Context) (*ServerChassisType, error)
	predicates             []predicate.ServerChassisType
}

var _ ent.Mutation = (*ServerChassisTypeMutation)(nil)

// serverchassistypeOption allows management of the mutation configuration using functional options.
type serverchassistypeOption func(*ServerChassisTypeMutation)

// newServerChassisTypeMutation creates new mutation for the ServerChassisType entity.
func newServerChassisTypeMutation(c config, op Op, opts ...serverchassistypeOption) *ServerChassisTypeMutation {
	m := &ServerChassisTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerChassisType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerChassisTypeID sets the ID field of the mutation.
func withServerChassisTypeID(id gidx.PrefixedID) serverchassistypeOption {
	return func(m *ServerChassisTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerChassisType
		)
		m.oldValue = func(ctx context.Context) (*ServerChassisType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerChassisType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerChassisType sets the old ServerChassisType of the mutation.
func withServerChassisType(node *ServerChassisType) serverchassistypeOption {
	return func(m *ServerChassisTypeMutation) {
		m.oldValue = func(context.Context) (*ServerChassisType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerChassisTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerChassisTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerChassisType entities.
func (m *ServerChassisTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerChassisTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerChassisTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerChassisType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerChassisTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerChassisTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerChassisTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerChassisTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerChassisTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerChassisTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerChassisTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerChassisTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerChassisTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerChassisTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerChassisTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerChassisTypeMutation) ResetModel() {
	m.model = nil
}

// SetHeight sets the "height" field.
func (m *ServerChassisTypeMutation) SetHeight(s string) {
	m.height = &s
}

// Height returns the value of the "height" field in the mutation.
func (m *ServerChassisTypeMutation) Height() (r string, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// ResetHeight resets all changes to the "height" field.
func (m *ServerChassisTypeMutation) ResetHeight() {
	m.height = nil
}

// SetIsFullDepth sets the "is_full_depth" field.
func (m *ServerChassisTypeMutation) SetIsFullDepth(b bool) {
	m.is_full_depth = &b
}

// IsFullDepth returns the value of the "is_full_depth" field in the mutation.
func (m *ServerChassisTypeMutation) IsFullDepth() (r bool, exists bool) {
	v := m.is_full_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFullDepth returns the old "is_full_depth" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldIsFullDepth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFullDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFullDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFullDepth: %w", err)
	}
	return oldValue.IsFullDepth, nil
}

// ResetIsFullDepth resets all changes to the "is_full_depth" field.
func (m *ServerChassisTypeMutation) ResetIsFullDepth() {
	m.is_full_depth = nil
}

// SetParentChassisTypeID sets the "parent_chassis_type_id" field.
func (m *ServerChassisTypeMutation) SetParentChassisTypeID(gi gidx.PrefixedID) {
	m.parent_chassis_type_id = &gi
}

// ParentChassisTypeID returns the value of the "parent_chassis_type_id" field in the mutation.
func (m *ServerChassisTypeMutation) ParentChassisTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.parent_chassis_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentChassisTypeID returns the old "parent_chassis_type_id" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldParentChassisTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentChassisTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentChassisTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentChassisTypeID: %w", err)
	}
	return oldValue.ParentChassisTypeID, nil
}

// ResetParentChassisTypeID resets all changes to the "parent_chassis_type_id" field.
func (m *ServerChassisTypeMutation) ResetParentChassisTypeID() {
	m.parent_chassis_type_id = nil
}

// AddChassiIDs adds the "chassis" edge to the ServerChassis entity by ids.
func (m *ServerChassisTypeMutation) AddChassiIDs(ids ...gidx.PrefixedID) {
	if m.chassis == nil {
		m.chassis = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.chassis[ids[i]] = struct{}{}
	}
}

// ClearChassis clears the "chassis" edge to the ServerChassis entity.
func (m *ServerChassisTypeMutation) ClearChassis() {
	m.clearedchassis = true
}

// ChassisCleared reports if the "chassis" edge to the ServerChassis entity was cleared.
func (m *ServerChassisTypeMutation) ChassisCleared() bool {
	return m.clearedchassis
}

// RemoveChassiIDs removes the "chassis" edge to the ServerChassis entity by IDs.
func (m *ServerChassisTypeMutation) RemoveChassiIDs(ids ...gidx.PrefixedID) {
	if m.removedchassis == nil {
		m.removedchassis = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.chassis, ids[i])
		m.removedchassis[ids[i]] = struct{}{}
	}
}

// RemovedChassis returns the removed IDs of the "chassis" edge to the ServerChassis entity.
func (m *ServerChassisTypeMutation) RemovedChassisIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedchassis {
		ids = append(ids, id)
	}
	return
}

// ChassisIDs returns the "chassis" edge IDs in the mutation.
func (m *ServerChassisTypeMutation) ChassisIDs() (ids []gidx.PrefixedID) {
	for id := range m.chassis {
		ids = append(ids, id)
	}
	return
}

// ResetChassis resets all changes to the "chassis" edge.
func (m *ServerChassisTypeMutation) ResetChassis() {
	m.chassis = nil
	m.clearedchassis = false
	m.removedchassis = nil
}

// Where appends a list predicates to the ServerChassisTypeMutation builder.
func (m *ServerChassisTypeMutation) Where(ps ...predicate.ServerChassisType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerChassisTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerChassisTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerChassisType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerChassisTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerChassisTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerChassisType).
func (m *ServerChassisTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerChassisTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, serverchassistype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverchassistype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, serverchassistype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, serverchassistype.FieldModel)
	}
	if m.height != nil {
		fields = append(fields, serverchassistype.FieldHeight)
	}
	if m.is_full_depth != nil {
		fields = append(fields, serverchassistype.FieldIsFullDepth)
	}
	if m.parent_chassis_type_id != nil {
		fields = append(fields, serverchassistype.FieldParentChassisTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerChassisTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverchassistype.FieldCreatedAt:
		return m.CreatedAt()
	case serverchassistype.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverchassistype.FieldVendor:
		return m.Vendor()
	case serverchassistype.FieldModel:
		return m.Model()
	case serverchassistype.FieldHeight:
		return m.Height()
	case serverchassistype.FieldIsFullDepth:
		return m.IsFullDepth()
	case serverchassistype.FieldParentChassisTypeID:
		return m.ParentChassisTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerChassisTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverchassistype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverchassistype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverchassistype.FieldVendor:
		return m.OldVendor(ctx)
	case serverchassistype.FieldModel:
		return m.OldModel(ctx)
	case serverchassistype.FieldHeight:
		return m.OldHeight(ctx)
	case serverchassistype.FieldIsFullDepth:
		return m.OldIsFullDepth(ctx)
	case serverchassistype.FieldParentChassisTypeID:
		return m.OldParentChassisTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerChassisType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverchassistype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverchassistype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverchassistype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case serverchassistype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case serverchassistype.FieldHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case serverchassistype.FieldIsFullDepth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFullDepth(v)
		return nil
	case serverchassistype.FieldParentChassisTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentChassisTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerChassisTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerChassisTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassisType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerChassisTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerChassisTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerChassisTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerChassisType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerChassisTypeMutation) ResetField(name string) error {
	switch name {
	case serverchassistype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverchassistype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverchassistype.FieldVendor:
		m.ResetVendor()
		return nil
	case serverchassistype.FieldModel:
		m.ResetModel()
		return nil
	case serverchassistype.FieldHeight:
		m.ResetHeight()
		return nil
	case serverchassistype.FieldIsFullDepth:
		m.ResetIsFullDepth()
		return nil
	case serverchassistype.FieldParentChassisTypeID:
		m.ResetParentChassisTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerChassisTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chassis != nil {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerChassisTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverchassistype.EdgeChassis:
		ids := make([]ent.Value, 0, len(m.chassis))
		for id := range m.chassis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerChassisTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchassis != nil {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerChassisTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serverchassistype.EdgeChassis:
		ids := make([]ent.Value, 0, len(m.removedchassis))
		for id := range m.removedchassis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerChassisTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchassis {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerChassisTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case serverchassistype.EdgeChassis:
		return m.clearedchassis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerChassisTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassisType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerChassisTypeMutation) ResetEdge(name string) error {
	switch name {
	case serverchassistype.EdgeChassis:
		m.ResetChassis()
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType edge %s", name)
}

// ServerComponentMutation represents an operation that mutates the ServerComponent nodes in the graph.
type ServerComponentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *gidx.PrefixedID
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	vendor                *string
	model                 *string
	serial                *string
	clearedFields         map[string]struct{}
	component_type        *gidx.PrefixedID
	clearedcomponent_type bool
	server                *gidx.PrefixedID
	clearedserver         bool
	done                  bool
	oldValue              func(context.Context) (*ServerComponent, error)
	predicates            []predicate.ServerComponent
}

var _ ent.Mutation = (*ServerComponentMutation)(nil)

// servercomponentOption allows management of the mutation configuration using functional options.
type servercomponentOption func(*ServerComponentMutation)

// newServerComponentMutation creates new mutation for the ServerComponent entity.
func newServerComponentMutation(c config, op Op, opts ...servercomponentOption) *ServerComponentMutation {
	m := &ServerComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeServerComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerComponentID sets the ID field of the mutation.
func withServerComponentID(id gidx.PrefixedID) servercomponentOption {
	return func(m *ServerComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerComponent
		)
		m.oldValue = func(ctx context.Context) (*ServerComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerComponent sets the old ServerComponent of the mutation.
func withServerComponent(node *ServerComponent) servercomponentOption {
	return func(m *ServerComponentMutation) {
		m.oldValue = func(context.Context) (*ServerComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerComponent entities.
func (m *ServerComponentMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerComponentMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerComponentMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerComponentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerComponentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerComponentMutation) ResetName() {
	m.name = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerComponentMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerComponentMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerComponentMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerComponentMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerComponentMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerComponentMutation) ResetModel() {
	m.model = nil
}

// SetSerial sets the "serial" field.
func (m *ServerComponentMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerComponentMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerComponentMutation) ResetSerial() {
	m.serial = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerComponentMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerComponentMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerComponentMutation) ResetServerID() {
	m.server = nil
}

// SetComponentTypeID sets the "component_type_id" field.
func (m *ServerComponentMutation) SetComponentTypeID(gi gidx.PrefixedID) {
	m.component_type = &gi
}

// ComponentTypeID returns the value of the "component_type_id" field in the mutation.
func (m *ServerComponentMutation) ComponentTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.component_type
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentTypeID returns the old "component_type_id" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldComponentTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentTypeID: %w", err)
	}
	return oldValue.ComponentTypeID, nil
}

// ResetComponentTypeID resets all changes to the "component_type_id" field.
func (m *ServerComponentMutation) ResetComponentTypeID() {
	m.component_type = nil
}

// ClearComponentType clears the "component_type" edge to the ServerComponentType entity.
func (m *ServerComponentMutation) ClearComponentType() {
	m.clearedcomponent_type = true
}

// ComponentTypeCleared reports if the "component_type" edge to the ServerComponentType entity was cleared.
func (m *ServerComponentMutation) ComponentTypeCleared() bool {
	return m.clearedcomponent_type
}

// ComponentTypeIDs returns the "component_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentTypeID instead. It exists only for internal usage by the builders.
func (m *ServerComponentMutation) ComponentTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.component_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponentType resets all changes to the "component_type" edge.
func (m *ServerComponentMutation) ResetComponentType() {
	m.component_type = nil
	m.clearedcomponent_type = false
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerComponentMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerComponentMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerComponentMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerComponentMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// Where appends a list predicates to the ServerComponentMutation builder.
func (m *ServerComponentMutation) Where(ps ...predicate.ServerComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerComponent).
func (m *ServerComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerComponentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, servercomponent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercomponent.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servercomponent.FieldName)
	}
	if m.vendor != nil {
		fields = append(fields, servercomponent.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servercomponent.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, servercomponent.FieldSerial)
	}
	if m.server != nil {
		fields = append(fields, servercomponent.FieldServerID)
	}
	if m.component_type != nil {
		fields = append(fields, servercomponent.FieldComponentTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercomponent.FieldCreatedAt:
		return m.CreatedAt()
	case servercomponent.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercomponent.FieldName:
		return m.Name()
	case servercomponent.FieldVendor:
		return m.Vendor()
	case servercomponent.FieldModel:
		return m.Model()
	case servercomponent.FieldSerial:
		return m.Serial()
	case servercomponent.FieldServerID:
		return m.ServerID()
	case servercomponent.FieldComponentTypeID:
		return m.ComponentTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercomponent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercomponent.FieldName:
		return m.OldName(ctx)
	case servercomponent.FieldVendor:
		return m.OldVendor(ctx)
	case servercomponent.FieldModel:
		return m.OldModel(ctx)
	case servercomponent.FieldSerial:
		return m.OldSerial(ctx)
	case servercomponent.FieldServerID:
		return m.OldServerID(ctx)
	case servercomponent.FieldComponentTypeID:
		return m.OldComponentTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercomponent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servercomponent.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servercomponent.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servercomponent.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case servercomponent.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case servercomponent.FieldComponentTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerComponentMutation) ResetField(name string) error {
	switch name {
	case servercomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercomponent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercomponent.FieldName:
		m.ResetName()
		return nil
	case servercomponent.FieldVendor:
		m.ResetVendor()
		return nil
	case servercomponent.FieldModel:
		m.ResetModel()
		return nil
	case servercomponent.FieldSerial:
		m.ResetSerial()
		return nil
	case servercomponent.FieldServerID:
		m.ResetServerID()
		return nil
	case servercomponent.FieldComponentTypeID:
		m.ResetComponentTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.component_type != nil {
		edges = append(edges, servercomponent.EdgeComponentType)
	}
	if m.server != nil {
		edges = append(edges, servercomponent.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servercomponent.EdgeComponentType:
		if id := m.component_type; id != nil {
			return []ent.Value{*id}
		}
	case servercomponent.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomponent_type {
		edges = append(edges, servercomponent.EdgeComponentType)
	}
	if m.clearedserver {
		edges = append(edges, servercomponent.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case servercomponent.EdgeComponentType:
		return m.clearedcomponent_type
	case servercomponent.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerComponentMutation) ClearEdge(name string) error {
	switch name {
	case servercomponent.EdgeComponentType:
		m.ClearComponentType()
		return nil
	case servercomponent.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerComponentMutation) ResetEdge(name string) error {
	switch name {
	case servercomponent.EdgeComponentType:
		m.ResetComponentType()
		return nil
	case servercomponent.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent edge %s", name)
}

// ServerComponentTypeMutation represents an operation that mutates the ServerComponentType nodes in the graph.
type ServerComponentTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ServerComponentType, error)
	predicates    []predicate.ServerComponentType
}

var _ ent.Mutation = (*ServerComponentTypeMutation)(nil)

// servercomponenttypeOption allows management of the mutation configuration using functional options.
type servercomponenttypeOption func(*ServerComponentTypeMutation)

// newServerComponentTypeMutation creates new mutation for the ServerComponentType entity.
func newServerComponentTypeMutation(c config, op Op, opts ...servercomponenttypeOption) *ServerComponentTypeMutation {
	m := &ServerComponentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerComponentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerComponentTypeID sets the ID field of the mutation.
func withServerComponentTypeID(id gidx.PrefixedID) servercomponenttypeOption {
	return func(m *ServerComponentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerComponentType
		)
		m.oldValue = func(ctx context.Context) (*ServerComponentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerComponentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerComponentType sets the old ServerComponentType of the mutation.
func withServerComponentType(node *ServerComponentType) servercomponenttypeOption {
	return func(m *ServerComponentTypeMutation) {
		m.oldValue = func(context.Context) (*ServerComponentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerComponentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerComponentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerComponentType entities.
func (m *ServerComponentTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerComponentTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerComponentTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerComponentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerComponentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerComponentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerComponentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerComponentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerComponentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerComponentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerComponentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerComponentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerComponentTypeMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the ServerComponentTypeMutation builder.
func (m *ServerComponentTypeMutation) Where(ps ...predicate.ServerComponentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerComponentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerComponentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerComponentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerComponentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerComponentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerComponentType).
func (m *ServerComponentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerComponentTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, servercomponenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercomponenttype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servercomponenttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerComponentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		return m.CreatedAt()
	case servercomponenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercomponenttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerComponentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercomponenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercomponenttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ServerComponentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercomponenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercomponenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ServerComponentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerComponentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerComponentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerComponentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerComponentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerComponentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerComponentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerComponentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerComponentTypeMutation) ResetField(name string) error {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercomponenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercomponenttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ServerComponentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerComponentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerComponentTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerComponentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerComponentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerComponentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerComponentTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerComponentTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServerComponentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerComponentTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServerComponentType edge %s", name)
}

// ServerTypeMutation represents an operation that mutates the ServerType nodes in the graph.
type ServerTypeMutation struct {
	config
	op             Op
	typ            string
	id             *gidx.PrefixedID
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	owner_id       *gidx.PrefixedID
	clearedFields  map[string]struct{}
	servers        map[gidx.PrefixedID]struct{}
	removedservers map[gidx.PrefixedID]struct{}
	clearedservers bool
	done           bool
	oldValue       func(context.Context) (*ServerType, error)
	predicates     []predicate.ServerType
}

var _ ent.Mutation = (*ServerTypeMutation)(nil)

// servertypeOption allows management of the mutation configuration using functional options.
type servertypeOption func(*ServerTypeMutation)

// newServerTypeMutation creates new mutation for the ServerType entity.
func newServerTypeMutation(c config, op Op, opts ...servertypeOption) *ServerTypeMutation {
	m := &ServerTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerTypeID sets the ID field of the mutation.
func withServerTypeID(id gidx.PrefixedID) servertypeOption {
	return func(m *ServerTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerType
		)
		m.oldValue = func(ctx context.Context) (*ServerType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerType sets the old ServerType of the mutation.
func withServerType(node *ServerType) servertypeOption {
	return func(m *ServerTypeMutation) {
		m.oldValue = func(context.Context) (*ServerType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerType entities.
func (m *ServerTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerTypeMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerTypeMutation) SetOwnerID(gi gidx.PrefixedID) {
	m.owner_id = &gi
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerTypeMutation) OwnerID() (r gidx.PrefixedID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldOwnerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerTypeMutation) ResetOwnerID() {
	m.owner_id = nil
}

// AddServerIDs adds the "servers" edge to the Server entity by ids.
func (m *ServerTypeMutation) AddServerIDs(ids ...gidx.PrefixedID) {
	if m.servers == nil {
		m.servers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the Server entity.
func (m *ServerTypeMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the Server entity was cleared.
func (m *ServerTypeMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the Server entity by IDs.
func (m *ServerTypeMutation) RemoveServerIDs(ids ...gidx.PrefixedID) {
	if m.removedservers == nil {
		m.removedservers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the Server entity.
func (m *ServerTypeMutation) RemovedServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *ServerTypeMutation) ServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *ServerTypeMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Where appends a list predicates to the ServerTypeMutation builder.
func (m *ServerTypeMutation) Where(ps ...predicate.ServerType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerType).
func (m *ServerTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, servertype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servertype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servertype.FieldName)
	}
	if m.owner_id != nil {
		fields = append(fields, servertype.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servertype.FieldCreatedAt:
		return m.CreatedAt()
	case servertype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servertype.FieldName:
		return m.Name()
	case servertype.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servertype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servertype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servertype.FieldName:
		return m.OldName(ctx)
	case servertype.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servertype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servertype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servertype.FieldOwnerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerTypeMutation) ResetField(name string) error {
	switch name {
	case servertype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servertype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servertype.FieldName:
		m.ResetName()
		return nil
	case servertype.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservers {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servertype.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerTypeMutation) ResetEdge(name string) error {
	switch name {
	case servertype.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown ServerType edge %s", name)
}
