// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"go.infratographer.com/server-api/internal/ent/generated/predicate"
	"go.infratographer.com/server-api/internal/ent/generated/provider"
	"go.infratographer.com/server-api/internal/ent/generated/server"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassis"
	"go.infratographer.com/server-api/internal/ent/generated/serverchassistype"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponent"
	"go.infratographer.com/server-api/internal/ent/generated/servercomponenttype"
	"go.infratographer.com/server-api/internal/ent/generated/servercpu"
	"go.infratographer.com/server-api/internal/ent/generated/servercputype"
	"go.infratographer.com/server-api/internal/ent/generated/serverharddrive"
	"go.infratographer.com/server-api/internal/ent/generated/serverharddrivetype"
	"go.infratographer.com/server-api/internal/ent/generated/servermemory"
	"go.infratographer.com/server-api/internal/ent/generated/servermemorytype"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboard"
	"go.infratographer.com/server-api/internal/ent/generated/servermotherboardtype"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkcard"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkcardtype"
	"go.infratographer.com/server-api/internal/ent/generated/servernetworkport"
	"go.infratographer.com/server-api/internal/ent/generated/serverpowersupply"
	"go.infratographer.com/server-api/internal/ent/generated/serverpowersupplytype"
	"go.infratographer.com/server-api/internal/ent/generated/servertype"
	"go.infratographer.com/x/gidx"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeProvider              = "Provider"
	TypeServer                = "Server"
	TypeServerCPU             = "ServerCPU"
	TypeServerCPUType         = "ServerCPUType"
	TypeServerChassis         = "ServerChassis"
	TypeServerChassisType     = "ServerChassisType"
	TypeServerComponent       = "ServerComponent"
	TypeServerComponentType   = "ServerComponentType"
	TypeServerHardDrive       = "ServerHardDrive"
	TypeServerHardDriveType   = "ServerHardDriveType"
	TypeServerMemory          = "ServerMemory"
	TypeServerMemoryType      = "ServerMemoryType"
	TypeServerMotherboard     = "ServerMotherboard"
	TypeServerMotherboardType = "ServerMotherboardType"
	TypeServerNetworkCard     = "ServerNetworkCard"
	TypeServerNetworkCardType = "ServerNetworkCardType"
	TypeServerNetworkPort     = "ServerNetworkPort"
	TypeServerPowerSupply     = "ServerPowerSupply"
	TypeServerPowerSupplyType = "ServerPowerSupplyType"
	TypeServerType            = "ServerType"
)

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *gidx.PrefixedID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	resource_provider_id *gidx.PrefixedID
	clearedFields        map[string]struct{}
	servers              map[gidx.PrefixedID]struct{}
	removedservers       map[gidx.PrefixedID]struct{}
	clearedservers       bool
	done                 bool
	oldValue             func(context.Context) (*Provider, error)
	predicates           []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id gidx.PrefixedID) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provider entities.
func (m *ProviderMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderMutation) ResetName() {
	m.name = nil
}

// SetResourceProviderID sets the "resource_provider_id" field.
func (m *ProviderMutation) SetResourceProviderID(gi gidx.PrefixedID) {
	m.resource_provider_id = &gi
}

// ResourceProviderID returns the value of the "resource_provider_id" field in the mutation.
func (m *ProviderMutation) ResourceProviderID() (r gidx.PrefixedID, exists bool) {
	v := m.resource_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceProviderID returns the old "resource_provider_id" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldResourceProviderID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceProviderID: %w", err)
	}
	return oldValue.ResourceProviderID, nil
}

// ResetResourceProviderID resets all changes to the "resource_provider_id" field.
func (m *ProviderMutation) ResetResourceProviderID() {
	m.resource_provider_id = nil
}

// AddServerIDs adds the "servers" edge to the Server entity by ids.
func (m *ProviderMutation) AddServerIDs(ids ...gidx.PrefixedID) {
	if m.servers == nil {
		m.servers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the Server entity.
func (m *ProviderMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the Server entity was cleared.
func (m *ProviderMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the Server entity by IDs.
func (m *ProviderMutation) RemoveServerIDs(ids ...gidx.PrefixedID) {
	if m.removedservers == nil {
		m.removedservers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the Server entity.
func (m *ProviderMutation) RemovedServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *ProviderMutation) ServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *ProviderMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, provider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, provider.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, provider.FieldName)
	}
	if m.resource_provider_id != nil {
		fields = append(fields, provider.FieldResourceProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldCreatedAt:
		return m.CreatedAt()
	case provider.FieldUpdatedAt:
		return m.UpdatedAt()
	case provider.FieldName:
		return m.Name()
	case provider.FieldResourceProviderID:
		return m.ResourceProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case provider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case provider.FieldName:
		return m.OldName(ctx)
	case provider.FieldResourceProviderID:
		return m.OldResourceProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case provider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case provider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provider.FieldResourceProviderID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case provider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case provider.FieldName:
		m.ResetName()
		return nil
	case provider.FieldResourceProviderID:
		m.ResetResourceProviderID()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servers != nil {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservers != nil {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservers {
		edges = append(edges, provider.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op                 Op
	typ                string
	id                 *gidx.PrefixedID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	owner_id           *gidx.PrefixedID
	location_id        *gidx.PrefixedID
	clearedFields      map[string]struct{}
	provider           *gidx.PrefixedID
	clearedprovider    bool
	server_type        *gidx.PrefixedID
	clearedserver_type bool
	components         map[gidx.PrefixedID]struct{}
	removedcomponents  map[gidx.PrefixedID]struct{}
	clearedcomponents  bool
	done               bool
	oldValue           func(context.Context) (*Server, error)
	predicates         []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id gidx.PrefixedID) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Server entities.
func (m *ServerMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[server.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[server.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, server.FieldDescription)
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerMutation) SetOwnerID(gi gidx.PrefixedID) {
	m.owner_id = &gi
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerMutation) OwnerID() (r gidx.PrefixedID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOwnerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetLocationID sets the "location_id" field.
func (m *ServerMutation) SetLocationID(gi gidx.PrefixedID) {
	m.location_id = &gi
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ServerMutation) LocationID() (r gidx.PrefixedID, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldLocationID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ServerMutation) ResetLocationID() {
	m.location_id = nil
}

// SetProviderID sets the "provider_id" field.
func (m *ServerMutation) SetProviderID(gi gidx.PrefixedID) {
	m.provider = &gi
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *ServerMutation) ProviderID() (r gidx.PrefixedID, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldProviderID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *ServerMutation) ResetProviderID() {
	m.provider = nil
}

// SetServerTypeID sets the "server_type_id" field.
func (m *ServerMutation) SetServerTypeID(gi gidx.PrefixedID) {
	m.server_type = &gi
}

// ServerTypeID returns the value of the "server_type_id" field in the mutation.
func (m *ServerMutation) ServerTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerTypeID returns the old "server_type_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldServerTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerTypeID: %w", err)
	}
	return oldValue.ServerTypeID, nil
}

// ResetServerTypeID resets all changes to the "server_type_id" field.
func (m *ServerMutation) ResetServerTypeID() {
	m.server_type = nil
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *ServerMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *ServerMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ProviderIDs() (ids []gidx.PrefixedID) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *ServerMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// ClearServerType clears the "server_type" edge to the ServerType entity.
func (m *ServerMutation) ClearServerType() {
	m.clearedserver_type = true
}

// ServerTypeCleared reports if the "server_type" edge to the ServerType entity was cleared.
func (m *ServerMutation) ServerTypeCleared() bool {
	return m.clearedserver_type
}

// ServerTypeIDs returns the "server_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ServerTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerType resets all changes to the "server_type" edge.
func (m *ServerMutation) ResetServerType() {
	m.server_type = nil
	m.clearedserver_type = false
}

// AddComponentIDs adds the "components" edge to the ServerComponent entity by ids.
func (m *ServerMutation) AddComponentIDs(ids ...gidx.PrefixedID) {
	if m.components == nil {
		m.components = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ServerComponent entity.
func (m *ServerMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ServerComponent entity was cleared.
func (m *ServerMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ServerComponent entity by IDs.
func (m *ServerMutation) RemoveComponentIDs(ids ...gidx.PrefixedID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ServerComponent entity.
func (m *ServerMutation) RemovedComponentsIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ServerMutation) ComponentsIDs() (ids []gidx.PrefixedID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ServerMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, server.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, server.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, server.FieldName)
	}
	if m.description != nil {
		fields = append(fields, server.FieldDescription)
	}
	if m.owner_id != nil {
		fields = append(fields, server.FieldOwnerID)
	}
	if m.location_id != nil {
		fields = append(fields, server.FieldLocationID)
	}
	if m.provider != nil {
		fields = append(fields, server.FieldProviderID)
	}
	if m.server_type != nil {
		fields = append(fields, server.FieldServerTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCreatedAt:
		return m.CreatedAt()
	case server.FieldUpdatedAt:
		return m.UpdatedAt()
	case server.FieldName:
		return m.Name()
	case server.FieldDescription:
		return m.Description()
	case server.FieldOwnerID:
		return m.OwnerID()
	case server.FieldLocationID:
		return m.LocationID()
	case server.FieldProviderID:
		return m.ProviderID()
	case server.FieldServerTypeID:
		return m.ServerTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case server.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case server.FieldName:
		return m.OldName(ctx)
	case server.FieldDescription:
		return m.OldDescription(ctx)
	case server.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case server.FieldLocationID:
		return m.OldLocationID(ctx)
	case server.FieldProviderID:
		return m.OldProviderID(ctx)
	case server.FieldServerTypeID:
		return m.OldServerTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case server.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case server.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case server.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case server.FieldOwnerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case server.FieldLocationID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case server.FieldProviderID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case server.FieldServerTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldDescription) {
		fields = append(fields, server.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case server.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case server.FieldName:
		m.ResetName()
		return nil
	case server.FieldDescription:
		m.ResetDescription()
		return nil
	case server.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case server.FieldLocationID:
		m.ResetLocationID()
		return nil
	case server.FieldProviderID:
		m.ResetProviderID()
		return nil
	case server.FieldServerTypeID:
		m.ResetServerTypeID()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.provider != nil {
		edges = append(edges, server.EdgeProvider)
	}
	if m.server_type != nil {
		edges = append(edges, server.EdgeServerType)
	}
	if m.components != nil {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeServerType:
		if id := m.server_type; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcomponents != nil {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprovider {
		edges = append(edges, server.EdgeProvider)
	}
	if m.clearedserver_type {
		edges = append(edges, server.EdgeServerType)
	}
	if m.clearedcomponents {
		edges = append(edges, server.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeProvider:
		return m.clearedprovider
	case server.EdgeServerType:
		return m.clearedserver_type
	case server.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	case server.EdgeProvider:
		m.ClearProvider()
		return nil
	case server.EdgeServerType:
		m.ClearServerType()
		return nil
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeProvider:
		m.ResetProvider()
		return nil
	case server.EdgeServerType:
		m.ResetServerType()
		return nil
	case server.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// ServerCPUMutation represents an operation that mutates the ServerCPU nodes in the graph.
type ServerCPUMutation struct {
	config
	op                     Op
	typ                    string
	id                     *gidx.PrefixedID
	created_at             *time.Time
	updated_at             *time.Time
	serial                 *string
	clearedFields          map[string]struct{}
	server                 *gidx.PrefixedID
	clearedserver          bool
	server_cpu_type        *gidx.PrefixedID
	clearedserver_cpu_type bool
	done                   bool
	oldValue               func(context.Context) (*ServerCPU, error)
	predicates             []predicate.ServerCPU
}

var _ ent.Mutation = (*ServerCPUMutation)(nil)

// servercpuOption allows management of the mutation configuration using functional options.
type servercpuOption func(*ServerCPUMutation)

// newServerCPUMutation creates new mutation for the ServerCPU entity.
func newServerCPUMutation(c config, op Op, opts ...servercpuOption) *ServerCPUMutation {
	m := &ServerCPUMutation{
		config:        c,
		op:            op,
		typ:           TypeServerCPU,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerCPUID sets the ID field of the mutation.
func withServerCPUID(id gidx.PrefixedID) servercpuOption {
	return func(m *ServerCPUMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerCPU
		)
		m.oldValue = func(ctx context.Context) (*ServerCPU, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerCPU.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerCPU sets the old ServerCPU of the mutation.
func withServerCPU(node *ServerCPU) servercpuOption {
	return func(m *ServerCPUMutation) {
		m.oldValue = func(context.Context) (*ServerCPU, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerCPUMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerCPUMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerCPU entities.
func (m *ServerCPUMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerCPUMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerCPUMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerCPU.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerCPUMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerCPUMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerCPU entity.
// If the ServerCPU object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerCPUMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerCPUMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerCPUMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerCPU entity.
// If the ServerCPU object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerCPUMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServerCPUTypeID sets the "server_cpu_type_id" field.
func (m *ServerCPUMutation) SetServerCPUTypeID(gi gidx.PrefixedID) {
	m.server_cpu_type = &gi
}

// ServerCPUTypeID returns the value of the "server_cpu_type_id" field in the mutation.
func (m *ServerCPUMutation) ServerCPUTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_cpu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerCPUTypeID returns the old "server_cpu_type_id" field's value of the ServerCPU entity.
// If the ServerCPU object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUMutation) OldServerCPUTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerCPUTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerCPUTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerCPUTypeID: %w", err)
	}
	return oldValue.ServerCPUTypeID, nil
}

// ResetServerCPUTypeID resets all changes to the "server_cpu_type_id" field.
func (m *ServerCPUMutation) ResetServerCPUTypeID() {
	m.server_cpu_type = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerCPUMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerCPUMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerCPU entity.
// If the ServerCPU object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerCPUMutation) ResetServerID() {
	m.server = nil
}

// SetSerial sets the "serial" field.
func (m *ServerCPUMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerCPUMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerCPU entity.
// If the ServerCPU object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerCPUMutation) ResetSerial() {
	m.serial = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerCPUMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerCPUMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerCPUMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerCPUMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerCPUType clears the "server_cpu_type" edge to the ServerCPUType entity.
func (m *ServerCPUMutation) ClearServerCPUType() {
	m.clearedserver_cpu_type = true
}

// ServerCPUTypeCleared reports if the "server_cpu_type" edge to the ServerCPUType entity was cleared.
func (m *ServerCPUMutation) ServerCPUTypeCleared() bool {
	return m.clearedserver_cpu_type
}

// ServerCPUTypeIDs returns the "server_cpu_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerCPUTypeID instead. It exists only for internal usage by the builders.
func (m *ServerCPUMutation) ServerCPUTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_cpu_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerCPUType resets all changes to the "server_cpu_type" edge.
func (m *ServerCPUMutation) ResetServerCPUType() {
	m.server_cpu_type = nil
	m.clearedserver_cpu_type = false
}

// Where appends a list predicates to the ServerCPUMutation builder.
func (m *ServerCPUMutation) Where(ps ...predicate.ServerCPU) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerCPUMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerCPUMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerCPU, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerCPUMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerCPUMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerCPU).
func (m *ServerCPUMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerCPUMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, servercpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercpu.FieldUpdatedAt)
	}
	if m.server_cpu_type != nil {
		fields = append(fields, servercpu.FieldServerCPUTypeID)
	}
	if m.server != nil {
		fields = append(fields, servercpu.FieldServerID)
	}
	if m.serial != nil {
		fields = append(fields, servercpu.FieldSerial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerCPUMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercpu.FieldCreatedAt:
		return m.CreatedAt()
	case servercpu.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercpu.FieldServerCPUTypeID:
		return m.ServerCPUTypeID()
	case servercpu.FieldServerID:
		return m.ServerID()
	case servercpu.FieldSerial:
		return m.Serial()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerCPUMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercpu.FieldServerCPUTypeID:
		return m.OldServerCPUTypeID(ctx)
	case servercpu.FieldServerID:
		return m.OldServerID(ctx)
	case servercpu.FieldSerial:
		return m.OldSerial(ctx)
	}
	return nil, fmt.Errorf("unknown ServerCPU field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercpu.FieldServerCPUTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerCPUTypeID(v)
		return nil
	case servercpu.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case servercpu.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	}
	return fmt.Errorf("unknown ServerCPU field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerCPUMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerCPUMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerCPU numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerCPUMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerCPUMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerCPUMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerCPU nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerCPUMutation) ResetField(name string) error {
	switch name {
	case servercpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercpu.FieldServerCPUTypeID:
		m.ResetServerCPUTypeID()
		return nil
	case servercpu.FieldServerID:
		m.ResetServerID()
		return nil
	case servercpu.FieldSerial:
		m.ResetSerial()
		return nil
	}
	return fmt.Errorf("unknown ServerCPU field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerCPUMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, servercpu.EdgeServer)
	}
	if m.server_cpu_type != nil {
		edges = append(edges, servercpu.EdgeServerCPUType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerCPUMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servercpu.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case servercpu.EdgeServerCPUType:
		if id := m.server_cpu_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerCPUMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerCPUMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerCPUMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, servercpu.EdgeServer)
	}
	if m.clearedserver_cpu_type {
		edges = append(edges, servercpu.EdgeServerCPUType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerCPUMutation) EdgeCleared(name string) bool {
	switch name {
	case servercpu.EdgeServer:
		return m.clearedserver
	case servercpu.EdgeServerCPUType:
		return m.clearedserver_cpu_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerCPUMutation) ClearEdge(name string) error {
	switch name {
	case servercpu.EdgeServer:
		m.ClearServer()
		return nil
	case servercpu.EdgeServerCPUType:
		m.ClearServerCPUType()
		return nil
	}
	return fmt.Errorf("unknown ServerCPU unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerCPUMutation) ResetEdge(name string) error {
	switch name {
	case servercpu.EdgeServer:
		m.ResetServer()
		return nil
	case servercpu.EdgeServerCPUType:
		m.ResetServerCPUType()
		return nil
	}
	return fmt.Errorf("unknown ServerCPU edge %s", name)
}

// ServerCPUTypeMutation represents an operation that mutates the ServerCPUType nodes in the graph.
type ServerCPUTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	vendor        *string
	model         *string
	clock_speed   *string
	core_count    *int64
	addcore_count *int64
	clearedFields map[string]struct{}
	cpu           map[gidx.PrefixedID]struct{}
	removedcpu    map[gidx.PrefixedID]struct{}
	clearedcpu    bool
	done          bool
	oldValue      func(context.Context) (*ServerCPUType, error)
	predicates    []predicate.ServerCPUType
}

var _ ent.Mutation = (*ServerCPUTypeMutation)(nil)

// servercputypeOption allows management of the mutation configuration using functional options.
type servercputypeOption func(*ServerCPUTypeMutation)

// newServerCPUTypeMutation creates new mutation for the ServerCPUType entity.
func newServerCPUTypeMutation(c config, op Op, opts ...servercputypeOption) *ServerCPUTypeMutation {
	m := &ServerCPUTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerCPUType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerCPUTypeID sets the ID field of the mutation.
func withServerCPUTypeID(id gidx.PrefixedID) servercputypeOption {
	return func(m *ServerCPUTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerCPUType
		)
		m.oldValue = func(ctx context.Context) (*ServerCPUType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerCPUType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerCPUType sets the old ServerCPUType of the mutation.
func withServerCPUType(node *ServerCPUType) servercputypeOption {
	return func(m *ServerCPUTypeMutation) {
		m.oldValue = func(context.Context) (*ServerCPUType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerCPUTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerCPUTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerCPUType entities.
func (m *ServerCPUTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerCPUTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerCPUTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerCPUType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerCPUTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerCPUTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerCPUTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerCPUTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerCPUTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerCPUTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerCPUTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerCPUTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerCPUTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerCPUTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerCPUTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerCPUTypeMutation) ResetModel() {
	m.model = nil
}

// SetClockSpeed sets the "clock_speed" field.
func (m *ServerCPUTypeMutation) SetClockSpeed(s string) {
	m.clock_speed = &s
}

// ClockSpeed returns the value of the "clock_speed" field in the mutation.
func (m *ServerCPUTypeMutation) ClockSpeed() (r string, exists bool) {
	v := m.clock_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldClockSpeed returns the old "clock_speed" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldClockSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClockSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClockSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockSpeed: %w", err)
	}
	return oldValue.ClockSpeed, nil
}

// ResetClockSpeed resets all changes to the "clock_speed" field.
func (m *ServerCPUTypeMutation) ResetClockSpeed() {
	m.clock_speed = nil
}

// SetCoreCount sets the "core_count" field.
func (m *ServerCPUTypeMutation) SetCoreCount(i int64) {
	m.core_count = &i
	m.addcore_count = nil
}

// CoreCount returns the value of the "core_count" field in the mutation.
func (m *ServerCPUTypeMutation) CoreCount() (r int64, exists bool) {
	v := m.core_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCoreCount returns the old "core_count" field's value of the ServerCPUType entity.
// If the ServerCPUType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerCPUTypeMutation) OldCoreCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoreCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoreCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoreCount: %w", err)
	}
	return oldValue.CoreCount, nil
}

// AddCoreCount adds i to the "core_count" field.
func (m *ServerCPUTypeMutation) AddCoreCount(i int64) {
	if m.addcore_count != nil {
		*m.addcore_count += i
	} else {
		m.addcore_count = &i
	}
}

// AddedCoreCount returns the value that was added to the "core_count" field in this mutation.
func (m *ServerCPUTypeMutation) AddedCoreCount() (r int64, exists bool) {
	v := m.addcore_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoreCount resets all changes to the "core_count" field.
func (m *ServerCPUTypeMutation) ResetCoreCount() {
	m.core_count = nil
	m.addcore_count = nil
}

// AddCPUIDs adds the "cpu" edge to the ServerCPU entity by ids.
func (m *ServerCPUTypeMutation) AddCPUIDs(ids ...gidx.PrefixedID) {
	if m.cpu == nil {
		m.cpu = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.cpu[ids[i]] = struct{}{}
	}
}

// ClearCPU clears the "cpu" edge to the ServerCPU entity.
func (m *ServerCPUTypeMutation) ClearCPU() {
	m.clearedcpu = true
}

// CPUCleared reports if the "cpu" edge to the ServerCPU entity was cleared.
func (m *ServerCPUTypeMutation) CPUCleared() bool {
	return m.clearedcpu
}

// RemoveCPUIDs removes the "cpu" edge to the ServerCPU entity by IDs.
func (m *ServerCPUTypeMutation) RemoveCPUIDs(ids ...gidx.PrefixedID) {
	if m.removedcpu == nil {
		m.removedcpu = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.cpu, ids[i])
		m.removedcpu[ids[i]] = struct{}{}
	}
}

// RemovedCPU returns the removed IDs of the "cpu" edge to the ServerCPU entity.
func (m *ServerCPUTypeMutation) RemovedCPUIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedcpu {
		ids = append(ids, id)
	}
	return
}

// CPUIDs returns the "cpu" edge IDs in the mutation.
func (m *ServerCPUTypeMutation) CPUIDs() (ids []gidx.PrefixedID) {
	for id := range m.cpu {
		ids = append(ids, id)
	}
	return
}

// ResetCPU resets all changes to the "cpu" edge.
func (m *ServerCPUTypeMutation) ResetCPU() {
	m.cpu = nil
	m.clearedcpu = false
	m.removedcpu = nil
}

// Where appends a list predicates to the ServerCPUTypeMutation builder.
func (m *ServerCPUTypeMutation) Where(ps ...predicate.ServerCPUType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerCPUTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerCPUTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerCPUType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerCPUTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerCPUTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerCPUType).
func (m *ServerCPUTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerCPUTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, servercputype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercputype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, servercputype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servercputype.FieldModel)
	}
	if m.clock_speed != nil {
		fields = append(fields, servercputype.FieldClockSpeed)
	}
	if m.core_count != nil {
		fields = append(fields, servercputype.FieldCoreCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerCPUTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercputype.FieldCreatedAt:
		return m.CreatedAt()
	case servercputype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercputype.FieldVendor:
		return m.Vendor()
	case servercputype.FieldModel:
		return m.Model()
	case servercputype.FieldClockSpeed:
		return m.ClockSpeed()
	case servercputype.FieldCoreCount:
		return m.CoreCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerCPUTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercputype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercputype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercputype.FieldVendor:
		return m.OldVendor(ctx)
	case servercputype.FieldModel:
		return m.OldModel(ctx)
	case servercputype.FieldClockSpeed:
		return m.OldClockSpeed(ctx)
	case servercputype.FieldCoreCount:
		return m.OldCoreCount(ctx)
	}
	return nil, fmt.Errorf("unknown ServerCPUType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercputype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercputype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercputype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servercputype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servercputype.FieldClockSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockSpeed(v)
		return nil
	case servercputype.FieldCoreCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerCPUTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcore_count != nil {
		fields = append(fields, servercputype.FieldCoreCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerCPUTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servercputype.FieldCoreCount:
		return m.AddedCoreCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerCPUTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servercputype.FieldCoreCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerCPUTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerCPUTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerCPUTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerCPUType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerCPUTypeMutation) ResetField(name string) error {
	switch name {
	case servercputype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercputype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercputype.FieldVendor:
		m.ResetVendor()
		return nil
	case servercputype.FieldModel:
		m.ResetModel()
		return nil
	case servercputype.FieldClockSpeed:
		m.ResetClockSpeed()
		return nil
	case servercputype.FieldCoreCount:
		m.ResetCoreCount()
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerCPUTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cpu != nil {
		edges = append(edges, servercputype.EdgeCPU)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerCPUTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servercputype.EdgeCPU:
		ids := make([]ent.Value, 0, len(m.cpu))
		for id := range m.cpu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerCPUTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcpu != nil {
		edges = append(edges, servercputype.EdgeCPU)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerCPUTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servercputype.EdgeCPU:
		ids := make([]ent.Value, 0, len(m.removedcpu))
		for id := range m.removedcpu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerCPUTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcpu {
		edges = append(edges, servercputype.EdgeCPU)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerCPUTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servercputype.EdgeCPU:
		return m.clearedcpu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerCPUTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerCPUType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerCPUTypeMutation) ResetEdge(name string) error {
	switch name {
	case servercputype.EdgeCPU:
		m.ResetCPU()
		return nil
	}
	return fmt.Errorf("unknown ServerCPUType edge %s", name)
}

// ServerChassisMutation represents an operation that mutates the ServerChassis nodes in the graph.
type ServerChassisMutation struct {
	config
	op                         Op
	typ                        string
	id                         *gidx.PrefixedID
	created_at                 *time.Time
	updated_at                 *time.Time
	parent_chassis_id          *gidx.PrefixedID
	serial                     *string
	clearedFields              map[string]struct{}
	server                     *gidx.PrefixedID
	clearedserver              bool
	server_chassis_type        *gidx.PrefixedID
	clearedserver_chassis_type bool
	done                       bool
	oldValue                   func(context.Context) (*ServerChassis, error)
	predicates                 []predicate.ServerChassis
}

var _ ent.Mutation = (*ServerChassisMutation)(nil)

// serverchassisOption allows management of the mutation configuration using functional options.
type serverchassisOption func(*ServerChassisMutation)

// newServerChassisMutation creates new mutation for the ServerChassis entity.
func newServerChassisMutation(c config, op Op, opts ...serverchassisOption) *ServerChassisMutation {
	m := &ServerChassisMutation{
		config:        c,
		op:            op,
		typ:           TypeServerChassis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerChassisID sets the ID field of the mutation.
func withServerChassisID(id gidx.PrefixedID) serverchassisOption {
	return func(m *ServerChassisMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerChassis
		)
		m.oldValue = func(ctx context.Context) (*ServerChassis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerChassis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerChassis sets the old ServerChassis of the mutation.
func withServerChassis(node *ServerChassis) serverchassisOption {
	return func(m *ServerChassisMutation) {
		m.oldValue = func(context.Context) (*ServerChassis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerChassisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerChassisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerChassis entities.
func (m *ServerChassisMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerChassisMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerChassisMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerChassis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerChassisMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerChassisMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerChassisMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerChassisMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerChassisMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerChassisMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServerChassisTypeID sets the "server_chassis_type_id" field.
func (m *ServerChassisMutation) SetServerChassisTypeID(gi gidx.PrefixedID) {
	m.server_chassis_type = &gi
}

// ServerChassisTypeID returns the value of the "server_chassis_type_id" field in the mutation.
func (m *ServerChassisMutation) ServerChassisTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_chassis_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerChassisTypeID returns the old "server_chassis_type_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldServerChassisTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerChassisTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerChassisTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerChassisTypeID: %w", err)
	}
	return oldValue.ServerChassisTypeID, nil
}

// ResetServerChassisTypeID resets all changes to the "server_chassis_type_id" field.
func (m *ServerChassisMutation) ResetServerChassisTypeID() {
	m.server_chassis_type = nil
}

// SetParentChassisID sets the "parent_chassis_id" field.
func (m *ServerChassisMutation) SetParentChassisID(gi gidx.PrefixedID) {
	m.parent_chassis_id = &gi
}

// ParentChassisID returns the value of the "parent_chassis_id" field in the mutation.
func (m *ServerChassisMutation) ParentChassisID() (r gidx.PrefixedID, exists bool) {
	v := m.parent_chassis_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentChassisID returns the old "parent_chassis_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldParentChassisID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentChassisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentChassisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentChassisID: %w", err)
	}
	return oldValue.ParentChassisID, nil
}

// ResetParentChassisID resets all changes to the "parent_chassis_id" field.
func (m *ServerChassisMutation) ResetParentChassisID() {
	m.parent_chassis_id = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerChassisMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerChassisMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerChassisMutation) ResetServerID() {
	m.server = nil
}

// SetSerial sets the "serial" field.
func (m *ServerChassisMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerChassisMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerChassis entity.
// If the ServerChassis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerChassisMutation) ResetSerial() {
	m.serial = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerChassisMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerChassisMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerChassisMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerChassisMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerChassisType clears the "server_chassis_type" edge to the ServerChassisType entity.
func (m *ServerChassisMutation) ClearServerChassisType() {
	m.clearedserver_chassis_type = true
}

// ServerChassisTypeCleared reports if the "server_chassis_type" edge to the ServerChassisType entity was cleared.
func (m *ServerChassisMutation) ServerChassisTypeCleared() bool {
	return m.clearedserver_chassis_type
}

// ServerChassisTypeIDs returns the "server_chassis_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerChassisTypeID instead. It exists only for internal usage by the builders.
func (m *ServerChassisMutation) ServerChassisTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_chassis_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerChassisType resets all changes to the "server_chassis_type" edge.
func (m *ServerChassisMutation) ResetServerChassisType() {
	m.server_chassis_type = nil
	m.clearedserver_chassis_type = false
}

// Where appends a list predicates to the ServerChassisMutation builder.
func (m *ServerChassisMutation) Where(ps ...predicate.ServerChassis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerChassisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerChassisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerChassis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerChassisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerChassisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerChassis).
func (m *ServerChassisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerChassisMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, serverchassis.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverchassis.FieldUpdatedAt)
	}
	if m.server_chassis_type != nil {
		fields = append(fields, serverchassis.FieldServerChassisTypeID)
	}
	if m.parent_chassis_id != nil {
		fields = append(fields, serverchassis.FieldParentChassisID)
	}
	if m.server != nil {
		fields = append(fields, serverchassis.FieldServerID)
	}
	if m.serial != nil {
		fields = append(fields, serverchassis.FieldSerial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerChassisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverchassis.FieldCreatedAt:
		return m.CreatedAt()
	case serverchassis.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverchassis.FieldServerChassisTypeID:
		return m.ServerChassisTypeID()
	case serverchassis.FieldParentChassisID:
		return m.ParentChassisID()
	case serverchassis.FieldServerID:
		return m.ServerID()
	case serverchassis.FieldSerial:
		return m.Serial()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerChassisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverchassis.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverchassis.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverchassis.FieldServerChassisTypeID:
		return m.OldServerChassisTypeID(ctx)
	case serverchassis.FieldParentChassisID:
		return m.OldParentChassisID(ctx)
	case serverchassis.FieldServerID:
		return m.OldServerID(ctx)
	case serverchassis.FieldSerial:
		return m.OldSerial(ctx)
	}
	return nil, fmt.Errorf("unknown ServerChassis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverchassis.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverchassis.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverchassis.FieldServerChassisTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerChassisTypeID(v)
		return nil
	case serverchassis.FieldParentChassisID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentChassisID(v)
		return nil
	case serverchassis.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case serverchassis.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	}
	return fmt.Errorf("unknown ServerChassis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerChassisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerChassisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerChassisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerChassisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerChassisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerChassis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerChassisMutation) ResetField(name string) error {
	switch name {
	case serverchassis.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverchassis.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverchassis.FieldServerChassisTypeID:
		m.ResetServerChassisTypeID()
		return nil
	case serverchassis.FieldParentChassisID:
		m.ResetParentChassisID()
		return nil
	case serverchassis.FieldServerID:
		m.ResetServerID()
		return nil
	case serverchassis.FieldSerial:
		m.ResetSerial()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerChassisMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, serverchassis.EdgeServer)
	}
	if m.server_chassis_type != nil {
		edges = append(edges, serverchassis.EdgeServerChassisType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerChassisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverchassis.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case serverchassis.EdgeServerChassisType:
		if id := m.server_chassis_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerChassisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerChassisMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerChassisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, serverchassis.EdgeServer)
	}
	if m.clearedserver_chassis_type {
		edges = append(edges, serverchassis.EdgeServerChassisType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerChassisMutation) EdgeCleared(name string) bool {
	switch name {
	case serverchassis.EdgeServer:
		return m.clearedserver
	case serverchassis.EdgeServerChassisType:
		return m.clearedserver_chassis_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerChassisMutation) ClearEdge(name string) error {
	switch name {
	case serverchassis.EdgeServer:
		m.ClearServer()
		return nil
	case serverchassis.EdgeServerChassisType:
		m.ClearServerChassisType()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerChassisMutation) ResetEdge(name string) error {
	switch name {
	case serverchassis.EdgeServer:
		m.ResetServer()
		return nil
	case serverchassis.EdgeServerChassisType:
		m.ResetServerChassisType()
		return nil
	}
	return fmt.Errorf("unknown ServerChassis edge %s", name)
}

// ServerChassisTypeMutation represents an operation that mutates the ServerChassisType nodes in the graph.
type ServerChassisTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *gidx.PrefixedID
	created_at             *time.Time
	updated_at             *time.Time
	vendor                 *string
	model                  *string
	height                 *string
	is_full_depth          *bool
	parent_chassis_type_id *gidx.PrefixedID
	clearedFields          map[string]struct{}
	chassis                map[gidx.PrefixedID]struct{}
	removedchassis         map[gidx.PrefixedID]struct{}
	clearedchassis         bool
	done                   bool
	oldValue               func(context.Context) (*ServerChassisType, error)
	predicates             []predicate.ServerChassisType
}

var _ ent.Mutation = (*ServerChassisTypeMutation)(nil)

// serverchassistypeOption allows management of the mutation configuration using functional options.
type serverchassistypeOption func(*ServerChassisTypeMutation)

// newServerChassisTypeMutation creates new mutation for the ServerChassisType entity.
func newServerChassisTypeMutation(c config, op Op, opts ...serverchassistypeOption) *ServerChassisTypeMutation {
	m := &ServerChassisTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerChassisType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerChassisTypeID sets the ID field of the mutation.
func withServerChassisTypeID(id gidx.PrefixedID) serverchassistypeOption {
	return func(m *ServerChassisTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerChassisType
		)
		m.oldValue = func(ctx context.Context) (*ServerChassisType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerChassisType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerChassisType sets the old ServerChassisType of the mutation.
func withServerChassisType(node *ServerChassisType) serverchassistypeOption {
	return func(m *ServerChassisTypeMutation) {
		m.oldValue = func(context.Context) (*ServerChassisType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerChassisTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerChassisTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerChassisType entities.
func (m *ServerChassisTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerChassisTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerChassisTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerChassisType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerChassisTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerChassisTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerChassisTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerChassisTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerChassisTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerChassisTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerChassisTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerChassisTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerChassisTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerChassisTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerChassisTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerChassisTypeMutation) ResetModel() {
	m.model = nil
}

// SetHeight sets the "height" field.
func (m *ServerChassisTypeMutation) SetHeight(s string) {
	m.height = &s
}

// Height returns the value of the "height" field in the mutation.
func (m *ServerChassisTypeMutation) Height() (r string, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// ResetHeight resets all changes to the "height" field.
func (m *ServerChassisTypeMutation) ResetHeight() {
	m.height = nil
}

// SetIsFullDepth sets the "is_full_depth" field.
func (m *ServerChassisTypeMutation) SetIsFullDepth(b bool) {
	m.is_full_depth = &b
}

// IsFullDepth returns the value of the "is_full_depth" field in the mutation.
func (m *ServerChassisTypeMutation) IsFullDepth() (r bool, exists bool) {
	v := m.is_full_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFullDepth returns the old "is_full_depth" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldIsFullDepth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFullDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFullDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFullDepth: %w", err)
	}
	return oldValue.IsFullDepth, nil
}

// ResetIsFullDepth resets all changes to the "is_full_depth" field.
func (m *ServerChassisTypeMutation) ResetIsFullDepth() {
	m.is_full_depth = nil
}

// SetParentChassisTypeID sets the "parent_chassis_type_id" field.
func (m *ServerChassisTypeMutation) SetParentChassisTypeID(gi gidx.PrefixedID) {
	m.parent_chassis_type_id = &gi
}

// ParentChassisTypeID returns the value of the "parent_chassis_type_id" field in the mutation.
func (m *ServerChassisTypeMutation) ParentChassisTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.parent_chassis_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentChassisTypeID returns the old "parent_chassis_type_id" field's value of the ServerChassisType entity.
// If the ServerChassisType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerChassisTypeMutation) OldParentChassisTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentChassisTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentChassisTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentChassisTypeID: %w", err)
	}
	return oldValue.ParentChassisTypeID, nil
}

// ResetParentChassisTypeID resets all changes to the "parent_chassis_type_id" field.
func (m *ServerChassisTypeMutation) ResetParentChassisTypeID() {
	m.parent_chassis_type_id = nil
}

// AddChassiIDs adds the "chassis" edge to the ServerChassis entity by ids.
func (m *ServerChassisTypeMutation) AddChassiIDs(ids ...gidx.PrefixedID) {
	if m.chassis == nil {
		m.chassis = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.chassis[ids[i]] = struct{}{}
	}
}

// ClearChassis clears the "chassis" edge to the ServerChassis entity.
func (m *ServerChassisTypeMutation) ClearChassis() {
	m.clearedchassis = true
}

// ChassisCleared reports if the "chassis" edge to the ServerChassis entity was cleared.
func (m *ServerChassisTypeMutation) ChassisCleared() bool {
	return m.clearedchassis
}

// RemoveChassiIDs removes the "chassis" edge to the ServerChassis entity by IDs.
func (m *ServerChassisTypeMutation) RemoveChassiIDs(ids ...gidx.PrefixedID) {
	if m.removedchassis == nil {
		m.removedchassis = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.chassis, ids[i])
		m.removedchassis[ids[i]] = struct{}{}
	}
}

// RemovedChassis returns the removed IDs of the "chassis" edge to the ServerChassis entity.
func (m *ServerChassisTypeMutation) RemovedChassisIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedchassis {
		ids = append(ids, id)
	}
	return
}

// ChassisIDs returns the "chassis" edge IDs in the mutation.
func (m *ServerChassisTypeMutation) ChassisIDs() (ids []gidx.PrefixedID) {
	for id := range m.chassis {
		ids = append(ids, id)
	}
	return
}

// ResetChassis resets all changes to the "chassis" edge.
func (m *ServerChassisTypeMutation) ResetChassis() {
	m.chassis = nil
	m.clearedchassis = false
	m.removedchassis = nil
}

// Where appends a list predicates to the ServerChassisTypeMutation builder.
func (m *ServerChassisTypeMutation) Where(ps ...predicate.ServerChassisType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerChassisTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerChassisTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerChassisType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerChassisTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerChassisTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerChassisType).
func (m *ServerChassisTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerChassisTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, serverchassistype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverchassistype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, serverchassistype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, serverchassistype.FieldModel)
	}
	if m.height != nil {
		fields = append(fields, serverchassistype.FieldHeight)
	}
	if m.is_full_depth != nil {
		fields = append(fields, serverchassistype.FieldIsFullDepth)
	}
	if m.parent_chassis_type_id != nil {
		fields = append(fields, serverchassistype.FieldParentChassisTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerChassisTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverchassistype.FieldCreatedAt:
		return m.CreatedAt()
	case serverchassistype.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverchassistype.FieldVendor:
		return m.Vendor()
	case serverchassistype.FieldModel:
		return m.Model()
	case serverchassistype.FieldHeight:
		return m.Height()
	case serverchassistype.FieldIsFullDepth:
		return m.IsFullDepth()
	case serverchassistype.FieldParentChassisTypeID:
		return m.ParentChassisTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerChassisTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverchassistype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverchassistype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverchassistype.FieldVendor:
		return m.OldVendor(ctx)
	case serverchassistype.FieldModel:
		return m.OldModel(ctx)
	case serverchassistype.FieldHeight:
		return m.OldHeight(ctx)
	case serverchassistype.FieldIsFullDepth:
		return m.OldIsFullDepth(ctx)
	case serverchassistype.FieldParentChassisTypeID:
		return m.OldParentChassisTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerChassisType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverchassistype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverchassistype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverchassistype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case serverchassistype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case serverchassistype.FieldHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case serverchassistype.FieldIsFullDepth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFullDepth(v)
		return nil
	case serverchassistype.FieldParentChassisTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentChassisTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerChassisTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerChassisTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerChassisTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassisType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerChassisTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerChassisTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerChassisTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerChassisType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerChassisTypeMutation) ResetField(name string) error {
	switch name {
	case serverchassistype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverchassistype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverchassistype.FieldVendor:
		m.ResetVendor()
		return nil
	case serverchassistype.FieldModel:
		m.ResetModel()
		return nil
	case serverchassistype.FieldHeight:
		m.ResetHeight()
		return nil
	case serverchassistype.FieldIsFullDepth:
		m.ResetIsFullDepth()
		return nil
	case serverchassistype.FieldParentChassisTypeID:
		m.ResetParentChassisTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerChassisTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chassis != nil {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerChassisTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverchassistype.EdgeChassis:
		ids := make([]ent.Value, 0, len(m.chassis))
		for id := range m.chassis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerChassisTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchassis != nil {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerChassisTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serverchassistype.EdgeChassis:
		ids := make([]ent.Value, 0, len(m.removedchassis))
		for id := range m.removedchassis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerChassisTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchassis {
		edges = append(edges, serverchassistype.EdgeChassis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerChassisTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case serverchassistype.EdgeChassis:
		return m.clearedchassis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerChassisTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerChassisType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerChassisTypeMutation) ResetEdge(name string) error {
	switch name {
	case serverchassistype.EdgeChassis:
		m.ResetChassis()
		return nil
	}
	return fmt.Errorf("unknown ServerChassisType edge %s", name)
}

// ServerComponentMutation represents an operation that mutates the ServerComponent nodes in the graph.
type ServerComponentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *gidx.PrefixedID
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	vendor                *string
	model                 *string
	serial                *string
	clearedFields         map[string]struct{}
	component_type        *gidx.PrefixedID
	clearedcomponent_type bool
	server                *gidx.PrefixedID
	clearedserver         bool
	done                  bool
	oldValue              func(context.Context) (*ServerComponent, error)
	predicates            []predicate.ServerComponent
}

var _ ent.Mutation = (*ServerComponentMutation)(nil)

// servercomponentOption allows management of the mutation configuration using functional options.
type servercomponentOption func(*ServerComponentMutation)

// newServerComponentMutation creates new mutation for the ServerComponent entity.
func newServerComponentMutation(c config, op Op, opts ...servercomponentOption) *ServerComponentMutation {
	m := &ServerComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeServerComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerComponentID sets the ID field of the mutation.
func withServerComponentID(id gidx.PrefixedID) servercomponentOption {
	return func(m *ServerComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerComponent
		)
		m.oldValue = func(ctx context.Context) (*ServerComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerComponent sets the old ServerComponent of the mutation.
func withServerComponent(node *ServerComponent) servercomponentOption {
	return func(m *ServerComponentMutation) {
		m.oldValue = func(context.Context) (*ServerComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerComponent entities.
func (m *ServerComponentMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerComponentMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerComponentMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerComponentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerComponentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerComponentMutation) ResetName() {
	m.name = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerComponentMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerComponentMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerComponentMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerComponentMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerComponentMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerComponentMutation) ResetModel() {
	m.model = nil
}

// SetSerial sets the "serial" field.
func (m *ServerComponentMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerComponentMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerComponentMutation) ResetSerial() {
	m.serial = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerComponentMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerComponentMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerComponentMutation) ResetServerID() {
	m.server = nil
}

// SetComponentTypeID sets the "component_type_id" field.
func (m *ServerComponentMutation) SetComponentTypeID(gi gidx.PrefixedID) {
	m.component_type = &gi
}

// ComponentTypeID returns the value of the "component_type_id" field in the mutation.
func (m *ServerComponentMutation) ComponentTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.component_type
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentTypeID returns the old "component_type_id" field's value of the ServerComponent entity.
// If the ServerComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentMutation) OldComponentTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentTypeID: %w", err)
	}
	return oldValue.ComponentTypeID, nil
}

// ResetComponentTypeID resets all changes to the "component_type_id" field.
func (m *ServerComponentMutation) ResetComponentTypeID() {
	m.component_type = nil
}

// ClearComponentType clears the "component_type" edge to the ServerComponentType entity.
func (m *ServerComponentMutation) ClearComponentType() {
	m.clearedcomponent_type = true
}

// ComponentTypeCleared reports if the "component_type" edge to the ServerComponentType entity was cleared.
func (m *ServerComponentMutation) ComponentTypeCleared() bool {
	return m.clearedcomponent_type
}

// ComponentTypeIDs returns the "component_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentTypeID instead. It exists only for internal usage by the builders.
func (m *ServerComponentMutation) ComponentTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.component_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponentType resets all changes to the "component_type" edge.
func (m *ServerComponentMutation) ResetComponentType() {
	m.component_type = nil
	m.clearedcomponent_type = false
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerComponentMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerComponentMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerComponentMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerComponentMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// Where appends a list predicates to the ServerComponentMutation builder.
func (m *ServerComponentMutation) Where(ps ...predicate.ServerComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerComponent).
func (m *ServerComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerComponentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, servercomponent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercomponent.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servercomponent.FieldName)
	}
	if m.vendor != nil {
		fields = append(fields, servercomponent.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servercomponent.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, servercomponent.FieldSerial)
	}
	if m.server != nil {
		fields = append(fields, servercomponent.FieldServerID)
	}
	if m.component_type != nil {
		fields = append(fields, servercomponent.FieldComponentTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercomponent.FieldCreatedAt:
		return m.CreatedAt()
	case servercomponent.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercomponent.FieldName:
		return m.Name()
	case servercomponent.FieldVendor:
		return m.Vendor()
	case servercomponent.FieldModel:
		return m.Model()
	case servercomponent.FieldSerial:
		return m.Serial()
	case servercomponent.FieldServerID:
		return m.ServerID()
	case servercomponent.FieldComponentTypeID:
		return m.ComponentTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercomponent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercomponent.FieldName:
		return m.OldName(ctx)
	case servercomponent.FieldVendor:
		return m.OldVendor(ctx)
	case servercomponent.FieldModel:
		return m.OldModel(ctx)
	case servercomponent.FieldSerial:
		return m.OldSerial(ctx)
	case servercomponent.FieldServerID:
		return m.OldServerID(ctx)
	case servercomponent.FieldComponentTypeID:
		return m.OldComponentTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercomponent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servercomponent.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servercomponent.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servercomponent.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case servercomponent.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case servercomponent.FieldComponentTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerComponentMutation) ResetField(name string) error {
	switch name {
	case servercomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercomponent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercomponent.FieldName:
		m.ResetName()
		return nil
	case servercomponent.FieldVendor:
		m.ResetVendor()
		return nil
	case servercomponent.FieldModel:
		m.ResetModel()
		return nil
	case servercomponent.FieldSerial:
		m.ResetSerial()
		return nil
	case servercomponent.FieldServerID:
		m.ResetServerID()
		return nil
	case servercomponent.FieldComponentTypeID:
		m.ResetComponentTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.component_type != nil {
		edges = append(edges, servercomponent.EdgeComponentType)
	}
	if m.server != nil {
		edges = append(edges, servercomponent.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servercomponent.EdgeComponentType:
		if id := m.component_type; id != nil {
			return []ent.Value{*id}
		}
	case servercomponent.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomponent_type {
		edges = append(edges, servercomponent.EdgeComponentType)
	}
	if m.clearedserver {
		edges = append(edges, servercomponent.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case servercomponent.EdgeComponentType:
		return m.clearedcomponent_type
	case servercomponent.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerComponentMutation) ClearEdge(name string) error {
	switch name {
	case servercomponent.EdgeComponentType:
		m.ClearComponentType()
		return nil
	case servercomponent.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerComponentMutation) ResetEdge(name string) error {
	switch name {
	case servercomponent.EdgeComponentType:
		m.ResetComponentType()
		return nil
	case servercomponent.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown ServerComponent edge %s", name)
}

// ServerComponentTypeMutation represents an operation that mutates the ServerComponentType nodes in the graph.
type ServerComponentTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ServerComponentType, error)
	predicates    []predicate.ServerComponentType
}

var _ ent.Mutation = (*ServerComponentTypeMutation)(nil)

// servercomponenttypeOption allows management of the mutation configuration using functional options.
type servercomponenttypeOption func(*ServerComponentTypeMutation)

// newServerComponentTypeMutation creates new mutation for the ServerComponentType entity.
func newServerComponentTypeMutation(c config, op Op, opts ...servercomponenttypeOption) *ServerComponentTypeMutation {
	m := &ServerComponentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerComponentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerComponentTypeID sets the ID field of the mutation.
func withServerComponentTypeID(id gidx.PrefixedID) servercomponenttypeOption {
	return func(m *ServerComponentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerComponentType
		)
		m.oldValue = func(ctx context.Context) (*ServerComponentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerComponentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerComponentType sets the old ServerComponentType of the mutation.
func withServerComponentType(node *ServerComponentType) servercomponenttypeOption {
	return func(m *ServerComponentTypeMutation) {
		m.oldValue = func(context.Context) (*ServerComponentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerComponentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerComponentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerComponentType entities.
func (m *ServerComponentTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerComponentTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerComponentTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerComponentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerComponentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerComponentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerComponentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerComponentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerComponentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerComponentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerComponentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerComponentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerComponentType entity.
// If the ServerComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerComponentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerComponentTypeMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the ServerComponentTypeMutation builder.
func (m *ServerComponentTypeMutation) Where(ps ...predicate.ServerComponentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerComponentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerComponentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerComponentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerComponentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerComponentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerComponentType).
func (m *ServerComponentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerComponentTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, servercomponenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servercomponenttype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servercomponenttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerComponentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		return m.CreatedAt()
	case servercomponenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servercomponenttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerComponentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servercomponenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servercomponenttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ServerComponentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servercomponenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servercomponenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ServerComponentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerComponentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerComponentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerComponentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerComponentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerComponentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerComponentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerComponentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerComponentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerComponentTypeMutation) ResetField(name string) error {
	switch name {
	case servercomponenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servercomponenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servercomponenttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ServerComponentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerComponentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerComponentTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerComponentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerComponentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerComponentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerComponentTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerComponentTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServerComponentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerComponentTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServerComponentType edge %s", name)
}

// ServerHardDriveMutation represents an operation that mutates the ServerHardDrive nodes in the graph.
type ServerHardDriveMutation struct {
	config
	op                            Op
	typ                           string
	id                            *gidx.PrefixedID
	created_at                    *time.Time
	updated_at                    *time.Time
	serial                        *string
	clearedFields                 map[string]struct{}
	server                        *gidx.PrefixedID
	clearedserver                 bool
	server_hard_drive_type        *gidx.PrefixedID
	clearedserver_hard_drive_type bool
	done                          bool
	oldValue                      func(context.Context) (*ServerHardDrive, error)
	predicates                    []predicate.ServerHardDrive
}

var _ ent.Mutation = (*ServerHardDriveMutation)(nil)

// serverharddriveOption allows management of the mutation configuration using functional options.
type serverharddriveOption func(*ServerHardDriveMutation)

// newServerHardDriveMutation creates new mutation for the ServerHardDrive entity.
func newServerHardDriveMutation(c config, op Op, opts ...serverharddriveOption) *ServerHardDriveMutation {
	m := &ServerHardDriveMutation{
		config:        c,
		op:            op,
		typ:           TypeServerHardDrive,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerHardDriveID sets the ID field of the mutation.
func withServerHardDriveID(id gidx.PrefixedID) serverharddriveOption {
	return func(m *ServerHardDriveMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerHardDrive
		)
		m.oldValue = func(ctx context.Context) (*ServerHardDrive, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerHardDrive.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerHardDrive sets the old ServerHardDrive of the mutation.
func withServerHardDrive(node *ServerHardDrive) serverharddriveOption {
	return func(m *ServerHardDriveMutation) {
		m.oldValue = func(context.Context) (*ServerHardDrive, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerHardDriveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerHardDriveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerHardDrive entities.
func (m *ServerHardDriveMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerHardDriveMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerHardDriveMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerHardDrive.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerHardDriveMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerHardDriveMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerHardDrive entity.
// If the ServerHardDrive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerHardDriveMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerHardDriveMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerHardDriveMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerHardDrive entity.
// If the ServerHardDrive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerHardDriveMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSerial sets the "serial" field.
func (m *ServerHardDriveMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerHardDriveMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerHardDrive entity.
// If the ServerHardDrive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerHardDriveMutation) ResetSerial() {
	m.serial = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerHardDriveMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerHardDriveMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerHardDrive entity.
// If the ServerHardDrive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerHardDriveMutation) ResetServerID() {
	m.server = nil
}

// SetServerHardDriveTypeID sets the "server_hard_drive_type_id" field.
func (m *ServerHardDriveMutation) SetServerHardDriveTypeID(gi gidx.PrefixedID) {
	m.server_hard_drive_type = &gi
}

// ServerHardDriveTypeID returns the value of the "server_hard_drive_type_id" field in the mutation.
func (m *ServerHardDriveMutation) ServerHardDriveTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_hard_drive_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerHardDriveTypeID returns the old "server_hard_drive_type_id" field's value of the ServerHardDrive entity.
// If the ServerHardDrive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveMutation) OldServerHardDriveTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerHardDriveTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerHardDriveTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerHardDriveTypeID: %w", err)
	}
	return oldValue.ServerHardDriveTypeID, nil
}

// ResetServerHardDriveTypeID resets all changes to the "server_hard_drive_type_id" field.
func (m *ServerHardDriveMutation) ResetServerHardDriveTypeID() {
	m.server_hard_drive_type = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerHardDriveMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerHardDriveMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerHardDriveMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerHardDriveMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerHardDriveType clears the "server_hard_drive_type" edge to the ServerHardDriveType entity.
func (m *ServerHardDriveMutation) ClearServerHardDriveType() {
	m.clearedserver_hard_drive_type = true
}

// ServerHardDriveTypeCleared reports if the "server_hard_drive_type" edge to the ServerHardDriveType entity was cleared.
func (m *ServerHardDriveMutation) ServerHardDriveTypeCleared() bool {
	return m.clearedserver_hard_drive_type
}

// ServerHardDriveTypeIDs returns the "server_hard_drive_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerHardDriveTypeID instead. It exists only for internal usage by the builders.
func (m *ServerHardDriveMutation) ServerHardDriveTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_hard_drive_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerHardDriveType resets all changes to the "server_hard_drive_type" edge.
func (m *ServerHardDriveMutation) ResetServerHardDriveType() {
	m.server_hard_drive_type = nil
	m.clearedserver_hard_drive_type = false
}

// Where appends a list predicates to the ServerHardDriveMutation builder.
func (m *ServerHardDriveMutation) Where(ps ...predicate.ServerHardDrive) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerHardDriveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerHardDriveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerHardDrive, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerHardDriveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerHardDriveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerHardDrive).
func (m *ServerHardDriveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerHardDriveMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, serverharddrive.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverharddrive.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, serverharddrive.FieldSerial)
	}
	if m.server != nil {
		fields = append(fields, serverharddrive.FieldServerID)
	}
	if m.server_hard_drive_type != nil {
		fields = append(fields, serverharddrive.FieldServerHardDriveTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerHardDriveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverharddrive.FieldCreatedAt:
		return m.CreatedAt()
	case serverharddrive.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverharddrive.FieldSerial:
		return m.Serial()
	case serverharddrive.FieldServerID:
		return m.ServerID()
	case serverharddrive.FieldServerHardDriveTypeID:
		return m.ServerHardDriveTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerHardDriveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverharddrive.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverharddrive.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverharddrive.FieldSerial:
		return m.OldSerial(ctx)
	case serverharddrive.FieldServerID:
		return m.OldServerID(ctx)
	case serverharddrive.FieldServerHardDriveTypeID:
		return m.OldServerHardDriveTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerHardDrive field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerHardDriveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverharddrive.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverharddrive.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverharddrive.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case serverharddrive.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case serverharddrive.FieldServerHardDriveTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerHardDriveTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerHardDrive field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerHardDriveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerHardDriveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerHardDriveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerHardDrive numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerHardDriveMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerHardDriveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerHardDriveMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerHardDrive nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerHardDriveMutation) ResetField(name string) error {
	switch name {
	case serverharddrive.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverharddrive.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverharddrive.FieldSerial:
		m.ResetSerial()
		return nil
	case serverharddrive.FieldServerID:
		m.ResetServerID()
		return nil
	case serverharddrive.FieldServerHardDriveTypeID:
		m.ResetServerHardDriveTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerHardDrive field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerHardDriveMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, serverharddrive.EdgeServer)
	}
	if m.server_hard_drive_type != nil {
		edges = append(edges, serverharddrive.EdgeServerHardDriveType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerHardDriveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverharddrive.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case serverharddrive.EdgeServerHardDriveType:
		if id := m.server_hard_drive_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerHardDriveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerHardDriveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerHardDriveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, serverharddrive.EdgeServer)
	}
	if m.clearedserver_hard_drive_type {
		edges = append(edges, serverharddrive.EdgeServerHardDriveType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerHardDriveMutation) EdgeCleared(name string) bool {
	switch name {
	case serverharddrive.EdgeServer:
		return m.clearedserver
	case serverharddrive.EdgeServerHardDriveType:
		return m.clearedserver_hard_drive_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerHardDriveMutation) ClearEdge(name string) error {
	switch name {
	case serverharddrive.EdgeServer:
		m.ClearServer()
		return nil
	case serverharddrive.EdgeServerHardDriveType:
		m.ClearServerHardDriveType()
		return nil
	}
	return fmt.Errorf("unknown ServerHardDrive unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerHardDriveMutation) ResetEdge(name string) error {
	switch name {
	case serverharddrive.EdgeServer:
		m.ResetServer()
		return nil
	case serverharddrive.EdgeServerHardDriveType:
		m.ResetServerHardDriveType()
		return nil
	}
	return fmt.Errorf("unknown ServerHardDrive edge %s", name)
}

// ServerHardDriveTypeMutation represents an operation that mutates the ServerHardDriveType nodes in the graph.
type ServerHardDriveTypeMutation struct {
	config
	op                Op
	typ               string
	id                *gidx.PrefixedID
	created_at        *time.Time
	updated_at        *time.Time
	vendor            *string
	model             *string
	speed             *string
	_type             *serverharddrivetype.Type
	capacity          *string
	clearedFields     map[string]struct{}
	hard_drive        map[gidx.PrefixedID]struct{}
	removedhard_drive map[gidx.PrefixedID]struct{}
	clearedhard_drive bool
	done              bool
	oldValue          func(context.Context) (*ServerHardDriveType, error)
	predicates        []predicate.ServerHardDriveType
}

var _ ent.Mutation = (*ServerHardDriveTypeMutation)(nil)

// serverharddrivetypeOption allows management of the mutation configuration using functional options.
type serverharddrivetypeOption func(*ServerHardDriveTypeMutation)

// newServerHardDriveTypeMutation creates new mutation for the ServerHardDriveType entity.
func newServerHardDriveTypeMutation(c config, op Op, opts ...serverharddrivetypeOption) *ServerHardDriveTypeMutation {
	m := &ServerHardDriveTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerHardDriveType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerHardDriveTypeID sets the ID field of the mutation.
func withServerHardDriveTypeID(id gidx.PrefixedID) serverharddrivetypeOption {
	return func(m *ServerHardDriveTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerHardDriveType
		)
		m.oldValue = func(ctx context.Context) (*ServerHardDriveType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerHardDriveType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerHardDriveType sets the old ServerHardDriveType of the mutation.
func withServerHardDriveType(node *ServerHardDriveType) serverharddrivetypeOption {
	return func(m *ServerHardDriveTypeMutation) {
		m.oldValue = func(context.Context) (*ServerHardDriveType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerHardDriveTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerHardDriveTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerHardDriveType entities.
func (m *ServerHardDriveTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerHardDriveTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerHardDriveTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerHardDriveType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerHardDriveTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerHardDriveTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerHardDriveTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerHardDriveTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerHardDriveTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerHardDriveTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerHardDriveTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerHardDriveTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerHardDriveTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerHardDriveTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerHardDriveTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerHardDriveTypeMutation) ResetModel() {
	m.model = nil
}

// SetSpeed sets the "speed" field.
func (m *ServerHardDriveTypeMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *ServerHardDriveTypeMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *ServerHardDriveTypeMutation) ResetSpeed() {
	m.speed = nil
}

// SetType sets the "type" field.
func (m *ServerHardDriveTypeMutation) SetType(s serverharddrivetype.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServerHardDriveTypeMutation) GetType() (r serverharddrivetype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldType(ctx context.Context) (v serverharddrivetype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServerHardDriveTypeMutation) ResetType() {
	m._type = nil
}

// SetCapacity sets the "capacity" field.
func (m *ServerHardDriveTypeMutation) SetCapacity(s string) {
	m.capacity = &s
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *ServerHardDriveTypeMutation) Capacity() (r string, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the ServerHardDriveType entity.
// If the ServerHardDriveType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerHardDriveTypeMutation) OldCapacity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *ServerHardDriveTypeMutation) ResetCapacity() {
	m.capacity = nil
}

// AddHardDriveIDs adds the "hard_drive" edge to the ServerHardDrive entity by ids.
func (m *ServerHardDriveTypeMutation) AddHardDriveIDs(ids ...gidx.PrefixedID) {
	if m.hard_drive == nil {
		m.hard_drive = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.hard_drive[ids[i]] = struct{}{}
	}
}

// ClearHardDrive clears the "hard_drive" edge to the ServerHardDrive entity.
func (m *ServerHardDriveTypeMutation) ClearHardDrive() {
	m.clearedhard_drive = true
}

// HardDriveCleared reports if the "hard_drive" edge to the ServerHardDrive entity was cleared.
func (m *ServerHardDriveTypeMutation) HardDriveCleared() bool {
	return m.clearedhard_drive
}

// RemoveHardDriveIDs removes the "hard_drive" edge to the ServerHardDrive entity by IDs.
func (m *ServerHardDriveTypeMutation) RemoveHardDriveIDs(ids ...gidx.PrefixedID) {
	if m.removedhard_drive == nil {
		m.removedhard_drive = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.hard_drive, ids[i])
		m.removedhard_drive[ids[i]] = struct{}{}
	}
}

// RemovedHardDrive returns the removed IDs of the "hard_drive" edge to the ServerHardDrive entity.
func (m *ServerHardDriveTypeMutation) RemovedHardDriveIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedhard_drive {
		ids = append(ids, id)
	}
	return
}

// HardDriveIDs returns the "hard_drive" edge IDs in the mutation.
func (m *ServerHardDriveTypeMutation) HardDriveIDs() (ids []gidx.PrefixedID) {
	for id := range m.hard_drive {
		ids = append(ids, id)
	}
	return
}

// ResetHardDrive resets all changes to the "hard_drive" edge.
func (m *ServerHardDriveTypeMutation) ResetHardDrive() {
	m.hard_drive = nil
	m.clearedhard_drive = false
	m.removedhard_drive = nil
}

// Where appends a list predicates to the ServerHardDriveTypeMutation builder.
func (m *ServerHardDriveTypeMutation) Where(ps ...predicate.ServerHardDriveType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerHardDriveTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerHardDriveTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerHardDriveType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerHardDriveTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerHardDriveTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerHardDriveType).
func (m *ServerHardDriveTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerHardDriveTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, serverharddrivetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverharddrivetype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, serverharddrivetype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, serverharddrivetype.FieldModel)
	}
	if m.speed != nil {
		fields = append(fields, serverharddrivetype.FieldSpeed)
	}
	if m._type != nil {
		fields = append(fields, serverharddrivetype.FieldType)
	}
	if m.capacity != nil {
		fields = append(fields, serverharddrivetype.FieldCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerHardDriveTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverharddrivetype.FieldCreatedAt:
		return m.CreatedAt()
	case serverharddrivetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverharddrivetype.FieldVendor:
		return m.Vendor()
	case serverharddrivetype.FieldModel:
		return m.Model()
	case serverharddrivetype.FieldSpeed:
		return m.Speed()
	case serverharddrivetype.FieldType:
		return m.GetType()
	case serverharddrivetype.FieldCapacity:
		return m.Capacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerHardDriveTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverharddrivetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverharddrivetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverharddrivetype.FieldVendor:
		return m.OldVendor(ctx)
	case serverharddrivetype.FieldModel:
		return m.OldModel(ctx)
	case serverharddrivetype.FieldSpeed:
		return m.OldSpeed(ctx)
	case serverharddrivetype.FieldType:
		return m.OldType(ctx)
	case serverharddrivetype.FieldCapacity:
		return m.OldCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown ServerHardDriveType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerHardDriveTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverharddrivetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverharddrivetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverharddrivetype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case serverharddrivetype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case serverharddrivetype.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case serverharddrivetype.FieldType:
		v, ok := value.(serverharddrivetype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case serverharddrivetype.FieldCapacity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown ServerHardDriveType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerHardDriveTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerHardDriveTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerHardDriveTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerHardDriveType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerHardDriveTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerHardDriveTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerHardDriveTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerHardDriveType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerHardDriveTypeMutation) ResetField(name string) error {
	switch name {
	case serverharddrivetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverharddrivetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverharddrivetype.FieldVendor:
		m.ResetVendor()
		return nil
	case serverharddrivetype.FieldModel:
		m.ResetModel()
		return nil
	case serverharddrivetype.FieldSpeed:
		m.ResetSpeed()
		return nil
	case serverharddrivetype.FieldType:
		m.ResetType()
		return nil
	case serverharddrivetype.FieldCapacity:
		m.ResetCapacity()
		return nil
	}
	return fmt.Errorf("unknown ServerHardDriveType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerHardDriveTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hard_drive != nil {
		edges = append(edges, serverharddrivetype.EdgeHardDrive)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerHardDriveTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverharddrivetype.EdgeHardDrive:
		ids := make([]ent.Value, 0, len(m.hard_drive))
		for id := range m.hard_drive {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerHardDriveTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhard_drive != nil {
		edges = append(edges, serverharddrivetype.EdgeHardDrive)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerHardDriveTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serverharddrivetype.EdgeHardDrive:
		ids := make([]ent.Value, 0, len(m.removedhard_drive))
		for id := range m.removedhard_drive {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerHardDriveTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhard_drive {
		edges = append(edges, serverharddrivetype.EdgeHardDrive)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerHardDriveTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case serverharddrivetype.EdgeHardDrive:
		return m.clearedhard_drive
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerHardDriveTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerHardDriveType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerHardDriveTypeMutation) ResetEdge(name string) error {
	switch name {
	case serverharddrivetype.EdgeHardDrive:
		m.ResetHardDrive()
		return nil
	}
	return fmt.Errorf("unknown ServerHardDriveType edge %s", name)
}

// ServerMemoryMutation represents an operation that mutates the ServerMemory nodes in the graph.
type ServerMemoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *gidx.PrefixedID
	created_at                *time.Time
	updated_at                *time.Time
	serial                    *string
	clearedFields             map[string]struct{}
	server                    *gidx.PrefixedID
	clearedserver             bool
	server_memory_type        *gidx.PrefixedID
	clearedserver_memory_type bool
	done                      bool
	oldValue                  func(context.Context) (*ServerMemory, error)
	predicates                []predicate.ServerMemory
}

var _ ent.Mutation = (*ServerMemoryMutation)(nil)

// servermemoryOption allows management of the mutation configuration using functional options.
type servermemoryOption func(*ServerMemoryMutation)

// newServerMemoryMutation creates new mutation for the ServerMemory entity.
func newServerMemoryMutation(c config, op Op, opts ...servermemoryOption) *ServerMemoryMutation {
	m := &ServerMemoryMutation{
		config:        c,
		op:            op,
		typ:           TypeServerMemory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerMemoryID sets the ID field of the mutation.
func withServerMemoryID(id gidx.PrefixedID) servermemoryOption {
	return func(m *ServerMemoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerMemory
		)
		m.oldValue = func(ctx context.Context) (*ServerMemory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerMemory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerMemory sets the old ServerMemory of the mutation.
func withServerMemory(node *ServerMemory) servermemoryOption {
	return func(m *ServerMemoryMutation) {
		m.oldValue = func(context.Context) (*ServerMemory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMemoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMemoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerMemory entities.
func (m *ServerMemoryMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMemoryMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMemoryMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerMemory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMemoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMemoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerMemory entity.
// If the ServerMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMemoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMemoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMemoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerMemory entity.
// If the ServerMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMemoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSerial sets the "serial" field.
func (m *ServerMemoryMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerMemoryMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerMemory entity.
// If the ServerMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerMemoryMutation) ResetSerial() {
	m.serial = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerMemoryMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerMemoryMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerMemory entity.
// If the ServerMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerMemoryMutation) ResetServerID() {
	m.server = nil
}

// SetServerMemoryTypeID sets the "server_memory_type_id" field.
func (m *ServerMemoryMutation) SetServerMemoryTypeID(gi gidx.PrefixedID) {
	m.server_memory_type = &gi
}

// ServerMemoryTypeID returns the value of the "server_memory_type_id" field in the mutation.
func (m *ServerMemoryMutation) ServerMemoryTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_memory_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerMemoryTypeID returns the old "server_memory_type_id" field's value of the ServerMemory entity.
// If the ServerMemory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryMutation) OldServerMemoryTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerMemoryTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerMemoryTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerMemoryTypeID: %w", err)
	}
	return oldValue.ServerMemoryTypeID, nil
}

// ResetServerMemoryTypeID resets all changes to the "server_memory_type_id" field.
func (m *ServerMemoryMutation) ResetServerMemoryTypeID() {
	m.server_memory_type = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerMemoryMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerMemoryMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerMemoryMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerMemoryMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerMemoryType clears the "server_memory_type" edge to the ServerMemoryType entity.
func (m *ServerMemoryMutation) ClearServerMemoryType() {
	m.clearedserver_memory_type = true
}

// ServerMemoryTypeCleared reports if the "server_memory_type" edge to the ServerMemoryType entity was cleared.
func (m *ServerMemoryMutation) ServerMemoryTypeCleared() bool {
	return m.clearedserver_memory_type
}

// ServerMemoryTypeIDs returns the "server_memory_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerMemoryTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMemoryMutation) ServerMemoryTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_memory_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerMemoryType resets all changes to the "server_memory_type" edge.
func (m *ServerMemoryMutation) ResetServerMemoryType() {
	m.server_memory_type = nil
	m.clearedserver_memory_type = false
}

// Where appends a list predicates to the ServerMemoryMutation builder.
func (m *ServerMemoryMutation) Where(ps ...predicate.ServerMemory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMemoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMemoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerMemory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMemoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMemoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerMemory).
func (m *ServerMemoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMemoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, servermemory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servermemory.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, servermemory.FieldSerial)
	}
	if m.server != nil {
		fields = append(fields, servermemory.FieldServerID)
	}
	if m.server_memory_type != nil {
		fields = append(fields, servermemory.FieldServerMemoryTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMemoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servermemory.FieldCreatedAt:
		return m.CreatedAt()
	case servermemory.FieldUpdatedAt:
		return m.UpdatedAt()
	case servermemory.FieldSerial:
		return m.Serial()
	case servermemory.FieldServerID:
		return m.ServerID()
	case servermemory.FieldServerMemoryTypeID:
		return m.ServerMemoryTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMemoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servermemory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servermemory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servermemory.FieldSerial:
		return m.OldSerial(ctx)
	case servermemory.FieldServerID:
		return m.OldServerID(ctx)
	case servermemory.FieldServerMemoryTypeID:
		return m.OldServerMemoryTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerMemory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMemoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servermemory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servermemory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servermemory.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case servermemory.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case servermemory.FieldServerMemoryTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerMemoryTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerMemory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMemoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMemoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMemoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMemory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMemoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMemoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMemoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerMemory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMemoryMutation) ResetField(name string) error {
	switch name {
	case servermemory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servermemory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servermemory.FieldSerial:
		m.ResetSerial()
		return nil
	case servermemory.FieldServerID:
		m.ResetServerID()
		return nil
	case servermemory.FieldServerMemoryTypeID:
		m.ResetServerMemoryTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerMemory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMemoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, servermemory.EdgeServer)
	}
	if m.server_memory_type != nil {
		edges = append(edges, servermemory.EdgeServerMemoryType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMemoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servermemory.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case servermemory.EdgeServerMemoryType:
		if id := m.server_memory_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMemoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMemoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMemoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, servermemory.EdgeServer)
	}
	if m.clearedserver_memory_type {
		edges = append(edges, servermemory.EdgeServerMemoryType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMemoryMutation) EdgeCleared(name string) bool {
	switch name {
	case servermemory.EdgeServer:
		return m.clearedserver
	case servermemory.EdgeServerMemoryType:
		return m.clearedserver_memory_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMemoryMutation) ClearEdge(name string) error {
	switch name {
	case servermemory.EdgeServer:
		m.ClearServer()
		return nil
	case servermemory.EdgeServerMemoryType:
		m.ClearServerMemoryType()
		return nil
	}
	return fmt.Errorf("unknown ServerMemory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMemoryMutation) ResetEdge(name string) error {
	switch name {
	case servermemory.EdgeServer:
		m.ResetServer()
		return nil
	case servermemory.EdgeServerMemoryType:
		m.ResetServerMemoryType()
		return nil
	}
	return fmt.Errorf("unknown ServerMemory edge %s", name)
}

// ServerMemoryTypeMutation represents an operation that mutates the ServerMemoryType nodes in the graph.
type ServerMemoryTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	vendor        *string
	model         *string
	speed         *string
	size          *string
	clearedFields map[string]struct{}
	memory        map[gidx.PrefixedID]struct{}
	removedmemory map[gidx.PrefixedID]struct{}
	clearedmemory bool
	done          bool
	oldValue      func(context.Context) (*ServerMemoryType, error)
	predicates    []predicate.ServerMemoryType
}

var _ ent.Mutation = (*ServerMemoryTypeMutation)(nil)

// servermemorytypeOption allows management of the mutation configuration using functional options.
type servermemorytypeOption func(*ServerMemoryTypeMutation)

// newServerMemoryTypeMutation creates new mutation for the ServerMemoryType entity.
func newServerMemoryTypeMutation(c config, op Op, opts ...servermemorytypeOption) *ServerMemoryTypeMutation {
	m := &ServerMemoryTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerMemoryType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerMemoryTypeID sets the ID field of the mutation.
func withServerMemoryTypeID(id gidx.PrefixedID) servermemorytypeOption {
	return func(m *ServerMemoryTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerMemoryType
		)
		m.oldValue = func(ctx context.Context) (*ServerMemoryType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerMemoryType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerMemoryType sets the old ServerMemoryType of the mutation.
func withServerMemoryType(node *ServerMemoryType) servermemorytypeOption {
	return func(m *ServerMemoryTypeMutation) {
		m.oldValue = func(context.Context) (*ServerMemoryType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMemoryTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMemoryTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerMemoryType entities.
func (m *ServerMemoryTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMemoryTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMemoryTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerMemoryType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMemoryTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMemoryTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMemoryTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMemoryTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMemoryTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMemoryTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerMemoryTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerMemoryTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerMemoryTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerMemoryTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerMemoryTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerMemoryTypeMutation) ResetModel() {
	m.model = nil
}

// SetSpeed sets the "speed" field.
func (m *ServerMemoryTypeMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *ServerMemoryTypeMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *ServerMemoryTypeMutation) ResetSpeed() {
	m.speed = nil
}

// SetSize sets the "size" field.
func (m *ServerMemoryTypeMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *ServerMemoryTypeMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the ServerMemoryType entity.
// If the ServerMemoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMemoryTypeMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *ServerMemoryTypeMutation) ResetSize() {
	m.size = nil
}

// AddMemoryIDs adds the "memory" edge to the ServerMemory entity by ids.
func (m *ServerMemoryTypeMutation) AddMemoryIDs(ids ...gidx.PrefixedID) {
	if m.memory == nil {
		m.memory = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.memory[ids[i]] = struct{}{}
	}
}

// ClearMemory clears the "memory" edge to the ServerMemory entity.
func (m *ServerMemoryTypeMutation) ClearMemory() {
	m.clearedmemory = true
}

// MemoryCleared reports if the "memory" edge to the ServerMemory entity was cleared.
func (m *ServerMemoryTypeMutation) MemoryCleared() bool {
	return m.clearedmemory
}

// RemoveMemoryIDs removes the "memory" edge to the ServerMemory entity by IDs.
func (m *ServerMemoryTypeMutation) RemoveMemoryIDs(ids ...gidx.PrefixedID) {
	if m.removedmemory == nil {
		m.removedmemory = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.memory, ids[i])
		m.removedmemory[ids[i]] = struct{}{}
	}
}

// RemovedMemory returns the removed IDs of the "memory" edge to the ServerMemory entity.
func (m *ServerMemoryTypeMutation) RemovedMemoryIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedmemory {
		ids = append(ids, id)
	}
	return
}

// MemoryIDs returns the "memory" edge IDs in the mutation.
func (m *ServerMemoryTypeMutation) MemoryIDs() (ids []gidx.PrefixedID) {
	for id := range m.memory {
		ids = append(ids, id)
	}
	return
}

// ResetMemory resets all changes to the "memory" edge.
func (m *ServerMemoryTypeMutation) ResetMemory() {
	m.memory = nil
	m.clearedmemory = false
	m.removedmemory = nil
}

// Where appends a list predicates to the ServerMemoryTypeMutation builder.
func (m *ServerMemoryTypeMutation) Where(ps ...predicate.ServerMemoryType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMemoryTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMemoryTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerMemoryType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMemoryTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMemoryTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerMemoryType).
func (m *ServerMemoryTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMemoryTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, servermemorytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servermemorytype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, servermemorytype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servermemorytype.FieldModel)
	}
	if m.speed != nil {
		fields = append(fields, servermemorytype.FieldSpeed)
	}
	if m.size != nil {
		fields = append(fields, servermemorytype.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMemoryTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servermemorytype.FieldCreatedAt:
		return m.CreatedAt()
	case servermemorytype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servermemorytype.FieldVendor:
		return m.Vendor()
	case servermemorytype.FieldModel:
		return m.Model()
	case servermemorytype.FieldSpeed:
		return m.Speed()
	case servermemorytype.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMemoryTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servermemorytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servermemorytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servermemorytype.FieldVendor:
		return m.OldVendor(ctx)
	case servermemorytype.FieldModel:
		return m.OldModel(ctx)
	case servermemorytype.FieldSpeed:
		return m.OldSpeed(ctx)
	case servermemorytype.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown ServerMemoryType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMemoryTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servermemorytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servermemorytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servermemorytype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servermemorytype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servermemorytype.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case servermemorytype.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown ServerMemoryType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMemoryTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMemoryTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMemoryTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMemoryType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMemoryTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMemoryTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMemoryTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerMemoryType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMemoryTypeMutation) ResetField(name string) error {
	switch name {
	case servermemorytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servermemorytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servermemorytype.FieldVendor:
		m.ResetVendor()
		return nil
	case servermemorytype.FieldModel:
		m.ResetModel()
		return nil
	case servermemorytype.FieldSpeed:
		m.ResetSpeed()
		return nil
	case servermemorytype.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown ServerMemoryType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMemoryTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.memory != nil {
		edges = append(edges, servermemorytype.EdgeMemory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMemoryTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servermemorytype.EdgeMemory:
		ids := make([]ent.Value, 0, len(m.memory))
		for id := range m.memory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMemoryTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmemory != nil {
		edges = append(edges, servermemorytype.EdgeMemory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMemoryTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servermemorytype.EdgeMemory:
		ids := make([]ent.Value, 0, len(m.removedmemory))
		for id := range m.removedmemory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMemoryTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmemory {
		edges = append(edges, servermemorytype.EdgeMemory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMemoryTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servermemorytype.EdgeMemory:
		return m.clearedmemory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMemoryTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMemoryType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMemoryTypeMutation) ResetEdge(name string) error {
	switch name {
	case servermemorytype.EdgeMemory:
		m.ResetMemory()
		return nil
	}
	return fmt.Errorf("unknown ServerMemoryType edge %s", name)
}

// ServerMotherboardMutation represents an operation that mutates the ServerMotherboard nodes in the graph.
type ServerMotherboardMutation struct {
	config
	op                             Op
	typ                            string
	id                             *gidx.PrefixedID
	created_at                     *time.Time
	updated_at                     *time.Time
	serial                         *string
	clearedFields                  map[string]struct{}
	server                         *gidx.PrefixedID
	clearedserver                  bool
	server_motherboard_type        *gidx.PrefixedID
	clearedserver_motherboard_type bool
	done                           bool
	oldValue                       func(context.Context) (*ServerMotherboard, error)
	predicates                     []predicate.ServerMotherboard
}

var _ ent.Mutation = (*ServerMotherboardMutation)(nil)

// servermotherboardOption allows management of the mutation configuration using functional options.
type servermotherboardOption func(*ServerMotherboardMutation)

// newServerMotherboardMutation creates new mutation for the ServerMotherboard entity.
func newServerMotherboardMutation(c config, op Op, opts ...servermotherboardOption) *ServerMotherboardMutation {
	m := &ServerMotherboardMutation{
		config:        c,
		op:            op,
		typ:           TypeServerMotherboard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerMotherboardID sets the ID field of the mutation.
func withServerMotherboardID(id gidx.PrefixedID) servermotherboardOption {
	return func(m *ServerMotherboardMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerMotherboard
		)
		m.oldValue = func(ctx context.Context) (*ServerMotherboard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerMotherboard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerMotherboard sets the old ServerMotherboard of the mutation.
func withServerMotherboard(node *ServerMotherboard) servermotherboardOption {
	return func(m *ServerMotherboardMutation) {
		m.oldValue = func(context.Context) (*ServerMotherboard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMotherboardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMotherboardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerMotherboard entities.
func (m *ServerMotherboardMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMotherboardMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMotherboardMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerMotherboard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMotherboardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMotherboardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerMotherboard entity.
// If the ServerMotherboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMotherboardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMotherboardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMotherboardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerMotherboard entity.
// If the ServerMotherboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMotherboardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSerial sets the "serial" field.
func (m *ServerMotherboardMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerMotherboardMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerMotherboard entity.
// If the ServerMotherboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerMotherboardMutation) ResetSerial() {
	m.serial = nil
}

// SetServerMotherboardTypeID sets the "server_motherboard_type_id" field.
func (m *ServerMotherboardMutation) SetServerMotherboardTypeID(gi gidx.PrefixedID) {
	m.server_motherboard_type = &gi
}

// ServerMotherboardTypeID returns the value of the "server_motherboard_type_id" field in the mutation.
func (m *ServerMotherboardMutation) ServerMotherboardTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_motherboard_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerMotherboardTypeID returns the old "server_motherboard_type_id" field's value of the ServerMotherboard entity.
// If the ServerMotherboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardMutation) OldServerMotherboardTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerMotherboardTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerMotherboardTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerMotherboardTypeID: %w", err)
	}
	return oldValue.ServerMotherboardTypeID, nil
}

// ResetServerMotherboardTypeID resets all changes to the "server_motherboard_type_id" field.
func (m *ServerMotherboardMutation) ResetServerMotherboardTypeID() {
	m.server_motherboard_type = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerMotherboardMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerMotherboardMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerMotherboard entity.
// If the ServerMotherboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerMotherboardMutation) ResetServerID() {
	m.server = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerMotherboardMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerMotherboardMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerMotherboardMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerMotherboardMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerMotherboardType clears the "server_motherboard_type" edge to the ServerMotherboardType entity.
func (m *ServerMotherboardMutation) ClearServerMotherboardType() {
	m.clearedserver_motherboard_type = true
}

// ServerMotherboardTypeCleared reports if the "server_motherboard_type" edge to the ServerMotherboardType entity was cleared.
func (m *ServerMotherboardMutation) ServerMotherboardTypeCleared() bool {
	return m.clearedserver_motherboard_type
}

// ServerMotherboardTypeIDs returns the "server_motherboard_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerMotherboardTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMotherboardMutation) ServerMotherboardTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_motherboard_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerMotherboardType resets all changes to the "server_motherboard_type" edge.
func (m *ServerMotherboardMutation) ResetServerMotherboardType() {
	m.server_motherboard_type = nil
	m.clearedserver_motherboard_type = false
}

// Where appends a list predicates to the ServerMotherboardMutation builder.
func (m *ServerMotherboardMutation) Where(ps ...predicate.ServerMotherboard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMotherboardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMotherboardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerMotherboard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMotherboardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMotherboardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerMotherboard).
func (m *ServerMotherboardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMotherboardMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, servermotherboard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servermotherboard.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, servermotherboard.FieldSerial)
	}
	if m.server_motherboard_type != nil {
		fields = append(fields, servermotherboard.FieldServerMotherboardTypeID)
	}
	if m.server != nil {
		fields = append(fields, servermotherboard.FieldServerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMotherboardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servermotherboard.FieldCreatedAt:
		return m.CreatedAt()
	case servermotherboard.FieldUpdatedAt:
		return m.UpdatedAt()
	case servermotherboard.FieldSerial:
		return m.Serial()
	case servermotherboard.FieldServerMotherboardTypeID:
		return m.ServerMotherboardTypeID()
	case servermotherboard.FieldServerID:
		return m.ServerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMotherboardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servermotherboard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servermotherboard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servermotherboard.FieldSerial:
		return m.OldSerial(ctx)
	case servermotherboard.FieldServerMotherboardTypeID:
		return m.OldServerMotherboardTypeID(ctx)
	case servermotherboard.FieldServerID:
		return m.OldServerID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerMotherboard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMotherboardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servermotherboard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servermotherboard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servermotherboard.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case servermotherboard.FieldServerMotherboardTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerMotherboardTypeID(v)
		return nil
	case servermotherboard.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMotherboardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMotherboardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMotherboardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMotherboard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMotherboardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMotherboardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMotherboardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerMotherboard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMotherboardMutation) ResetField(name string) error {
	switch name {
	case servermotherboard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servermotherboard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servermotherboard.FieldSerial:
		m.ResetSerial()
		return nil
	case servermotherboard.FieldServerMotherboardTypeID:
		m.ResetServerMotherboardTypeID()
		return nil
	case servermotherboard.FieldServerID:
		m.ResetServerID()
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMotherboardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, servermotherboard.EdgeServer)
	}
	if m.server_motherboard_type != nil {
		edges = append(edges, servermotherboard.EdgeServerMotherboardType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMotherboardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servermotherboard.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case servermotherboard.EdgeServerMotherboardType:
		if id := m.server_motherboard_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMotherboardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMotherboardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMotherboardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, servermotherboard.EdgeServer)
	}
	if m.clearedserver_motherboard_type {
		edges = append(edges, servermotherboard.EdgeServerMotherboardType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMotherboardMutation) EdgeCleared(name string) bool {
	switch name {
	case servermotherboard.EdgeServer:
		return m.clearedserver
	case servermotherboard.EdgeServerMotherboardType:
		return m.clearedserver_motherboard_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMotherboardMutation) ClearEdge(name string) error {
	switch name {
	case servermotherboard.EdgeServer:
		m.ClearServer()
		return nil
	case servermotherboard.EdgeServerMotherboardType:
		m.ClearServerMotherboardType()
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMotherboardMutation) ResetEdge(name string) error {
	switch name {
	case servermotherboard.EdgeServer:
		m.ResetServer()
		return nil
	case servermotherboard.EdgeServerMotherboardType:
		m.ResetServerMotherboardType()
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboard edge %s", name)
}

// ServerMotherboardTypeMutation represents an operation that mutates the ServerMotherboardType nodes in the graph.
type ServerMotherboardTypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *gidx.PrefixedID
	created_at         *time.Time
	updated_at         *time.Time
	vendor             *string
	model              *string
	clearedFields      map[string]struct{}
	motherboard        map[gidx.PrefixedID]struct{}
	removedmotherboard map[gidx.PrefixedID]struct{}
	clearedmotherboard bool
	done               bool
	oldValue           func(context.Context) (*ServerMotherboardType, error)
	predicates         []predicate.ServerMotherboardType
}

var _ ent.Mutation = (*ServerMotherboardTypeMutation)(nil)

// servermotherboardtypeOption allows management of the mutation configuration using functional options.
type servermotherboardtypeOption func(*ServerMotherboardTypeMutation)

// newServerMotherboardTypeMutation creates new mutation for the ServerMotherboardType entity.
func newServerMotherboardTypeMutation(c config, op Op, opts ...servermotherboardtypeOption) *ServerMotherboardTypeMutation {
	m := &ServerMotherboardTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerMotherboardType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerMotherboardTypeID sets the ID field of the mutation.
func withServerMotherboardTypeID(id gidx.PrefixedID) servermotherboardtypeOption {
	return func(m *ServerMotherboardTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerMotherboardType
		)
		m.oldValue = func(ctx context.Context) (*ServerMotherboardType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerMotherboardType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerMotherboardType sets the old ServerMotherboardType of the mutation.
func withServerMotherboardType(node *ServerMotherboardType) servermotherboardtypeOption {
	return func(m *ServerMotherboardTypeMutation) {
		m.oldValue = func(context.Context) (*ServerMotherboardType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMotherboardTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMotherboardTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerMotherboardType entities.
func (m *ServerMotherboardTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMotherboardTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMotherboardTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerMotherboardType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerMotherboardTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerMotherboardTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerMotherboardType entity.
// If the ServerMotherboardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerMotherboardTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerMotherboardTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerMotherboardTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerMotherboardType entity.
// If the ServerMotherboardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerMotherboardTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerMotherboardTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerMotherboardTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerMotherboardType entity.
// If the ServerMotherboardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerMotherboardTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerMotherboardTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerMotherboardTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerMotherboardType entity.
// If the ServerMotherboardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMotherboardTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerMotherboardTypeMutation) ResetModel() {
	m.model = nil
}

// AddMotherboardIDs adds the "motherboard" edge to the ServerMotherboard entity by ids.
func (m *ServerMotherboardTypeMutation) AddMotherboardIDs(ids ...gidx.PrefixedID) {
	if m.motherboard == nil {
		m.motherboard = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.motherboard[ids[i]] = struct{}{}
	}
}

// ClearMotherboard clears the "motherboard" edge to the ServerMotherboard entity.
func (m *ServerMotherboardTypeMutation) ClearMotherboard() {
	m.clearedmotherboard = true
}

// MotherboardCleared reports if the "motherboard" edge to the ServerMotherboard entity was cleared.
func (m *ServerMotherboardTypeMutation) MotherboardCleared() bool {
	return m.clearedmotherboard
}

// RemoveMotherboardIDs removes the "motherboard" edge to the ServerMotherboard entity by IDs.
func (m *ServerMotherboardTypeMutation) RemoveMotherboardIDs(ids ...gidx.PrefixedID) {
	if m.removedmotherboard == nil {
		m.removedmotherboard = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.motherboard, ids[i])
		m.removedmotherboard[ids[i]] = struct{}{}
	}
}

// RemovedMotherboard returns the removed IDs of the "motherboard" edge to the ServerMotherboard entity.
func (m *ServerMotherboardTypeMutation) RemovedMotherboardIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedmotherboard {
		ids = append(ids, id)
	}
	return
}

// MotherboardIDs returns the "motherboard" edge IDs in the mutation.
func (m *ServerMotherboardTypeMutation) MotherboardIDs() (ids []gidx.PrefixedID) {
	for id := range m.motherboard {
		ids = append(ids, id)
	}
	return
}

// ResetMotherboard resets all changes to the "motherboard" edge.
func (m *ServerMotherboardTypeMutation) ResetMotherboard() {
	m.motherboard = nil
	m.clearedmotherboard = false
	m.removedmotherboard = nil
}

// Where appends a list predicates to the ServerMotherboardTypeMutation builder.
func (m *ServerMotherboardTypeMutation) Where(ps ...predicate.ServerMotherboardType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMotherboardTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMotherboardTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerMotherboardType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMotherboardTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMotherboardTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerMotherboardType).
func (m *ServerMotherboardTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMotherboardTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, servermotherboardtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servermotherboardtype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, servermotherboardtype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servermotherboardtype.FieldModel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMotherboardTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servermotherboardtype.FieldCreatedAt:
		return m.CreatedAt()
	case servermotherboardtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servermotherboardtype.FieldVendor:
		return m.Vendor()
	case servermotherboardtype.FieldModel:
		return m.Model()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMotherboardTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servermotherboardtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servermotherboardtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servermotherboardtype.FieldVendor:
		return m.OldVendor(ctx)
	case servermotherboardtype.FieldModel:
		return m.OldModel(ctx)
	}
	return nil, fmt.Errorf("unknown ServerMotherboardType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMotherboardTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servermotherboardtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servermotherboardtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servermotherboardtype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servermotherboardtype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboardType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMotherboardTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMotherboardTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMotherboardTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMotherboardType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMotherboardTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMotherboardTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMotherboardTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerMotherboardType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMotherboardTypeMutation) ResetField(name string) error {
	switch name {
	case servermotherboardtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servermotherboardtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servermotherboardtype.FieldVendor:
		m.ResetVendor()
		return nil
	case servermotherboardtype.FieldModel:
		m.ResetModel()
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboardType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMotherboardTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.motherboard != nil {
		edges = append(edges, servermotherboardtype.EdgeMotherboard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMotherboardTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servermotherboardtype.EdgeMotherboard:
		ids := make([]ent.Value, 0, len(m.motherboard))
		for id := range m.motherboard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMotherboardTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmotherboard != nil {
		edges = append(edges, servermotherboardtype.EdgeMotherboard)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMotherboardTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servermotherboardtype.EdgeMotherboard:
		ids := make([]ent.Value, 0, len(m.removedmotherboard))
		for id := range m.removedmotherboard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMotherboardTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmotherboard {
		edges = append(edges, servermotherboardtype.EdgeMotherboard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMotherboardTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servermotherboardtype.EdgeMotherboard:
		return m.clearedmotherboard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMotherboardTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerMotherboardType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMotherboardTypeMutation) ResetEdge(name string) error {
	switch name {
	case servermotherboardtype.EdgeMotherboard:
		m.ResetMotherboard()
		return nil
	}
	return fmt.Errorf("unknown ServerMotherboardType edge %s", name)
}

// ServerNetworkCardMutation represents an operation that mutates the ServerNetworkCard nodes in the graph.
type ServerNetworkCardMutation struct {
	config
	op                       Op
	typ                      string
	id                       *gidx.PrefixedID
	created_at               *time.Time
	updated_at               *time.Time
	serial                   *string
	clearedFields            map[string]struct{}
	network_card_type        *gidx.PrefixedID
	clearednetwork_card_type bool
	server                   *gidx.PrefixedID
	clearedserver            bool
	network_port             map[gidx.PrefixedID]struct{}
	removednetwork_port      map[gidx.PrefixedID]struct{}
	clearednetwork_port      bool
	done                     bool
	oldValue                 func(context.Context) (*ServerNetworkCard, error)
	predicates               []predicate.ServerNetworkCard
}

var _ ent.Mutation = (*ServerNetworkCardMutation)(nil)

// servernetworkcardOption allows management of the mutation configuration using functional options.
type servernetworkcardOption func(*ServerNetworkCardMutation)

// newServerNetworkCardMutation creates new mutation for the ServerNetworkCard entity.
func newServerNetworkCardMutation(c config, op Op, opts ...servernetworkcardOption) *ServerNetworkCardMutation {
	m := &ServerNetworkCardMutation{
		config:        c,
		op:            op,
		typ:           TypeServerNetworkCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerNetworkCardID sets the ID field of the mutation.
func withServerNetworkCardID(id gidx.PrefixedID) servernetworkcardOption {
	return func(m *ServerNetworkCardMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerNetworkCard
		)
		m.oldValue = func(ctx context.Context) (*ServerNetworkCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerNetworkCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerNetworkCard sets the old ServerNetworkCard of the mutation.
func withServerNetworkCard(node *ServerNetworkCard) servernetworkcardOption {
	return func(m *ServerNetworkCardMutation) {
		m.oldValue = func(context.Context) (*ServerNetworkCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerNetworkCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerNetworkCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerNetworkCard entities.
func (m *ServerNetworkCardMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerNetworkCardMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerNetworkCardMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerNetworkCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerNetworkCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerNetworkCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerNetworkCard entity.
// If the ServerNetworkCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerNetworkCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerNetworkCardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerNetworkCardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerNetworkCard entity.
// If the ServerNetworkCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerNetworkCardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSerial sets the "serial" field.
func (m *ServerNetworkCardMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerNetworkCardMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerNetworkCard entity.
// If the ServerNetworkCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerNetworkCardMutation) ResetSerial() {
	m.serial = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerNetworkCardMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerNetworkCardMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerNetworkCard entity.
// If the ServerNetworkCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerNetworkCardMutation) ResetServerID() {
	m.server = nil
}

// SetServerNetworkCardTypeID sets the "server_network_card_type_id" field.
func (m *ServerNetworkCardMutation) SetServerNetworkCardTypeID(gi gidx.PrefixedID) {
	m.network_card_type = &gi
}

// ServerNetworkCardTypeID returns the value of the "server_network_card_type_id" field in the mutation.
func (m *ServerNetworkCardMutation) ServerNetworkCardTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.network_card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerNetworkCardTypeID returns the old "server_network_card_type_id" field's value of the ServerNetworkCard entity.
// If the ServerNetworkCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardMutation) OldServerNetworkCardTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerNetworkCardTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerNetworkCardTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerNetworkCardTypeID: %w", err)
	}
	return oldValue.ServerNetworkCardTypeID, nil
}

// ResetServerNetworkCardTypeID resets all changes to the "server_network_card_type_id" field.
func (m *ServerNetworkCardMutation) ResetServerNetworkCardTypeID() {
	m.network_card_type = nil
}

// SetNetworkCardTypeID sets the "network_card_type" edge to the ServerNetworkCardType entity by id.
func (m *ServerNetworkCardMutation) SetNetworkCardTypeID(id gidx.PrefixedID) {
	m.network_card_type = &id
}

// ClearNetworkCardType clears the "network_card_type" edge to the ServerNetworkCardType entity.
func (m *ServerNetworkCardMutation) ClearNetworkCardType() {
	m.clearednetwork_card_type = true
}

// NetworkCardTypeCleared reports if the "network_card_type" edge to the ServerNetworkCardType entity was cleared.
func (m *ServerNetworkCardMutation) NetworkCardTypeCleared() bool {
	return m.clearednetwork_card_type
}

// NetworkCardTypeID returns the "network_card_type" edge ID in the mutation.
func (m *ServerNetworkCardMutation) NetworkCardTypeID() (id gidx.PrefixedID, exists bool) {
	if m.network_card_type != nil {
		return *m.network_card_type, true
	}
	return
}

// NetworkCardTypeIDs returns the "network_card_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkCardTypeID instead. It exists only for internal usage by the builders.
func (m *ServerNetworkCardMutation) NetworkCardTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.network_card_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkCardType resets all changes to the "network_card_type" edge.
func (m *ServerNetworkCardMutation) ResetNetworkCardType() {
	m.network_card_type = nil
	m.clearednetwork_card_type = false
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerNetworkCardMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerNetworkCardMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerNetworkCardMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerNetworkCardMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// AddNetworkPortIDs adds the "network_port" edge to the ServerNetworkPort entity by ids.
func (m *ServerNetworkCardMutation) AddNetworkPortIDs(ids ...gidx.PrefixedID) {
	if m.network_port == nil {
		m.network_port = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.network_port[ids[i]] = struct{}{}
	}
}

// ClearNetworkPort clears the "network_port" edge to the ServerNetworkPort entity.
func (m *ServerNetworkCardMutation) ClearNetworkPort() {
	m.clearednetwork_port = true
}

// NetworkPortCleared reports if the "network_port" edge to the ServerNetworkPort entity was cleared.
func (m *ServerNetworkCardMutation) NetworkPortCleared() bool {
	return m.clearednetwork_port
}

// RemoveNetworkPortIDs removes the "network_port" edge to the ServerNetworkPort entity by IDs.
func (m *ServerNetworkCardMutation) RemoveNetworkPortIDs(ids ...gidx.PrefixedID) {
	if m.removednetwork_port == nil {
		m.removednetwork_port = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.network_port, ids[i])
		m.removednetwork_port[ids[i]] = struct{}{}
	}
}

// RemovedNetworkPort returns the removed IDs of the "network_port" edge to the ServerNetworkPort entity.
func (m *ServerNetworkCardMutation) RemovedNetworkPortIDs() (ids []gidx.PrefixedID) {
	for id := range m.removednetwork_port {
		ids = append(ids, id)
	}
	return
}

// NetworkPortIDs returns the "network_port" edge IDs in the mutation.
func (m *ServerNetworkCardMutation) NetworkPortIDs() (ids []gidx.PrefixedID) {
	for id := range m.network_port {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkPort resets all changes to the "network_port" edge.
func (m *ServerNetworkCardMutation) ResetNetworkPort() {
	m.network_port = nil
	m.clearednetwork_port = false
	m.removednetwork_port = nil
}

// Where appends a list predicates to the ServerNetworkCardMutation builder.
func (m *ServerNetworkCardMutation) Where(ps ...predicate.ServerNetworkCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerNetworkCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerNetworkCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerNetworkCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerNetworkCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerNetworkCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerNetworkCard).
func (m *ServerNetworkCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerNetworkCardMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, servernetworkcard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servernetworkcard.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, servernetworkcard.FieldSerial)
	}
	if m.server != nil {
		fields = append(fields, servernetworkcard.FieldServerID)
	}
	if m.network_card_type != nil {
		fields = append(fields, servernetworkcard.FieldServerNetworkCardTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerNetworkCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servernetworkcard.FieldCreatedAt:
		return m.CreatedAt()
	case servernetworkcard.FieldUpdatedAt:
		return m.UpdatedAt()
	case servernetworkcard.FieldSerial:
		return m.Serial()
	case servernetworkcard.FieldServerID:
		return m.ServerID()
	case servernetworkcard.FieldServerNetworkCardTypeID:
		return m.ServerNetworkCardTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerNetworkCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servernetworkcard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servernetworkcard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servernetworkcard.FieldSerial:
		return m.OldSerial(ctx)
	case servernetworkcard.FieldServerID:
		return m.OldServerID(ctx)
	case servernetworkcard.FieldServerNetworkCardTypeID:
		return m.OldServerNetworkCardTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerNetworkCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servernetworkcard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servernetworkcard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servernetworkcard.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case servernetworkcard.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case servernetworkcard.FieldServerNetworkCardTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerNetworkCardTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerNetworkCardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerNetworkCardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerNetworkCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerNetworkCardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerNetworkCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerNetworkCardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerNetworkCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerNetworkCardMutation) ResetField(name string) error {
	switch name {
	case servernetworkcard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servernetworkcard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servernetworkcard.FieldSerial:
		m.ResetSerial()
		return nil
	case servernetworkcard.FieldServerID:
		m.ResetServerID()
		return nil
	case servernetworkcard.FieldServerNetworkCardTypeID:
		m.ResetServerNetworkCardTypeID()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerNetworkCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.network_card_type != nil {
		edges = append(edges, servernetworkcard.EdgeNetworkCardType)
	}
	if m.server != nil {
		edges = append(edges, servernetworkcard.EdgeServer)
	}
	if m.network_port != nil {
		edges = append(edges, servernetworkcard.EdgeNetworkPort)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerNetworkCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servernetworkcard.EdgeNetworkCardType:
		if id := m.network_card_type; id != nil {
			return []ent.Value{*id}
		}
	case servernetworkcard.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case servernetworkcard.EdgeNetworkPort:
		ids := make([]ent.Value, 0, len(m.network_port))
		for id := range m.network_port {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerNetworkCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednetwork_port != nil {
		edges = append(edges, servernetworkcard.EdgeNetworkPort)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerNetworkCardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servernetworkcard.EdgeNetworkPort:
		ids := make([]ent.Value, 0, len(m.removednetwork_port))
		for id := range m.removednetwork_port {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerNetworkCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednetwork_card_type {
		edges = append(edges, servernetworkcard.EdgeNetworkCardType)
	}
	if m.clearedserver {
		edges = append(edges, servernetworkcard.EdgeServer)
	}
	if m.clearednetwork_port {
		edges = append(edges, servernetworkcard.EdgeNetworkPort)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerNetworkCardMutation) EdgeCleared(name string) bool {
	switch name {
	case servernetworkcard.EdgeNetworkCardType:
		return m.clearednetwork_card_type
	case servernetworkcard.EdgeServer:
		return m.clearedserver
	case servernetworkcard.EdgeNetworkPort:
		return m.clearednetwork_port
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerNetworkCardMutation) ClearEdge(name string) error {
	switch name {
	case servernetworkcard.EdgeNetworkCardType:
		m.ClearNetworkCardType()
		return nil
	case servernetworkcard.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerNetworkCardMutation) ResetEdge(name string) error {
	switch name {
	case servernetworkcard.EdgeNetworkCardType:
		m.ResetNetworkCardType()
		return nil
	case servernetworkcard.EdgeServer:
		m.ResetServer()
		return nil
	case servernetworkcard.EdgeNetworkPort:
		m.ResetNetworkPort()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCard edge %s", name)
}

// ServerNetworkCardTypeMutation represents an operation that mutates the ServerNetworkCardType nodes in the graph.
type ServerNetworkCardTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *gidx.PrefixedID
	created_at          *time.Time
	updated_at          *time.Time
	vendor              *string
	model               *string
	port_count          *int
	addport_count       *int
	clearedFields       map[string]struct{}
	network_card        map[gidx.PrefixedID]struct{}
	removednetwork_card map[gidx.PrefixedID]struct{}
	clearednetwork_card bool
	done                bool
	oldValue            func(context.Context) (*ServerNetworkCardType, error)
	predicates          []predicate.ServerNetworkCardType
}

var _ ent.Mutation = (*ServerNetworkCardTypeMutation)(nil)

// servernetworkcardtypeOption allows management of the mutation configuration using functional options.
type servernetworkcardtypeOption func(*ServerNetworkCardTypeMutation)

// newServerNetworkCardTypeMutation creates new mutation for the ServerNetworkCardType entity.
func newServerNetworkCardTypeMutation(c config, op Op, opts ...servernetworkcardtypeOption) *ServerNetworkCardTypeMutation {
	m := &ServerNetworkCardTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerNetworkCardType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerNetworkCardTypeID sets the ID field of the mutation.
func withServerNetworkCardTypeID(id gidx.PrefixedID) servernetworkcardtypeOption {
	return func(m *ServerNetworkCardTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerNetworkCardType
		)
		m.oldValue = func(ctx context.Context) (*ServerNetworkCardType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerNetworkCardType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerNetworkCardType sets the old ServerNetworkCardType of the mutation.
func withServerNetworkCardType(node *ServerNetworkCardType) servernetworkcardtypeOption {
	return func(m *ServerNetworkCardTypeMutation) {
		m.oldValue = func(context.Context) (*ServerNetworkCardType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerNetworkCardTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerNetworkCardTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerNetworkCardType entities.
func (m *ServerNetworkCardTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerNetworkCardTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerNetworkCardTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerNetworkCardType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerNetworkCardTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerNetworkCardTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerNetworkCardType entity.
// If the ServerNetworkCardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerNetworkCardTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerNetworkCardTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerNetworkCardTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerNetworkCardType entity.
// If the ServerNetworkCardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerNetworkCardTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerNetworkCardTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerNetworkCardTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerNetworkCardType entity.
// If the ServerNetworkCardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerNetworkCardTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerNetworkCardTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerNetworkCardTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerNetworkCardType entity.
// If the ServerNetworkCardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerNetworkCardTypeMutation) ResetModel() {
	m.model = nil
}

// SetPortCount sets the "port_count" field.
func (m *ServerNetworkCardTypeMutation) SetPortCount(i int) {
	m.port_count = &i
	m.addport_count = nil
}

// PortCount returns the value of the "port_count" field in the mutation.
func (m *ServerNetworkCardTypeMutation) PortCount() (r int, exists bool) {
	v := m.port_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPortCount returns the old "port_count" field's value of the ServerNetworkCardType entity.
// If the ServerNetworkCardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkCardTypeMutation) OldPortCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPortCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPortCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPortCount: %w", err)
	}
	return oldValue.PortCount, nil
}

// AddPortCount adds i to the "port_count" field.
func (m *ServerNetworkCardTypeMutation) AddPortCount(i int) {
	if m.addport_count != nil {
		*m.addport_count += i
	} else {
		m.addport_count = &i
	}
}

// AddedPortCount returns the value that was added to the "port_count" field in this mutation.
func (m *ServerNetworkCardTypeMutation) AddedPortCount() (r int, exists bool) {
	v := m.addport_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPortCount resets all changes to the "port_count" field.
func (m *ServerNetworkCardTypeMutation) ResetPortCount() {
	m.port_count = nil
	m.addport_count = nil
}

// AddNetworkCardIDs adds the "network_card" edge to the ServerNetworkCard entity by ids.
func (m *ServerNetworkCardTypeMutation) AddNetworkCardIDs(ids ...gidx.PrefixedID) {
	if m.network_card == nil {
		m.network_card = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.network_card[ids[i]] = struct{}{}
	}
}

// ClearNetworkCard clears the "network_card" edge to the ServerNetworkCard entity.
func (m *ServerNetworkCardTypeMutation) ClearNetworkCard() {
	m.clearednetwork_card = true
}

// NetworkCardCleared reports if the "network_card" edge to the ServerNetworkCard entity was cleared.
func (m *ServerNetworkCardTypeMutation) NetworkCardCleared() bool {
	return m.clearednetwork_card
}

// RemoveNetworkCardIDs removes the "network_card" edge to the ServerNetworkCard entity by IDs.
func (m *ServerNetworkCardTypeMutation) RemoveNetworkCardIDs(ids ...gidx.PrefixedID) {
	if m.removednetwork_card == nil {
		m.removednetwork_card = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.network_card, ids[i])
		m.removednetwork_card[ids[i]] = struct{}{}
	}
}

// RemovedNetworkCard returns the removed IDs of the "network_card" edge to the ServerNetworkCard entity.
func (m *ServerNetworkCardTypeMutation) RemovedNetworkCardIDs() (ids []gidx.PrefixedID) {
	for id := range m.removednetwork_card {
		ids = append(ids, id)
	}
	return
}

// NetworkCardIDs returns the "network_card" edge IDs in the mutation.
func (m *ServerNetworkCardTypeMutation) NetworkCardIDs() (ids []gidx.PrefixedID) {
	for id := range m.network_card {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkCard resets all changes to the "network_card" edge.
func (m *ServerNetworkCardTypeMutation) ResetNetworkCard() {
	m.network_card = nil
	m.clearednetwork_card = false
	m.removednetwork_card = nil
}

// Where appends a list predicates to the ServerNetworkCardTypeMutation builder.
func (m *ServerNetworkCardTypeMutation) Where(ps ...predicate.ServerNetworkCardType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerNetworkCardTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerNetworkCardTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerNetworkCardType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerNetworkCardTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerNetworkCardTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerNetworkCardType).
func (m *ServerNetworkCardTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerNetworkCardTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, servernetworkcardtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servernetworkcardtype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, servernetworkcardtype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, servernetworkcardtype.FieldModel)
	}
	if m.port_count != nil {
		fields = append(fields, servernetworkcardtype.FieldPortCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerNetworkCardTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servernetworkcardtype.FieldCreatedAt:
		return m.CreatedAt()
	case servernetworkcardtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servernetworkcardtype.FieldVendor:
		return m.Vendor()
	case servernetworkcardtype.FieldModel:
		return m.Model()
	case servernetworkcardtype.FieldPortCount:
		return m.PortCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerNetworkCardTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servernetworkcardtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servernetworkcardtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servernetworkcardtype.FieldVendor:
		return m.OldVendor(ctx)
	case servernetworkcardtype.FieldModel:
		return m.OldModel(ctx)
	case servernetworkcardtype.FieldPortCount:
		return m.OldPortCount(ctx)
	}
	return nil, fmt.Errorf("unknown ServerNetworkCardType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkCardTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servernetworkcardtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servernetworkcardtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servernetworkcardtype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case servernetworkcardtype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case servernetworkcardtype.FieldPortCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPortCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCardType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerNetworkCardTypeMutation) AddedFields() []string {
	var fields []string
	if m.addport_count != nil {
		fields = append(fields, servernetworkcardtype.FieldPortCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerNetworkCardTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servernetworkcardtype.FieldPortCount:
		return m.AddedPortCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkCardTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servernetworkcardtype.FieldPortCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPortCount(v)
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCardType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerNetworkCardTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerNetworkCardTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerNetworkCardTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerNetworkCardType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerNetworkCardTypeMutation) ResetField(name string) error {
	switch name {
	case servernetworkcardtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servernetworkcardtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servernetworkcardtype.FieldVendor:
		m.ResetVendor()
		return nil
	case servernetworkcardtype.FieldModel:
		m.ResetModel()
		return nil
	case servernetworkcardtype.FieldPortCount:
		m.ResetPortCount()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCardType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerNetworkCardTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.network_card != nil {
		edges = append(edges, servernetworkcardtype.EdgeNetworkCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerNetworkCardTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servernetworkcardtype.EdgeNetworkCard:
		ids := make([]ent.Value, 0, len(m.network_card))
		for id := range m.network_card {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerNetworkCardTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednetwork_card != nil {
		edges = append(edges, servernetworkcardtype.EdgeNetworkCard)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerNetworkCardTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servernetworkcardtype.EdgeNetworkCard:
		ids := make([]ent.Value, 0, len(m.removednetwork_card))
		for id := range m.removednetwork_card {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerNetworkCardTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednetwork_card {
		edges = append(edges, servernetworkcardtype.EdgeNetworkCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerNetworkCardTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servernetworkcardtype.EdgeNetworkCard:
		return m.clearednetwork_card
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerNetworkCardTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerNetworkCardType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerNetworkCardTypeMutation) ResetEdge(name string) error {
	switch name {
	case servernetworkcardtype.EdgeNetworkCard:
		m.ResetNetworkCard()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkCardType edge %s", name)
}

// ServerNetworkPortMutation represents an operation that mutates the ServerNetworkPort nodes in the graph.
type ServerNetworkPortMutation struct {
	config
	op                  Op
	typ                 string
	id                  *gidx.PrefixedID
	created_at          *time.Time
	updated_at          *time.Time
	mac_address         *string
	clearedFields       map[string]struct{}
	network_card        *gidx.PrefixedID
	clearednetwork_card bool
	done                bool
	oldValue            func(context.Context) (*ServerNetworkPort, error)
	predicates          []predicate.ServerNetworkPort
}

var _ ent.Mutation = (*ServerNetworkPortMutation)(nil)

// servernetworkportOption allows management of the mutation configuration using functional options.
type servernetworkportOption func(*ServerNetworkPortMutation)

// newServerNetworkPortMutation creates new mutation for the ServerNetworkPort entity.
func newServerNetworkPortMutation(c config, op Op, opts ...servernetworkportOption) *ServerNetworkPortMutation {
	m := &ServerNetworkPortMutation{
		config:        c,
		op:            op,
		typ:           TypeServerNetworkPort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerNetworkPortID sets the ID field of the mutation.
func withServerNetworkPortID(id gidx.PrefixedID) servernetworkportOption {
	return func(m *ServerNetworkPortMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerNetworkPort
		)
		m.oldValue = func(ctx context.Context) (*ServerNetworkPort, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerNetworkPort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerNetworkPort sets the old ServerNetworkPort of the mutation.
func withServerNetworkPort(node *ServerNetworkPort) servernetworkportOption {
	return func(m *ServerNetworkPortMutation) {
		m.oldValue = func(context.Context) (*ServerNetworkPort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerNetworkPortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerNetworkPortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerNetworkPort entities.
func (m *ServerNetworkPortMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerNetworkPortMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerNetworkPortMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerNetworkPort.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerNetworkPortMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerNetworkPortMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerNetworkPort entity.
// If the ServerNetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkPortMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerNetworkPortMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerNetworkPortMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerNetworkPortMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerNetworkPort entity.
// If the ServerNetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkPortMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerNetworkPortMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *ServerNetworkPortMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *ServerNetworkPortMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the ServerNetworkPort entity.
// If the ServerNetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkPortMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *ServerNetworkPortMutation) ResetMACAddress() {
	m.mac_address = nil
}

// SetServerNetworkCardID sets the "server_network_card_id" field.
func (m *ServerNetworkPortMutation) SetServerNetworkCardID(gi gidx.PrefixedID) {
	m.network_card = &gi
}

// ServerNetworkCardID returns the value of the "server_network_card_id" field in the mutation.
func (m *ServerNetworkPortMutation) ServerNetworkCardID() (r gidx.PrefixedID, exists bool) {
	v := m.network_card
	if v == nil {
		return
	}
	return *v, true
}

// OldServerNetworkCardID returns the old "server_network_card_id" field's value of the ServerNetworkPort entity.
// If the ServerNetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerNetworkPortMutation) OldServerNetworkCardID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerNetworkCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerNetworkCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerNetworkCardID: %w", err)
	}
	return oldValue.ServerNetworkCardID, nil
}

// ResetServerNetworkCardID resets all changes to the "server_network_card_id" field.
func (m *ServerNetworkPortMutation) ResetServerNetworkCardID() {
	m.network_card = nil
}

// SetNetworkCardID sets the "network_card" edge to the ServerNetworkCard entity by id.
func (m *ServerNetworkPortMutation) SetNetworkCardID(id gidx.PrefixedID) {
	m.network_card = &id
}

// ClearNetworkCard clears the "network_card" edge to the ServerNetworkCard entity.
func (m *ServerNetworkPortMutation) ClearNetworkCard() {
	m.clearednetwork_card = true
}

// NetworkCardCleared reports if the "network_card" edge to the ServerNetworkCard entity was cleared.
func (m *ServerNetworkPortMutation) NetworkCardCleared() bool {
	return m.clearednetwork_card
}

// NetworkCardID returns the "network_card" edge ID in the mutation.
func (m *ServerNetworkPortMutation) NetworkCardID() (id gidx.PrefixedID, exists bool) {
	if m.network_card != nil {
		return *m.network_card, true
	}
	return
}

// NetworkCardIDs returns the "network_card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkCardID instead. It exists only for internal usage by the builders.
func (m *ServerNetworkPortMutation) NetworkCardIDs() (ids []gidx.PrefixedID) {
	if id := m.network_card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkCard resets all changes to the "network_card" edge.
func (m *ServerNetworkPortMutation) ResetNetworkCard() {
	m.network_card = nil
	m.clearednetwork_card = false
}

// Where appends a list predicates to the ServerNetworkPortMutation builder.
func (m *ServerNetworkPortMutation) Where(ps ...predicate.ServerNetworkPort) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerNetworkPortMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerNetworkPortMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerNetworkPort, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerNetworkPortMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerNetworkPortMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerNetworkPort).
func (m *ServerNetworkPortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerNetworkPortMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, servernetworkport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servernetworkport.FieldUpdatedAt)
	}
	if m.mac_address != nil {
		fields = append(fields, servernetworkport.FieldMACAddress)
	}
	if m.network_card != nil {
		fields = append(fields, servernetworkport.FieldServerNetworkCardID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerNetworkPortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servernetworkport.FieldCreatedAt:
		return m.CreatedAt()
	case servernetworkport.FieldUpdatedAt:
		return m.UpdatedAt()
	case servernetworkport.FieldMACAddress:
		return m.MACAddress()
	case servernetworkport.FieldServerNetworkCardID:
		return m.ServerNetworkCardID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerNetworkPortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servernetworkport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servernetworkport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servernetworkport.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case servernetworkport.FieldServerNetworkCardID:
		return m.OldServerNetworkCardID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerNetworkPort field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkPortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servernetworkport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servernetworkport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servernetworkport.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case servernetworkport.FieldServerNetworkCardID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerNetworkCardID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkPort field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerNetworkPortMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerNetworkPortMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerNetworkPortMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerNetworkPort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerNetworkPortMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerNetworkPortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerNetworkPortMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerNetworkPort nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerNetworkPortMutation) ResetField(name string) error {
	switch name {
	case servernetworkport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servernetworkport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servernetworkport.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case servernetworkport.FieldServerNetworkCardID:
		m.ResetServerNetworkCardID()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkPort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerNetworkPortMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.network_card != nil {
		edges = append(edges, servernetworkport.EdgeNetworkCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerNetworkPortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servernetworkport.EdgeNetworkCard:
		if id := m.network_card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerNetworkPortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerNetworkPortMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerNetworkPortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednetwork_card {
		edges = append(edges, servernetworkport.EdgeNetworkCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerNetworkPortMutation) EdgeCleared(name string) bool {
	switch name {
	case servernetworkport.EdgeNetworkCard:
		return m.clearednetwork_card
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerNetworkPortMutation) ClearEdge(name string) error {
	switch name {
	case servernetworkport.EdgeNetworkCard:
		m.ClearNetworkCard()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkPort unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerNetworkPortMutation) ResetEdge(name string) error {
	switch name {
	case servernetworkport.EdgeNetworkCard:
		m.ResetNetworkCard()
		return nil
	}
	return fmt.Errorf("unknown ServerNetworkPort edge %s", name)
}

// ServerPowerSupplyMutation represents an operation that mutates the ServerPowerSupply nodes in the graph.
type ServerPowerSupplyMutation struct {
	config
	op                              Op
	typ                             string
	id                              *gidx.PrefixedID
	created_at                      *time.Time
	updated_at                      *time.Time
	serial                          *string
	clearedFields                   map[string]struct{}
	server                          *gidx.PrefixedID
	clearedserver                   bool
	server_power_supply_type        *gidx.PrefixedID
	clearedserver_power_supply_type bool
	done                            bool
	oldValue                        func(context.Context) (*ServerPowerSupply, error)
	predicates                      []predicate.ServerPowerSupply
}

var _ ent.Mutation = (*ServerPowerSupplyMutation)(nil)

// serverpowersupplyOption allows management of the mutation configuration using functional options.
type serverpowersupplyOption func(*ServerPowerSupplyMutation)

// newServerPowerSupplyMutation creates new mutation for the ServerPowerSupply entity.
func newServerPowerSupplyMutation(c config, op Op, opts ...serverpowersupplyOption) *ServerPowerSupplyMutation {
	m := &ServerPowerSupplyMutation{
		config:        c,
		op:            op,
		typ:           TypeServerPowerSupply,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerPowerSupplyID sets the ID field of the mutation.
func withServerPowerSupplyID(id gidx.PrefixedID) serverpowersupplyOption {
	return func(m *ServerPowerSupplyMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerPowerSupply
		)
		m.oldValue = func(ctx context.Context) (*ServerPowerSupply, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerPowerSupply.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerPowerSupply sets the old ServerPowerSupply of the mutation.
func withServerPowerSupply(node *ServerPowerSupply) serverpowersupplyOption {
	return func(m *ServerPowerSupplyMutation) {
		m.oldValue = func(context.Context) (*ServerPowerSupply, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerPowerSupplyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerPowerSupplyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerPowerSupply entities.
func (m *ServerPowerSupplyMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerPowerSupplyMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerPowerSupplyMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerPowerSupply.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerPowerSupplyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerPowerSupplyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerPowerSupply entity.
// If the ServerPowerSupply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerPowerSupplyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerPowerSupplyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerPowerSupplyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerPowerSupply entity.
// If the ServerPowerSupply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerPowerSupplyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSerial sets the "serial" field.
func (m *ServerPowerSupplyMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ServerPowerSupplyMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the ServerPowerSupply entity.
// If the ServerPowerSupply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ServerPowerSupplyMutation) ResetSerial() {
	m.serial = nil
}

// SetServerPowerSupplyTypeID sets the "server_power_supply_type_id" field.
func (m *ServerPowerSupplyMutation) SetServerPowerSupplyTypeID(gi gidx.PrefixedID) {
	m.server_power_supply_type = &gi
}

// ServerPowerSupplyTypeID returns the value of the "server_power_supply_type_id" field in the mutation.
func (m *ServerPowerSupplyMutation) ServerPowerSupplyTypeID() (r gidx.PrefixedID, exists bool) {
	v := m.server_power_supply_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerPowerSupplyTypeID returns the old "server_power_supply_type_id" field's value of the ServerPowerSupply entity.
// If the ServerPowerSupply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyMutation) OldServerPowerSupplyTypeID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerPowerSupplyTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerPowerSupplyTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerPowerSupplyTypeID: %w", err)
	}
	return oldValue.ServerPowerSupplyTypeID, nil
}

// ResetServerPowerSupplyTypeID resets all changes to the "server_power_supply_type_id" field.
func (m *ServerPowerSupplyMutation) ResetServerPowerSupplyTypeID() {
	m.server_power_supply_type = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerPowerSupplyMutation) SetServerID(gi gidx.PrefixedID) {
	m.server = &gi
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerPowerSupplyMutation) ServerID() (r gidx.PrefixedID, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the ServerPowerSupply entity.
// If the ServerPowerSupply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyMutation) OldServerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerPowerSupplyMutation) ResetServerID() {
	m.server = nil
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerPowerSupplyMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerPowerSupplyMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerPowerSupplyMutation) ServerIDs() (ids []gidx.PrefixedID) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerPowerSupplyMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// ClearServerPowerSupplyType clears the "server_power_supply_type" edge to the ServerPowerSupplyType entity.
func (m *ServerPowerSupplyMutation) ClearServerPowerSupplyType() {
	m.clearedserver_power_supply_type = true
}

// ServerPowerSupplyTypeCleared reports if the "server_power_supply_type" edge to the ServerPowerSupplyType entity was cleared.
func (m *ServerPowerSupplyMutation) ServerPowerSupplyTypeCleared() bool {
	return m.clearedserver_power_supply_type
}

// ServerPowerSupplyTypeIDs returns the "server_power_supply_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerPowerSupplyTypeID instead. It exists only for internal usage by the builders.
func (m *ServerPowerSupplyMutation) ServerPowerSupplyTypeIDs() (ids []gidx.PrefixedID) {
	if id := m.server_power_supply_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerPowerSupplyType resets all changes to the "server_power_supply_type" edge.
func (m *ServerPowerSupplyMutation) ResetServerPowerSupplyType() {
	m.server_power_supply_type = nil
	m.clearedserver_power_supply_type = false
}

// Where appends a list predicates to the ServerPowerSupplyMutation builder.
func (m *ServerPowerSupplyMutation) Where(ps ...predicate.ServerPowerSupply) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerPowerSupplyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerPowerSupplyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerPowerSupply, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerPowerSupplyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerPowerSupplyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerPowerSupply).
func (m *ServerPowerSupplyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerPowerSupplyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, serverpowersupply.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverpowersupply.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, serverpowersupply.FieldSerial)
	}
	if m.server_power_supply_type != nil {
		fields = append(fields, serverpowersupply.FieldServerPowerSupplyTypeID)
	}
	if m.server != nil {
		fields = append(fields, serverpowersupply.FieldServerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerPowerSupplyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverpowersupply.FieldCreatedAt:
		return m.CreatedAt()
	case serverpowersupply.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverpowersupply.FieldSerial:
		return m.Serial()
	case serverpowersupply.FieldServerPowerSupplyTypeID:
		return m.ServerPowerSupplyTypeID()
	case serverpowersupply.FieldServerID:
		return m.ServerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerPowerSupplyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverpowersupply.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverpowersupply.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverpowersupply.FieldSerial:
		return m.OldSerial(ctx)
	case serverpowersupply.FieldServerPowerSupplyTypeID:
		return m.OldServerPowerSupplyTypeID(ctx)
	case serverpowersupply.FieldServerID:
		return m.OldServerID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerPowerSupply field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerPowerSupplyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverpowersupply.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverpowersupply.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverpowersupply.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case serverpowersupply.FieldServerPowerSupplyTypeID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerPowerSupplyTypeID(v)
		return nil
	case serverpowersupply.FieldServerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupply field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerPowerSupplyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerPowerSupplyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerPowerSupplyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerPowerSupply numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerPowerSupplyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerPowerSupplyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerPowerSupplyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerPowerSupply nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerPowerSupplyMutation) ResetField(name string) error {
	switch name {
	case serverpowersupply.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverpowersupply.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverpowersupply.FieldSerial:
		m.ResetSerial()
		return nil
	case serverpowersupply.FieldServerPowerSupplyTypeID:
		m.ResetServerPowerSupplyTypeID()
		return nil
	case serverpowersupply.FieldServerID:
		m.ResetServerID()
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupply field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerPowerSupplyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.server != nil {
		edges = append(edges, serverpowersupply.EdgeServer)
	}
	if m.server_power_supply_type != nil {
		edges = append(edges, serverpowersupply.EdgeServerPowerSupplyType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerPowerSupplyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverpowersupply.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	case serverpowersupply.EdgeServerPowerSupplyType:
		if id := m.server_power_supply_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerPowerSupplyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerPowerSupplyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerPowerSupplyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserver {
		edges = append(edges, serverpowersupply.EdgeServer)
	}
	if m.clearedserver_power_supply_type {
		edges = append(edges, serverpowersupply.EdgeServerPowerSupplyType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerPowerSupplyMutation) EdgeCleared(name string) bool {
	switch name {
	case serverpowersupply.EdgeServer:
		return m.clearedserver
	case serverpowersupply.EdgeServerPowerSupplyType:
		return m.clearedserver_power_supply_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerPowerSupplyMutation) ClearEdge(name string) error {
	switch name {
	case serverpowersupply.EdgeServer:
		m.ClearServer()
		return nil
	case serverpowersupply.EdgeServerPowerSupplyType:
		m.ClearServerPowerSupplyType()
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupply unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerPowerSupplyMutation) ResetEdge(name string) error {
	switch name {
	case serverpowersupply.EdgeServer:
		m.ResetServer()
		return nil
	case serverpowersupply.EdgeServerPowerSupplyType:
		m.ResetServerPowerSupplyType()
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupply edge %s", name)
}

// ServerPowerSupplyTypeMutation represents an operation that mutates the ServerPowerSupplyType nodes in the graph.
type ServerPowerSupplyTypeMutation struct {
	config
	op            Op
	typ           string
	id            *gidx.PrefixedID
	created_at    *time.Time
	updated_at    *time.Time
	vendor        *string
	model         *string
	watts         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ServerPowerSupplyType, error)
	predicates    []predicate.ServerPowerSupplyType
}

var _ ent.Mutation = (*ServerPowerSupplyTypeMutation)(nil)

// serverpowersupplytypeOption allows management of the mutation configuration using functional options.
type serverpowersupplytypeOption func(*ServerPowerSupplyTypeMutation)

// newServerPowerSupplyTypeMutation creates new mutation for the ServerPowerSupplyType entity.
func newServerPowerSupplyTypeMutation(c config, op Op, opts ...serverpowersupplytypeOption) *ServerPowerSupplyTypeMutation {
	m := &ServerPowerSupplyTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerPowerSupplyType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerPowerSupplyTypeID sets the ID field of the mutation.
func withServerPowerSupplyTypeID(id gidx.PrefixedID) serverpowersupplytypeOption {
	return func(m *ServerPowerSupplyTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerPowerSupplyType
		)
		m.oldValue = func(ctx context.Context) (*ServerPowerSupplyType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerPowerSupplyType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerPowerSupplyType sets the old ServerPowerSupplyType of the mutation.
func withServerPowerSupplyType(node *ServerPowerSupplyType) serverpowersupplytypeOption {
	return func(m *ServerPowerSupplyTypeMutation) {
		m.oldValue = func(context.Context) (*ServerPowerSupplyType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerPowerSupplyTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerPowerSupplyTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerPowerSupplyType entities.
func (m *ServerPowerSupplyTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerPowerSupplyTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerPowerSupplyTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerPowerSupplyType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerPowerSupplyTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerPowerSupplyTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerPowerSupplyType entity.
// If the ServerPowerSupplyType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerPowerSupplyTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerPowerSupplyTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerPowerSupplyTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerPowerSupplyType entity.
// If the ServerPowerSupplyType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerPowerSupplyTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVendor sets the "vendor" field.
func (m *ServerPowerSupplyTypeMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ServerPowerSupplyTypeMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ServerPowerSupplyType entity.
// If the ServerPowerSupplyType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyTypeMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ServerPowerSupplyTypeMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *ServerPowerSupplyTypeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ServerPowerSupplyTypeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the ServerPowerSupplyType entity.
// If the ServerPowerSupplyType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyTypeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ServerPowerSupplyTypeMutation) ResetModel() {
	m.model = nil
}

// SetWatts sets the "watts" field.
func (m *ServerPowerSupplyTypeMutation) SetWatts(s string) {
	m.watts = &s
}

// Watts returns the value of the "watts" field in the mutation.
func (m *ServerPowerSupplyTypeMutation) Watts() (r string, exists bool) {
	v := m.watts
	if v == nil {
		return
	}
	return *v, true
}

// OldWatts returns the old "watts" field's value of the ServerPowerSupplyType entity.
// If the ServerPowerSupplyType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerPowerSupplyTypeMutation) OldWatts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatts: %w", err)
	}
	return oldValue.Watts, nil
}

// ResetWatts resets all changes to the "watts" field.
func (m *ServerPowerSupplyTypeMutation) ResetWatts() {
	m.watts = nil
}

// Where appends a list predicates to the ServerPowerSupplyTypeMutation builder.
func (m *ServerPowerSupplyTypeMutation) Where(ps ...predicate.ServerPowerSupplyType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerPowerSupplyTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerPowerSupplyTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerPowerSupplyType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerPowerSupplyTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerPowerSupplyTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerPowerSupplyType).
func (m *ServerPowerSupplyTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerPowerSupplyTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, serverpowersupplytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serverpowersupplytype.FieldUpdatedAt)
	}
	if m.vendor != nil {
		fields = append(fields, serverpowersupplytype.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, serverpowersupplytype.FieldModel)
	}
	if m.watts != nil {
		fields = append(fields, serverpowersupplytype.FieldWatts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerPowerSupplyTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverpowersupplytype.FieldCreatedAt:
		return m.CreatedAt()
	case serverpowersupplytype.FieldUpdatedAt:
		return m.UpdatedAt()
	case serverpowersupplytype.FieldVendor:
		return m.Vendor()
	case serverpowersupplytype.FieldModel:
		return m.Model()
	case serverpowersupplytype.FieldWatts:
		return m.Watts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerPowerSupplyTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverpowersupplytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serverpowersupplytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serverpowersupplytype.FieldVendor:
		return m.OldVendor(ctx)
	case serverpowersupplytype.FieldModel:
		return m.OldModel(ctx)
	case serverpowersupplytype.FieldWatts:
		return m.OldWatts(ctx)
	}
	return nil, fmt.Errorf("unknown ServerPowerSupplyType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerPowerSupplyTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverpowersupplytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serverpowersupplytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serverpowersupplytype.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case serverpowersupplytype.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case serverpowersupplytype.FieldWatts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatts(v)
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupplyType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerPowerSupplyTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerPowerSupplyTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerPowerSupplyTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerPowerSupplyType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerPowerSupplyTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerPowerSupplyTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerPowerSupplyTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerPowerSupplyType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerPowerSupplyTypeMutation) ResetField(name string) error {
	switch name {
	case serverpowersupplytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serverpowersupplytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serverpowersupplytype.FieldVendor:
		m.ResetVendor()
		return nil
	case serverpowersupplytype.FieldModel:
		m.ResetModel()
		return nil
	case serverpowersupplytype.FieldWatts:
		m.ResetWatts()
		return nil
	}
	return fmt.Errorf("unknown ServerPowerSupplyType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerPowerSupplyTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerPowerSupplyTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerPowerSupplyTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerPowerSupplyTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerPowerSupplyTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerPowerSupplyTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerPowerSupplyTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServerPowerSupplyType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerPowerSupplyTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServerPowerSupplyType edge %s", name)
}

// ServerTypeMutation represents an operation that mutates the ServerType nodes in the graph.
type ServerTypeMutation struct {
	config
	op             Op
	typ            string
	id             *gidx.PrefixedID
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	owner_id       *gidx.PrefixedID
	clearedFields  map[string]struct{}
	servers        map[gidx.PrefixedID]struct{}
	removedservers map[gidx.PrefixedID]struct{}
	clearedservers bool
	done           bool
	oldValue       func(context.Context) (*ServerType, error)
	predicates     []predicate.ServerType
}

var _ ent.Mutation = (*ServerTypeMutation)(nil)

// servertypeOption allows management of the mutation configuration using functional options.
type servertypeOption func(*ServerTypeMutation)

// newServerTypeMutation creates new mutation for the ServerType entity.
func newServerTypeMutation(c config, op Op, opts ...servertypeOption) *ServerTypeMutation {
	m := &ServerTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerTypeID sets the ID field of the mutation.
func withServerTypeID(id gidx.PrefixedID) servertypeOption {
	return func(m *ServerTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerType
		)
		m.oldValue = func(ctx context.Context) (*ServerType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerType sets the old ServerType of the mutation.
func withServerType(node *ServerType) servertypeOption {
	return func(m *ServerTypeMutation) {
		m.oldValue = func(context.Context) (*ServerType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerType entities.
func (m *ServerTypeMutation) SetID(id gidx.PrefixedID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerTypeMutation) ID() (id gidx.PrefixedID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerTypeMutation) IDs(ctx context.Context) ([]gidx.PrefixedID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gidx.PrefixedID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServerTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServerTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServerTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServerTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServerTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServerTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServerTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServerTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServerTypeMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerTypeMutation) SetOwnerID(gi gidx.PrefixedID) {
	m.owner_id = &gi
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerTypeMutation) OwnerID() (r gidx.PrefixedID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ServerType entity.
// If the ServerType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTypeMutation) OldOwnerID(ctx context.Context) (v gidx.PrefixedID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerTypeMutation) ResetOwnerID() {
	m.owner_id = nil
}

// AddServerIDs adds the "servers" edge to the Server entity by ids.
func (m *ServerTypeMutation) AddServerIDs(ids ...gidx.PrefixedID) {
	if m.servers == nil {
		m.servers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the Server entity.
func (m *ServerTypeMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the Server entity was cleared.
func (m *ServerTypeMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the Server entity by IDs.
func (m *ServerTypeMutation) RemoveServerIDs(ids ...gidx.PrefixedID) {
	if m.removedservers == nil {
		m.removedservers = make(map[gidx.PrefixedID]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the Server entity.
func (m *ServerTypeMutation) RemovedServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *ServerTypeMutation) ServersIDs() (ids []gidx.PrefixedID) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *ServerTypeMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Where appends a list predicates to the ServerTypeMutation builder.
func (m *ServerTypeMutation) Where(ps ...predicate.ServerType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerType).
func (m *ServerTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, servertype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servertype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, servertype.FieldName)
	}
	if m.owner_id != nil {
		fields = append(fields, servertype.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servertype.FieldCreatedAt:
		return m.CreatedAt()
	case servertype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servertype.FieldName:
		return m.Name()
	case servertype.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servertype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servertype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servertype.FieldName:
		return m.OldName(ctx)
	case servertype.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown ServerType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servertype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servertype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servertype.FieldOwnerID:
		v, ok := value.(gidx.PrefixedID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerTypeMutation) ResetField(name string) error {
	switch name {
	case servertype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servertype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servertype.FieldName:
		m.ResetName()
		return nil
	case servertype.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservers {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servertype.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerTypeMutation) ResetEdge(name string) error {
	switch name {
	case servertype.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown ServerType edge %s", name)
}
